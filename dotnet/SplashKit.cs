using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using __sklib_ptr = System.IntPtr;

namespace SplashKitSDK
{
  public static class SplashKit
  {
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_bool(bool v) { return v ? -1 : 0; }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static bool __skadapter__to_bool(int v) { return v != 0; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_ptr(IntPtr v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_ptr(IntPtr v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte __skadapter__to_sklib_int8_t(byte v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte __skadapter__to_int8_t(byte v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_int(int v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_int(int v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static short __skadapter__to_sklib_short(short v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static short __skadapter__to_short(short v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static long __skadapter__to_sklib_int64_t(long v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static long __skadapter__to_int64_t(long v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float __skadapter__to_sklib_float(float v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static float __skadapter__to_float(float v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static double __skadapter__to_sklib_double(double v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static double __skadapter__to_double(double v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte __skadapter__to_sklib_byte(byte v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte __skadapter__to_byte(byte v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static char __skadapter__to_sklib_char(char v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static char __skadapter__to_char(char v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte __skadapter__to_sklib_unsigned_char(byte v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte __skadapter__to_unsigned_char(byte v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static uint __skadapter__to_sklib_unsigned_int(uint v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static uint __skadapter__to_unsigned_int(uint v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static ushort __skadapter__to_sklib_unsigned_short(ushort v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static ushort __skadapter__to_unsigned_short(ushort v) { return v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_key_code(KeyCode v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static KeyCode __skadapter__to_key_code(int v) { return (KeyCode)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_log_level(LogLevel v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static LogLevel __skadapter__to_log_level(int v) { return (LogLevel)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_log_mode(LogMode v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static LogMode __skadapter__to_log_mode(int v) { return (LogMode)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_mouse_button(MouseButton v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static MouseButton __skadapter__to_mouse_button(int v) { return (MouseButton)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_connection_type(ConnectionType v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static ConnectionType __skadapter__to_connection_type(int v) { return (ConnectionType)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_resource_kind(ResourceKind v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static ResourceKind __skadapter__to_resource_kind(int v) { return (ResourceKind)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_collision_test_kind(CollisionTestKind v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static CollisionTestKind __skadapter__to_collision_test_kind(int v) { return (CollisionTestKind)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_sprite_event_kind(SpriteEventKind v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static SpriteEventKind __skadapter__to_sprite_event_kind(int v) { return (SpriteEventKind)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_drawing_dest(DrawingDest v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static DrawingDest __skadapter__to_drawing_dest(int v) { return (DrawingDest)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_font_style(FontStyle v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static FontStyle __skadapter__to_font_style(int v) { return (FontStyle)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_http_status_code(HttpStatusCode v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static HttpStatusCode __skadapter__to_http_status_code(int v) { return (HttpStatusCode)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_interface_style(InterfaceStyle v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static InterfaceStyle __skadapter__to_interface_style(int v) { return (InterfaceStyle)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_pin_modes(PinModes v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static PinModes __skadapter__to_pin_modes(int v) { return (PinModes)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_pin_values(PinValues v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static PinValues __skadapter__to_pin_values(int v) { return (PinValues)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_pins(Pins v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Pins __skadapter__to_pins(int v) { return (Pins)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_pull_up_down(PullUpDown v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static PullUpDown __skadapter__to_pull_up_down(int v) { return (PullUpDown)v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int __skadapter__to_sklib_http_method(HttpMethod v) { return (int)v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static HttpMethod __skadapter__to_http_method(int v) { return (HttpMethod)v; }

    [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi ) ]
    private struct __sklib_string
    {
      internal IntPtr str;
      internal int    size;
      internal IntPtr ptr;
    }

    private static __sklib_string __skadapter__to_sklib_string(string s)
    {
      s = s == null ? "": s;
      int totalLength = s.Length + 1;
      __sklib_string result;
      result.size = totalLength;

      result.str = Marshal.AllocHGlobal(totalLength);

      Marshal.Copy(System.Text.Encoding.ASCII.GetBytes(s), 0, result.str, s.Length);
      Marshal.WriteByte(result.str, s.Length, 0);

      result.ptr = IntPtr.Zero;
      return result;
    }

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free__sklib_string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free__sklib_string(__sklib_string s);

    private static void __skadapter__free__sklib_string(ref __sklib_string s)
    {
      Marshal.FreeHGlobal(s.str);
      s.str = IntPtr.Zero;
    }

    private static string __skadapter__to_string(__sklib_string s)
    {
      byte[] bytes = new byte[s.size];
      Marshal.Copy(s.str, bytes, 0, bytes.Length);

      string result = System.Text.Encoding.ASCII.GetString (bytes);
      __sklib__free__sklib_string(s);
      return result;
    }

    private static __sklib_matrix_2d __skadapter__to_sklib_matrix_2d(Matrix2D v)
    {
      __sklib_matrix_2d __skreturn;
      __skreturn.Elements_0 = __skadapter__to_sklib_double(v.Elements[0,0]);
      __skreturn.Elements_1 = __skadapter__to_sklib_double(v.Elements[0,1]);
      __skreturn.Elements_2 = __skadapter__to_sklib_double(v.Elements[0,2]);
      __skreturn.Elements_3 = __skadapter__to_sklib_double(v.Elements[1,0]);
      __skreturn.Elements_4 = __skadapter__to_sklib_double(v.Elements[1,1]);
      __skreturn.Elements_5 = __skadapter__to_sklib_double(v.Elements[1,2]);
      __skreturn.Elements_6 = __skadapter__to_sklib_double(v.Elements[2,0]);
      __skreturn.Elements_7 = __skadapter__to_sklib_double(v.Elements[2,1]);
      __skreturn.Elements_8 = __skadapter__to_sklib_double(v.Elements[2,2]);
      return __skreturn;
    }
    private static Matrix2D __skadapter__to_matrix_2d(__sklib_matrix_2d v)
    {
      Matrix2D __skreturn;
      __skreturn.Elements = new double[3,3];
      __skreturn.Elements[0,0] = __skadapter__to_double(v.Elements_0);
      __skreturn.Elements[0,1] = __skadapter__to_double(v.Elements_1);
      __skreturn.Elements[0,2] = __skadapter__to_double(v.Elements_2);
      __skreturn.Elements[1,0] = __skadapter__to_double(v.Elements_3);
      __skreturn.Elements[1,1] = __skadapter__to_double(v.Elements_4);
      __skreturn.Elements[1,2] = __skadapter__to_double(v.Elements_5);
      __skreturn.Elements[2,0] = __skadapter__to_double(v.Elements_6);
      __skreturn.Elements[2,1] = __skadapter__to_double(v.Elements_7);
      __skreturn.Elements[2,2] = __skadapter__to_double(v.Elements_8);
      return __skreturn;
    }


    private static __sklib_point_2d __skadapter__to_sklib_point_2d(Point2D v)
    {
      __sklib_point_2d __skreturn;
      __skreturn.X = __skadapter__to_sklib_double(v.X);
      __skreturn.Y = __skadapter__to_sklib_double(v.Y);
      return __skreturn;
    }
    private static Point2D __skadapter__to_point_2d(__sklib_point_2d v)
    {
      Point2D __skreturn;
      __skreturn.X = __skadapter__to_double(v.X);
      __skreturn.Y = __skadapter__to_double(v.Y);
      return __skreturn;
    }


    private static __sklib_circle __skadapter__to_sklib_circle(Circle v)
    {
      __sklib_circle __skreturn;
      __skreturn.Center = __skadapter__to_sklib_point_2d(v.Center);
      __skreturn.Radius = __skadapter__to_sklib_double(v.Radius);
      return __skreturn;
    }
    private static Circle __skadapter__to_circle(__sklib_circle v)
    {
      Circle __skreturn;
      __skreturn.Center = __skadapter__to_point_2d(v.Center);
      __skreturn.Radius = __skadapter__to_double(v.Radius);
      return __skreturn;
    }


    private static __sklib_color __skadapter__to_sklib_color(Color v)
    {
      __sklib_color __skreturn;
      __skreturn.R = __skadapter__to_sklib_float(v.R);
      __skreturn.G = __skadapter__to_sklib_float(v.G);
      __skreturn.B = __skadapter__to_sklib_float(v.B);
      __skreturn.A = __skadapter__to_sklib_float(v.A);
      return __skreturn;
    }
    private static Color __skadapter__to_color(__sklib_color v)
    {
      Color __skreturn;
      __skreturn.R = __skadapter__to_float(v.R);
      __skreturn.G = __skadapter__to_float(v.G);
      __skreturn.B = __skadapter__to_float(v.B);
      __skreturn.A = __skadapter__to_float(v.A);
      return __skreturn;
    }


    private static __sklib_rectangle __skadapter__to_sklib_rectangle(Rectangle v)
    {
      __sklib_rectangle __skreturn;
      __skreturn.X = __skadapter__to_sklib_double(v.X);
      __skreturn.Y = __skadapter__to_sklib_double(v.Y);
      __skreturn.Width = __skadapter__to_sklib_double(v.Width);
      __skreturn.Height = __skadapter__to_sklib_double(v.Height);
      return __skreturn;
    }
    private static Rectangle __skadapter__to_rectangle(__sklib_rectangle v)
    {
      Rectangle __skreturn;
      __skreturn.X = __skadapter__to_double(v.X);
      __skreturn.Y = __skadapter__to_double(v.Y);
      __skreturn.Width = __skadapter__to_double(v.Width);
      __skreturn.Height = __skadapter__to_double(v.Height);
      return __skreturn;
    }


    private static __sklib_drawing_options __skadapter__to_sklib_drawing_options(DrawingOptions v)
    {
      __sklib_drawing_options __skreturn;
      __skreturn.Dest = __skadapter__to_sklib_ptr(v.Dest);
      __skreturn.ScaleX = __skadapter__to_sklib_float(v.ScaleX);
      __skreturn.ScaleY = __skadapter__to_sklib_float(v.ScaleY);
      __skreturn.Angle = __skadapter__to_sklib_float(v.Angle);
      __skreturn.AnchorOffsetX = __skadapter__to_sklib_float(v.AnchorOffsetX);
      __skreturn.AnchorOffsetY = __skadapter__to_sklib_float(v.AnchorOffsetY);
      __skreturn.FlipX = __skadapter__to_sklib_bool(v.FlipX);
      __skreturn.FlipY = __skadapter__to_sklib_bool(v.FlipY);
      __skreturn.IsPart = __skadapter__to_sklib_bool(v.IsPart);
      __skreturn.Part = __skadapter__to_sklib_rectangle(v.Part);
      __skreturn.DrawCell = __skadapter__to_sklib_int(v.DrawCell);
      __skreturn.Camera = __skadapter__to_sklib_drawing_dest(v.Camera);
      __skreturn.LineWidth = __skadapter__to_sklib_int(v.LineWidth);
      __skreturn.Anim = __skadapter__to_sklib_animation(v.Anim);
      return __skreturn;
    }
    private static DrawingOptions __skadapter__to_drawing_options(__sklib_drawing_options v)
    {
      DrawingOptions __skreturn;
      __skreturn.Dest = __skadapter__to_ptr(v.Dest);
      __skreturn.ScaleX = __skadapter__to_float(v.ScaleX);
      __skreturn.ScaleY = __skadapter__to_float(v.ScaleY);
      __skreturn.Angle = __skadapter__to_float(v.Angle);
      __skreturn.AnchorOffsetX = __skadapter__to_float(v.AnchorOffsetX);
      __skreturn.AnchorOffsetY = __skadapter__to_float(v.AnchorOffsetY);
      __skreturn.FlipX = __skadapter__to_bool(v.FlipX);
      __skreturn.FlipY = __skadapter__to_bool(v.FlipY);
      __skreturn.IsPart = __skadapter__to_bool(v.IsPart);
      __skreturn.Part = __skadapter__to_rectangle(v.Part);
      __skreturn.DrawCell = __skadapter__to_int(v.DrawCell);
      __skreturn.Camera = __skadapter__to_drawing_dest(v.Camera);
      __skreturn.LineWidth = __skadapter__to_int(v.LineWidth);
      __skreturn.Anim = __skadapter__to_animation(v.Anim);
      return __skreturn;
    }


    private static __sklib_line __skadapter__to_sklib_line(Line v)
    {
      __sklib_line __skreturn;
      __skreturn.StartPoint = __skadapter__to_sklib_point_2d(v.StartPoint);
      __skreturn.EndPoint = __skadapter__to_sklib_point_2d(v.EndPoint);
      return __skreturn;
    }
    private static Line __skadapter__to_line(__sklib_line v)
    {
      Line __skreturn;
      __skreturn.StartPoint = __skadapter__to_point_2d(v.StartPoint);
      __skreturn.EndPoint = __skadapter__to_point_2d(v.EndPoint);
      return __skreturn;
    }


    private static __sklib_quad __skadapter__to_sklib_quad(Quad v)
    {
      __sklib_quad __skreturn;
      __skreturn.Points_0 = __skadapter__to_sklib_point_2d(v.Points[0]);
      __skreturn.Points_1 = __skadapter__to_sklib_point_2d(v.Points[1]);
      __skreturn.Points_2 = __skadapter__to_sklib_point_2d(v.Points[2]);
      __skreturn.Points_3 = __skadapter__to_sklib_point_2d(v.Points[3]);
      return __skreturn;
    }
    private static Quad __skadapter__to_quad(__sklib_quad v)
    {
      Quad __skreturn;
      __skreturn.Points = new Point2D[4];
      __skreturn.Points[0] = __skadapter__to_point_2d(v.Points_0);
      __skreturn.Points[1] = __skadapter__to_point_2d(v.Points_1);
      __skreturn.Points[2] = __skadapter__to_point_2d(v.Points_2);
      __skreturn.Points[3] = __skadapter__to_point_2d(v.Points_3);
      return __skreturn;
    }


    private static __sklib_triangle __skadapter__to_sklib_triangle(Triangle v)
    {
      __sklib_triangle __skreturn;
      __skreturn.Points_0 = __skadapter__to_sklib_point_2d(v.Points[0]);
      __skreturn.Points_1 = __skadapter__to_sklib_point_2d(v.Points[1]);
      __skreturn.Points_2 = __skadapter__to_sklib_point_2d(v.Points[2]);
      return __skreturn;
    }
    private static Triangle __skadapter__to_triangle(__sklib_triangle v)
    {
      Triangle __skreturn;
      __skreturn.Points = new Point2D[3];
      __skreturn.Points[0] = __skadapter__to_point_2d(v.Points_0);
      __skreturn.Points[1] = __skadapter__to_point_2d(v.Points_1);
      __skreturn.Points[2] = __skadapter__to_point_2d(v.Points_2);
      return __skreturn;
    }


    private static __sklib_vector_2d __skadapter__to_sklib_vector_2d(Vector2D v)
    {
      __sklib_vector_2d __skreturn;
      __skreturn.X = __skadapter__to_sklib_double(v.X);
      __skreturn.Y = __skadapter__to_sklib_double(v.Y);
      return __skreturn;
    }
    private static Vector2D __skadapter__to_vector_2d(__sklib_vector_2d v)
    {
      Vector2D __skreturn;
      __skreturn.X = __skadapter__to_double(v.X);
      __skreturn.Y = __skadapter__to_double(v.Y);
      return __skreturn;
    }


    // Based on: https://social.msdn.microsoft.com/Forums/vstudio/en-US/0f5ba27d-92c2-4b41-b717-16e759b68087/how-to-marshal-an-array-of-struct-pointer?forum=csharpgeneral
    private static IntPtr ToIntPtr<T>(T[] items) where T : struct
    {
        IntPtr result, tmp = IntPtr.Zero;

        int length = Marshal.SizeOf<T>();
        int totalLength = length * items.Length;

        result = Marshal.AllocHGlobal(totalLength);

        int start = 0;
        byte[] data = new byte[totalLength];   //prepare to get the whole items array to this bytes array
        foreach (T item in items)
        {
            tmp = Marshal.AllocHGlobal(length);
            Marshal.StructureToPtr(item, tmp, false);

            Marshal.Copy(tmp, data, start, length);
            start += length;
            Marshal.FreeHGlobal(tmp);
        }
        Marshal.Copy(data, 0, result, totalLength);

        return result;
    }

    private static T[] FromIntPtr<T>(IntPtr ptr, int count) where T : struct
    {
        T[] result = new T[count];
        IntPtr tmp;

        int size = Marshal.SizeOf<T>();
        int totalSize = size * count;
        byte[] data = new byte[totalSize];

        Marshal.Copy(ptr, data, 0, totalSize);

        tmp = Marshal.AllocHGlobal(size);

        for (int i = 0; i < count; i++)
        {
          Marshal.Copy(data, i * size, tmp, size);
          result[i] = Marshal.PtrToStructure<T>(tmp);
        }

        Marshal.FreeHGlobal(tmp);
        return result;
    }


    [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi )]
    private struct __sklib_vector_string    {
      internal IntPtr _data_from_app;
      public __sklib_string[] data_from_app
      {
        set
        {
          _data_from_app = ToIntPtr(value);
        }
      }
      public uint size_from_app;
      private IntPtr _data_from_lib;
      public __sklib_string[] data_from_lib
      {
        get
        {
          return FromIntPtr<__sklib_string>(_data_from_lib, (int)size_from_lib);
        }
      }
      public uint size_from_lib;
    }

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free__sklib_vector_string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free__sklib_vector_string(__sklib_vector_string v);

    private static void __skadapter__free__sklib_vector_string(ref __sklib_vector_string v)
    {
      // System.Console.WriteLine("Freeing data");
      Marshal.FreeHGlobal(v._data_from_app);
    }
    private static __sklib_vector_string __skadapter__to_sklib_vector_string(List<string> v)
    {
      int i = 0;
      __sklib_vector_string result = new __sklib_vector_string();

      result.size_from_lib = 0;
      result.size_from_app = (uint)v.Count;
      __sklib_string[] tmp = new __sklib_string[result.size_from_app];

      foreach(string d in v)
      {
        tmp[i] = __skadapter__to_sklib_string(v[i]);
        i++;
      }

      result.data_from_app = tmp;
      return result;
    }
    private static List<string> __skadapter__to_vector_string(__sklib_vector_string v)
    {
      List<string> result = new List<string>();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        result.Add(__skadapter__to_string(v.data_from_lib[i]));
      }
      __sklib__free__sklib_vector_string(v);
      return result;
    }
    private static void __skadapter__update_from_vector_string(ref __sklib_vector_string v, List<string> __skreturn)
    {
      __skreturn.Clear();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        __skreturn.Add(__skadapter__to_string(v.data_from_lib[i]));
      }
            __sklib__free__sklib_vector_string(v);
    }

    [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi )]
    private struct __sklib_vector_line    {
      internal IntPtr _data_from_app;
      public __sklib_line[] data_from_app
      {
        set
        {
          _data_from_app = ToIntPtr(value);
        }
      }
      public uint size_from_app;
      private IntPtr _data_from_lib;
      public __sklib_line[] data_from_lib
      {
        get
        {
          return FromIntPtr<__sklib_line>(_data_from_lib, (int)size_from_lib);
        }
      }
      public uint size_from_lib;
    }

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free__sklib_vector_line", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free__sklib_vector_line(__sklib_vector_line v);

    private static void __skadapter__free__sklib_vector_line(ref __sklib_vector_line v)
    {
      // System.Console.WriteLine("Freeing data");
      Marshal.FreeHGlobal(v._data_from_app);
    }
    private static __sklib_vector_line __skadapter__to_sklib_vector_line(List<Line> v)
    {
      int i = 0;
      __sklib_vector_line result = new __sklib_vector_line();

      result.size_from_lib = 0;
      result.size_from_app = (uint)v.Count;
      __sklib_line[] tmp = new __sklib_line[result.size_from_app];

      foreach(Line d in v)
      {
        tmp[i] = __skadapter__to_sklib_line(v[i]);
        i++;
      }

      result.data_from_app = tmp;
      return result;
    }
    private static List<Line> __skadapter__to_vector_line(__sklib_vector_line v)
    {
      List<Line> result = new List<Line>();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        result.Add(__skadapter__to_line(v.data_from_lib[i]));
      }
      __sklib__free__sklib_vector_line(v);
      return result;
    }
    private static void __skadapter__update_from_vector_line(ref __sklib_vector_line v, List<Line> __skreturn)
    {
      __skreturn.Clear();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        __skreturn.Add(__skadapter__to_line(v.data_from_lib[i]));
      }
            __sklib__free__sklib_vector_line(v);
    }

    [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi )]
    private struct __sklib_vector_int8_t    {
      internal IntPtr _data_from_app;
      public byte[] data_from_app
      {
        set
        {
          _data_from_app = ToIntPtr(value);
        }
      }
      public uint size_from_app;
      private IntPtr _data_from_lib;
      public byte[] data_from_lib
      {
        get
        {
          return FromIntPtr<byte>(_data_from_lib, (int)size_from_lib);
        }
      }
      public uint size_from_lib;
    }

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free__sklib_vector_int8_t", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free__sklib_vector_int8_t(__sklib_vector_int8_t v);

    private static void __skadapter__free__sklib_vector_int8_t(ref __sklib_vector_int8_t v)
    {
      // System.Console.WriteLine("Freeing data");
      Marshal.FreeHGlobal(v._data_from_app);
    }
    private static __sklib_vector_int8_t __skadapter__to_sklib_vector_int8_t(List<byte> v)
    {
      int i = 0;
      __sklib_vector_int8_t result = new __sklib_vector_int8_t();

      result.size_from_lib = 0;
      result.size_from_app = (uint)v.Count;
      byte[] tmp = new byte[result.size_from_app];

      foreach(byte d in v)
      {
        tmp[i] = __skadapter__to_sklib_int8_t(v[i]);
        i++;
      }

      result.data_from_app = tmp;
      return result;
    }
    private static List<byte> __skadapter__to_vector_int8_t(__sklib_vector_int8_t v)
    {
      List<byte> result = new List<byte>();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        result.Add(__skadapter__to_int8_t(v.data_from_lib[i]));
      }
      __sklib__free__sklib_vector_int8_t(v);
      return result;
    }
    private static void __skadapter__update_from_vector_int8_t(ref __sklib_vector_int8_t v, List<byte> __skreturn)
    {
      __skreturn.Clear();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        __skreturn.Add(__skadapter__to_int8_t(v.data_from_lib[i]));
      }
            __sklib__free__sklib_vector_int8_t(v);
    }

    [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi )]
    private struct __sklib_vector_triangle    {
      internal IntPtr _data_from_app;
      public __sklib_triangle[] data_from_app
      {
        set
        {
          _data_from_app = ToIntPtr(value);
        }
      }
      public uint size_from_app;
      private IntPtr _data_from_lib;
      public __sklib_triangle[] data_from_lib
      {
        get
        {
          return FromIntPtr<__sklib_triangle>(_data_from_lib, (int)size_from_lib);
        }
      }
      public uint size_from_lib;
    }

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free__sklib_vector_triangle", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free__sklib_vector_triangle(__sklib_vector_triangle v);

    private static void __skadapter__free__sklib_vector_triangle(ref __sklib_vector_triangle v)
    {
      // System.Console.WriteLine("Freeing data");
      Marshal.FreeHGlobal(v._data_from_app);
    }
    private static __sklib_vector_triangle __skadapter__to_sklib_vector_triangle(List<Triangle> v)
    {
      int i = 0;
      __sklib_vector_triangle result = new __sklib_vector_triangle();

      result.size_from_lib = 0;
      result.size_from_app = (uint)v.Count;
      __sklib_triangle[] tmp = new __sklib_triangle[result.size_from_app];

      foreach(Triangle d in v)
      {
        tmp[i] = __skadapter__to_sklib_triangle(v[i]);
        i++;
      }

      result.data_from_app = tmp;
      return result;
    }
    private static List<Triangle> __skadapter__to_vector_triangle(__sklib_vector_triangle v)
    {
      List<Triangle> result = new List<Triangle>();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        result.Add(__skadapter__to_triangle(v.data_from_lib[i]));
      }
      __sklib__free__sklib_vector_triangle(v);
      return result;
    }
    private static void __skadapter__update_from_vector_triangle(ref __sklib_vector_triangle v, List<Triangle> __skreturn)
    {
      __skreturn.Clear();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        __skreturn.Add(__skadapter__to_triangle(v.data_from_lib[i]));
      }
            __sklib__free__sklib_vector_triangle(v);
    }

    [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi )]
    private struct __sklib_vector_double    {
      internal IntPtr _data_from_app;
      public double[] data_from_app
      {
        set
        {
          _data_from_app = ToIntPtr(value);
        }
      }
      public uint size_from_app;
      private IntPtr _data_from_lib;
      public double[] data_from_lib
      {
        get
        {
          return FromIntPtr<double>(_data_from_lib, (int)size_from_lib);
        }
      }
      public uint size_from_lib;
    }

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free__sklib_vector_double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free__sklib_vector_double(__sklib_vector_double v);

    private static void __skadapter__free__sklib_vector_double(ref __sklib_vector_double v)
    {
      // System.Console.WriteLine("Freeing data");
      Marshal.FreeHGlobal(v._data_from_app);
    }
    private static __sklib_vector_double __skadapter__to_sklib_vector_double(List<double> v)
    {
      int i = 0;
      __sklib_vector_double result = new __sklib_vector_double();

      result.size_from_lib = 0;
      result.size_from_app = (uint)v.Count;
      double[] tmp = new double[result.size_from_app];

      foreach(double d in v)
      {
        tmp[i] = __skadapter__to_sklib_double(v[i]);
        i++;
      }

      result.data_from_app = tmp;
      return result;
    }
    private static List<double> __skadapter__to_vector_double(__sklib_vector_double v)
    {
      List<double> result = new List<double>();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        result.Add(__skadapter__to_double(v.data_from_lib[i]));
      }
      __sklib__free__sklib_vector_double(v);
      return result;
    }
    private static void __skadapter__update_from_vector_double(ref __sklib_vector_double v, List<double> __skreturn)
    {
      __skreturn.Clear();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        __skreturn.Add(__skadapter__to_double(v.data_from_lib[i]));
      }
            __sklib__free__sklib_vector_double(v);
    }

    [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi )]
    private struct __sklib_vector_json    {
      internal IntPtr _data_from_app;
      public __sklib_ptr[] data_from_app
      {
        set
        {
          _data_from_app = ToIntPtr(value);
        }
      }
      public uint size_from_app;
      private IntPtr _data_from_lib;
      public __sklib_ptr[] data_from_lib
      {
        get
        {
          return FromIntPtr<__sklib_ptr>(_data_from_lib, (int)size_from_lib);
        }
      }
      public uint size_from_lib;
    }

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free__sklib_vector_json", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free__sklib_vector_json(__sklib_vector_json v);

    private static void __skadapter__free__sklib_vector_json(ref __sklib_vector_json v)
    {
      // System.Console.WriteLine("Freeing data");
      Marshal.FreeHGlobal(v._data_from_app);
    }
    private static __sklib_vector_json __skadapter__to_sklib_vector_json(List<Json> v)
    {
      int i = 0;
      __sklib_vector_json result = new __sklib_vector_json();

      result.size_from_lib = 0;
      result.size_from_app = (uint)v.Count;
      __sklib_ptr[] tmp = new __sklib_ptr[result.size_from_app];

      foreach(Json d in v)
      {
        tmp[i] = __skadapter__to_sklib_json(v[i]);
        i++;
      }

      result.data_from_app = tmp;
      return result;
    }
    private static List<Json> __skadapter__to_vector_json(__sklib_vector_json v)
    {
      List<Json> result = new List<Json>();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        result.Add(__skadapter__to_json(v.data_from_lib[i]));
      }
      __sklib__free__sklib_vector_json(v);
      return result;
    }
    private static void __skadapter__update_from_vector_json(ref __sklib_vector_json v, List<Json> __skreturn)
    {
      __skreturn.Clear();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        __skreturn.Add(__skadapter__to_json(v.data_from_lib[i]));
      }
            __sklib__free__sklib_vector_json(v);
    }

    [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi )]
    private struct __sklib_vector_bool    {
      internal IntPtr _data_from_app;
      public int[] data_from_app
      {
        set
        {
          _data_from_app = ToIntPtr(value);
        }
      }
      public uint size_from_app;
      private IntPtr _data_from_lib;
      public int[] data_from_lib
      {
        get
        {
          return FromIntPtr<int>(_data_from_lib, (int)size_from_lib);
        }
      }
      public uint size_from_lib;
    }

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free__sklib_vector_bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free__sklib_vector_bool(__sklib_vector_bool v);

    private static void __skadapter__free__sklib_vector_bool(ref __sklib_vector_bool v)
    {
      // System.Console.WriteLine("Freeing data");
      Marshal.FreeHGlobal(v._data_from_app);
    }
    private static __sklib_vector_bool __skadapter__to_sklib_vector_bool(List<bool> v)
    {
      int i = 0;
      __sklib_vector_bool result = new __sklib_vector_bool();

      result.size_from_lib = 0;
      result.size_from_app = (uint)v.Count;
      int[] tmp = new int[result.size_from_app];

      foreach(bool d in v)
      {
        tmp[i] = __skadapter__to_sklib_bool(v[i]);
        i++;
      }

      result.data_from_app = tmp;
      return result;
    }
    private static List<bool> __skadapter__to_vector_bool(__sklib_vector_bool v)
    {
      List<bool> result = new List<bool>();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        result.Add(__skadapter__to_bool(v.data_from_lib[i]));
      }
      __sklib__free__sklib_vector_bool(v);
      return result;
    }
    private static void __skadapter__update_from_vector_bool(ref __sklib_vector_bool v, List<bool> __skreturn)
    {
      __skreturn.Clear();
      for (int i = 0; i < v.size_from_lib; i++)
      {
        __skreturn.Add(__skadapter__to_bool(v.data_from_lib[i]));
      }
            __sklib__free__sklib_vector_bool(v);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static KeyCallback __skadapter__to_sklib_key_callback(KeyCallback v) { return v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static FreeNotifier __skadapter__to_sklib_free_notifier(FreeNotifier v) { return v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static SpriteEventHandler __skadapter__to_sklib_sprite_event_handler(SpriteEventHandler v) { return v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static SpriteFloatFunction __skadapter__to_sklib_sprite_float_function(SpriteFloatFunction v) { return v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static SpriteFunction __skadapter__to_sklib_sprite_function(SpriteFunction v) { return v; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_json(Json v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Json __skadapter__to_json(IntPtr v) { return Json.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_music(Music v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Music __skadapter__to_music(IntPtr v) { return Music.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_connection(Connection v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Connection __skadapter__to_connection(IntPtr v) { return Connection.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_message(Message v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Message __skadapter__to_message(IntPtr v) { return Message.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_server_socket(ServerSocket v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static ServerSocket __skadapter__to_server_socket(IntPtr v) { return ServerSocket.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_sound_effect(SoundEffect v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static SoundEffect __skadapter__to_sound_effect(IntPtr v) { return SoundEffect.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_sprite(Sprite v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Sprite __skadapter__to_sprite(IntPtr v) { return Sprite.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_timer(Timer v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Timer __skadapter__to_timer(IntPtr v) { return Timer.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_animation(Animation v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Animation __skadapter__to_animation(IntPtr v) { return Animation.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_animation_script(AnimationScript v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static AnimationScript __skadapter__to_animation_script(IntPtr v) { return AnimationScript.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_bitmap(Bitmap v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Bitmap __skadapter__to_bitmap(IntPtr v) { return Bitmap.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_display(Display v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Display __skadapter__to_display(IntPtr v) { return Display.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_font(Font v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Font __skadapter__to_font(IntPtr v) { return Font.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_http_response(HttpResponse v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static HttpResponse __skadapter__to_http_response(IntPtr v) { return HttpResponse.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_http_request(HttpRequest v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static HttpRequest __skadapter__to_http_request(IntPtr v) { return HttpRequest.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_web_server(WebServer v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static WebServer __skadapter__to_web_server(IntPtr v) { return WebServer.FetchOrCreate(v); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IntPtr __skadapter__to_sklib_window(Window v) { return v; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Window __skadapter__to_window(IntPtr v) { return Window.FetchOrCreate(v); }
    
    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__animation_count__animation_script", CharSet=CharSet.Ansi)]
    private static extern int __sklib__animation_count__animation_script(__sklib_ptr script);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__animation_current_cell__animation", CharSet=CharSet.Ansi)]
    private static extern int __sklib__animation_current_cell__animation(__sklib_ptr anim);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__animation_current_vector__animation", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__animation_current_vector__animation(__sklib_ptr anim);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__animation_ended__animation", CharSet=CharSet.Ansi)]
    private static extern int __sklib__animation_ended__animation(__sklib_ptr anim);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__animation_entered_frame__animation", CharSet=CharSet.Ansi)]
    private static extern int __sklib__animation_entered_frame__animation(__sklib_ptr anim);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__animation_frame_time__animation", CharSet=CharSet.Ansi)]
    private static extern float __sklib__animation_frame_time__animation(__sklib_ptr anim);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__animation_index__animation_script__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__animation_index__animation_script__string_ref(__sklib_ptr script, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__animation_name__animation", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__animation_name__animation(__sklib_ptr temp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__animation_script_name__animation_script", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__animation_script_name__animation_script(__sklib_ptr script);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__animation_script_named__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__animation_script_named__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__assign_animation__animation__animation_script__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__assign_animation__animation__animation_script__string_ref(__sklib_ptr anim, __sklib_ptr script, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__assign_animation__animation__animation_script__string_ref__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__assign_animation__animation__animation_script__string_ref__bool(__sklib_ptr anim, __sklib_ptr script, __sklib_string name, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__assign_animation__animation__animation_script__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__assign_animation__animation__animation_script__int(__sklib_ptr anim, __sklib_ptr script, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__assign_animation__animation__animation_script__int__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__assign_animation__animation__animation_script__int__bool(__sklib_ptr anim, __sklib_ptr script, int idx, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__assign_animation__animation__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__assign_animation__animation__string_ref__string_ref(__sklib_ptr anim, __sklib_string scriptName, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__assign_animation__animation__string_ref__string_ref__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__assign_animation__animation__string_ref__string_ref__bool(__sklib_ptr anim, __sklib_string scriptName, __sklib_string name, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__assign_animation__animation__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__assign_animation__animation__int(__sklib_ptr anim, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__assign_animation__animation__int__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__assign_animation__animation__int__bool(__sklib_ptr anim, int idx, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__assign_animation__animation__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__assign_animation__animation__string(__sklib_ptr anim, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__assign_animation__animation__string__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__assign_animation__animation__string__bool(__sklib_ptr anim, __sklib_string name, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_animation__animation_script__int__bool", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_animation__animation_script__int__bool(__sklib_ptr script, int idx, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_animation__animation_script__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_animation__animation_script__string_ref(__sklib_ptr script, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_animation__animation_script__string_ref__bool", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_animation__animation_script__string_ref__bool(__sklib_ptr script, __sklib_string name, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_animation__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_animation__string_ref__string_ref(__sklib_string scriptName, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_animation__string_ref__string_ref__bool", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_animation__string_ref__string_ref__bool(__sklib_string scriptName, __sklib_string name, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_all_animation_scripts", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_all_animation_scripts();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_animation__animation", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_animation__animation(__sklib_ptr ani);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_animation_script__animation_script", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_animation_script__animation_script(__sklib_ptr scriptToFree);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_animation_script__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_animation_script__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_animation_named__animation_script__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_animation_named__animation_script__string_ref(__sklib_ptr script, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_animation_script__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_animation_script__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__load_animation_script__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__load_animation_script__string_ref__string_ref(__sklib_string name, __sklib_string filename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__restart_animation__animation", CharSet=CharSet.Ansi)]
    private static extern void __sklib__restart_animation__animation(__sklib_ptr anim);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__restart_animation__animation__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__restart_animation__animation__bool(__sklib_ptr anim, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_animation__animation__float__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_animation__animation__float__bool(__sklib_ptr anim, float pct, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_animation__animation", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_animation__animation(__sklib_ptr anim);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_animation__animation__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_animation__animation__float(__sklib_ptr anim, float pct);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__audio_ready", CharSet=CharSet.Ansi)]
    private static extern int __sklib__audio_ready();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_audio", CharSet=CharSet.Ansi)]
    private static extern void __sklib__close_audio();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__open_audio", CharSet=CharSet.Ansi)]
    private static extern void __sklib__open_audio();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__contains__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__contains__string_ref__string_ref(__sklib_string text, __sklib_string subtext);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__convert_to_double__string_ref", CharSet=CharSet.Ansi)]
    private static extern double __sklib__convert_to_double__string_ref(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__convert_to_integer__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__convert_to_integer__string_ref(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__index_of__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__index_of__string_ref__string_ref(__sklib_string text, __sklib_string subtext);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_double__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_double__string_ref(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_integer__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_integer__string_ref(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_number__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_number__string_ref(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__length_of__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__length_of__string_ref(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__replace_all__string_ref__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__replace_all__string_ref__string_ref__string_ref(__sklib_string text, __sklib_string substr, __sklib_string newText);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__split__string_ref__char", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_string __sklib__split__string_ref__char(__sklib_string text, char delimiter);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__to_lowercase__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__to_lowercase__string_ref(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__to_uppercase__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__to_uppercase__string_ref(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__trim__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__trim__string_ref(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_resource_bundle__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_resource_bundle__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_resource_bundle__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_resource_bundle__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__load_resource_bundle__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__load_resource_bundle__string_ref__string_ref(__sklib_string name, __sklib_string filename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__camera_position", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__camera_position();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__camera_x", CharSet=CharSet.Ansi)]
    private static extern double __sklib__camera_x();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__camera_y", CharSet=CharSet.Ansi)]
    private static extern double __sklib__camera_y();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__center_camera_on__sprite__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__center_camera_on__sprite__vector_2d_ref(__sklib_ptr s, __sklib_vector_2d offset);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__center_camera_on__sprite__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__center_camera_on__sprite__double__double(__sklib_ptr s, double offsetX, double offsetY);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_camera_by__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_camera_by__vector_2d_ref(__sklib_vector_2d offset);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_camera_by__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_camera_by__double__double(double dx, double dy);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_camera_to__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_camera_to__point_2d_ref(__sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_camera_to__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_camera_to__double__double(double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_in_window__window__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__point_in_window__window__point_2d_ref(__sklib_ptr wind, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_on_screen__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__point_on_screen__point_2d_ref(__sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rect_in_window__window__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__rect_in_window__window__rectangle_ref(__sklib_ptr wind, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rect_on_screen__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__rect_on_screen__rectangle_ref(__sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__screen_center", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__screen_center();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__screen_rectangle", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__screen_rectangle();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_camera_position__point_2d", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_camera_position__point_2d(__sklib_point_2d pos);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_camera_x__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_camera_x__double(double x);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_camera_y__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_camera_y__double(double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__to_screen__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__to_screen__point_2d_ref(__sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__to_screen__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__to_screen__rectangle_ref(__sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__to_screen_x__double", CharSet=CharSet.Ansi)]
    private static extern double __sklib__to_screen_x__double(double worldX);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__to_screen_y__double", CharSet=CharSet.Ansi)]
    private static extern double __sklib__to_screen_y__double(double worldY);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__to_world__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__to_world__point_2d_ref(__sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__to_world_x__double", CharSet=CharSet.Ansi)]
    private static extern double __sklib__to_world_x__double(double screenX);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__to_world_y__double", CharSet=CharSet.Ansi)]
    private static extern double __sklib__to_world_y__double(double screenY);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_world_to_screen", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_world_to_screen();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_area__window", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__window_area__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_circle__color__circle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_circle__color__circle_ref(__sklib_color clr, __sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_circle__color__circle_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_circle__color__circle_ref__drawing_options(__sklib_color clr, __sklib_circle c, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_circle__color__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_circle__color__double__double__double(__sklib_color clr, double x, double y, double radius);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_circle__color__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_circle__color__double__double__double__drawing_options(__sklib_color clr, double x, double y, double radius, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_circle_on_bitmap__bitmap__color__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_circle_on_bitmap__bitmap__color__double__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y, double radius);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_circle_on_bitmap__bitmap__color__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_circle_on_bitmap__bitmap__color__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x, double y, double radius, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_circle_on_window__window__color__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_circle_on_window__window__color__double__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y, double radius);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_circle_on_window__window__color__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_circle_on_window__window__color__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x, double y, double radius, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_circle__color__circle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_circle__color__circle_ref(__sklib_color clr, __sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_circle__color__circle_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_circle__color__circle_ref__drawing_options(__sklib_color clr, __sklib_circle c, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_circle__color__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_circle__color__double__double__double(__sklib_color clr, double x, double y, double radius);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_circle__color__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_circle__color__double__double__double__drawing_options(__sklib_color clr, double x, double y, double radius, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_circle_on_bitmap__bitmap__color__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_circle_on_bitmap__bitmap__color__double__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y, double radius);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_circle_on_bitmap__bitmap__color__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_circle_on_bitmap__bitmap__color__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x, double y, double radius, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_circle_on_window__window__color__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_circle_on_window__window__color__double__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y, double radius);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_circle_on_window__window__color__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_circle_on_window__window__color__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x, double y, double radius, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__center_point__circle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__center_point__circle_ref(__sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__circle_at__point_2d_ref__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_circle __sklib__circle_at__point_2d_ref__double(__sklib_point_2d pt, double radius);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__circle_at__double__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_circle __sklib__circle_at__double__double__double(double x, double y, double radius);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__circle_quad_intersect__circle_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__circle_quad_intersect__circle_ref__quad_ref(__sklib_circle c, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__circle_radius__circle", CharSet=CharSet.Ansi)]
    private static extern float __sklib__circle_radius__circle(__sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__circle_ray_intersection__point_2d_ref__vector_2d_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__circle_ray_intersection__point_2d_ref__vector_2d_ref__circle_ref(__sklib_point_2d origin, __sklib_vector_2d heading, __sklib_circle circ);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__circle_ray_intersection__point_2d_ref__vector_2d_ref__circle_ref__point_2d_ref__double_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__circle_ray_intersection__point_2d_ref__vector_2d_ref__circle_ref__point_2d_ref__double_ref(__sklib_point_2d origin, __sklib_vector_2d heading, __sklib_circle circ, ref __sklib_point_2d hitPoint, ref double hitDistance);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__circle_triangle_intersect__circle_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__circle_triangle_intersect__circle_ref__triangle_ref(__sklib_circle c, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__circle_triangle_intersect__circle_ref__triangle_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__circle_triangle_intersect__circle_ref__triangle_ref__point_2d_ref(__sklib_circle c, __sklib_triangle tri, ref __sklib_point_2d p);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__circle_x__circle_ref", CharSet=CharSet.Ansi)]
    private static extern float __sklib__circle_x__circle_ref(__sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__circle_y__circle_ref", CharSet=CharSet.Ansi)]
    private static extern float __sklib__circle_y__circle_ref(__sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__circles_intersect__circle__circle", CharSet=CharSet.Ansi)]
    private static extern int __sklib__circles_intersect__circle__circle(__sklib_circle c1, __sklib_circle c2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__circles_intersect__double__double__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern int __sklib__circles_intersect__double__double__double__double__double__double(double c1X, double c1Y, double c1Radius, double c2X, double c2Y, double c2Radius);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__closest_point_on_circle__point_2d_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__closest_point_on_circle__point_2d_ref__circle_ref(__sklib_point_2d fromPt, __sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__closest_point_on_line_from_circle__circle_ref__line_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__closest_point_on_line_from_circle__circle_ref__line_ref(__sklib_circle c, __sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__closest_point_on_rect_from_circle__circle_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__closest_point_on_rect_from_circle__circle_ref__rectangle_ref(__sklib_circle c, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__closest_point_on_triangle_from_circle__circle_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__closest_point_on_triangle_from_circle__circle_ref__triangle_ref(__sklib_circle c, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__distant_point_on_circle__point_2d_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__distant_point_on_circle__point_2d_ref__circle_ref(__sklib_point_2d pt, __sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__distant_point_on_circle_heading__point_2d_ref__circle_ref__vector_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__distant_point_on_circle_heading__point_2d_ref__circle_ref__vector_2d_ref__point_2d_ref(__sklib_point_2d pt, __sklib_circle c, __sklib_vector_2d heading, ref __sklib_point_2d oppositePt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__ray_circle_intersect_distance__point_2d_ref__vector_2d_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern float __sklib__ray_circle_intersect_distance__point_2d_ref__vector_2d_ref__circle_ref(__sklib_point_2d rayOrigin, __sklib_vector_2d rayHeading, __sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__tangent_points__point_2d_ref__circle_ref__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__tangent_points__point_2d_ref__circle_ref__point_2d_ref__point_2d_ref(__sklib_point_2d fromPt, __sklib_circle c, ref __sklib_point_2d p1, ref __sklib_point_2d p2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__widest_points__circle_ref__vector_2d_ref__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__widest_points__circle_ref__vector_2d_ref__point_2d_ref__point_2d_ref(__sklib_circle c, __sklib_vector_2d along, ref __sklib_point_2d pt1, ref __sklib_point_2d pt2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_clip", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__current_clip();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_clip__bitmap", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__current_clip__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_clip__window", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__current_clip__window(__sklib_ptr wnd);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__pop_clip__window", CharSet=CharSet.Ansi)]
    private static extern void __sklib__pop_clip__window(__sklib_ptr wnd);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__pop_clip", CharSet=CharSet.Ansi)]
    private static extern void __sklib__pop_clip();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__pop_clip__bitmap", CharSet=CharSet.Ansi)]
    private static extern void __sklib__pop_clip__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__push_clip__window__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__push_clip__window__rectangle_ref(__sklib_ptr wnd, __sklib_rectangle r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__push_clip__bitmap__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__push_clip__bitmap__rectangle_ref(__sklib_ptr bmp, __sklib_rectangle r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__push_clip__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__push_clip__rectangle_ref(__sklib_rectangle r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__reset_clip__bitmap", CharSet=CharSet.Ansi)]
    private static extern void __sklib__reset_clip__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__reset_clip", CharSet=CharSet.Ansi)]
    private static extern void __sklib__reset_clip();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__reset_clip__window", CharSet=CharSet.Ansi)]
    private static extern void __sklib__reset_clip__window(__sklib_ptr wnd);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_clip__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_clip__rectangle_ref(__sklib_rectangle r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_clip__bitmap__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_clip__bitmap__rectangle_ref(__sklib_ptr bmp, __sklib_rectangle r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_clip__window__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_clip__window__rectangle_ref(__sklib_ptr wnd, __sklib_rectangle r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_circle_collision__bitmap__point_2d_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_circle_collision__bitmap__point_2d_ref__circle_ref(__sklib_ptr bmp, __sklib_point_2d pt, __sklib_circle circ);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_circle_collision__bitmap__double__double__circle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_circle_collision__bitmap__double__double__circle_ref(__sklib_ptr bmp, double x, double y, __sklib_circle circ);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_circle_collision__bitmap__int__matrix_2d_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_circle_collision__bitmap__int__matrix_2d_ref__circle_ref(__sklib_ptr bmp, int cell, __sklib_matrix_2d translation, __sklib_circle circ);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_circle_collision__bitmap__int__point_2d_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_circle_collision__bitmap__int__point_2d_ref__circle_ref(__sklib_ptr bmp, int cell, __sklib_point_2d pt, __sklib_circle circ);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_circle_collision__bitmap__int__double__double__circle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_circle_collision__bitmap__int__double__double__circle_ref(__sklib_ptr bmp, int cell, double x, double y, __sklib_circle circ);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_collision__bitmap__double__double__bitmap__double__double", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_collision__bitmap__double__double__bitmap__double__double(__sklib_ptr bmp1, double x1, double y1, __sklib_ptr bmp2, double x2, double y2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_collision__bitmap__point_2d_ref__bitmap__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_collision__bitmap__point_2d_ref__bitmap__point_2d_ref(__sklib_ptr bmp1, __sklib_point_2d pt1, __sklib_ptr bmp2, __sklib_point_2d pt2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_collision__bitmap__int__matrix_2d_ref__bitmap__int__matrix_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_collision__bitmap__int__matrix_2d_ref__bitmap__int__matrix_2d_ref(__sklib_ptr bmp1, int cell1, __sklib_matrix_2d matrix1, __sklib_ptr bmp2, int cell2, __sklib_matrix_2d matrix2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_collision__bitmap__int__point_2d_ref__bitmap__int__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_collision__bitmap__int__point_2d_ref__bitmap__int__point_2d_ref(__sklib_ptr bmp1, int cell1, __sklib_point_2d pt1, __sklib_ptr bmp2, int cell2, __sklib_point_2d pt2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_collision__bitmap__int__double__double__bitmap__int__double__double", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_collision__bitmap__int__double__double__bitmap__int__double__double(__sklib_ptr bmp1, int cell1, double x1, double y1, __sklib_ptr bmp2, int cell2, double x2, double y2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_point_collision__bitmap__matrix_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_point_collision__bitmap__matrix_2d_ref__point_2d_ref(__sklib_ptr bmp, __sklib_matrix_2d translation, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_point_collision__bitmap__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_point_collision__bitmap__point_2d_ref__point_2d_ref(__sklib_ptr bmp, __sklib_point_2d bmpPt, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_point_collision__bitmap__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_point_collision__bitmap__double__double__double__double(__sklib_ptr bmp, double bmpX, double bmpY, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_point_collision__bitmap__int__matrix_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_point_collision__bitmap__int__matrix_2d_ref__point_2d_ref(__sklib_ptr bmp, int cell, __sklib_matrix_2d translation, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_point_collision__bitmap__int__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_point_collision__bitmap__int__point_2d_ref__point_2d_ref(__sklib_ptr bmp, int cell, __sklib_point_2d bmpPt, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_point_collision__bitmap__int__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_point_collision__bitmap__int__double__double__double__double(__sklib_ptr bmp, int cell, double bmpX, double bmpY, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_quad_collision__bitmap__point_2d_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_quad_collision__bitmap__point_2d_ref__quad_ref(__sklib_ptr bmp, __sklib_point_2d pt, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_quad_collision__bitmap__double__double__quad_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_quad_collision__bitmap__double__double__quad_ref(__sklib_ptr bmp, double x, double y, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_quad_collision__bitmap__int__matrix_2d_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_quad_collision__bitmap__int__matrix_2d_ref__quad_ref(__sklib_ptr bmp, int cell, __sklib_matrix_2d translation, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_quad_collision__bitmap__int__point_2d_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_quad_collision__bitmap__int__point_2d_ref__quad_ref(__sklib_ptr bmp, int cell, __sklib_point_2d pt, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_quad_collision__bitmap__int__double__double__quad_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_quad_collision__bitmap__int__double__double__quad_ref(__sklib_ptr bmp, int cell, double x, double y, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_ray_collision__bitmap__point_2d_ref__point_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_ray_collision__bitmap__point_2d_ref__point_2d_ref__vector_2d_ref(__sklib_ptr bmp, __sklib_point_2d pt, __sklib_point_2d origin, __sklib_vector_2d heading);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_ray_collision__bitmap__double__double__point_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_ray_collision__bitmap__double__double__point_2d_ref__vector_2d_ref(__sklib_ptr bmp, double x, double y, __sklib_point_2d origin, __sklib_vector_2d heading);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_ray_collision__bitmap__int__matrix_2d_ref__point_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_ray_collision__bitmap__int__matrix_2d_ref__point_2d_ref__vector_2d_ref(__sklib_ptr bmp, int cell, __sklib_matrix_2d translation, __sklib_point_2d origin, __sklib_vector_2d heading);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_ray_collision__bitmap__int__point_2d_ref__point_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_ray_collision__bitmap__int__point_2d_ref__point_2d_ref__vector_2d_ref(__sklib_ptr bmp, int cell, __sklib_point_2d pt, __sklib_point_2d origin, __sklib_vector_2d heading);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_ray_collision__bitmap__int__double__double__point_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_ray_collision__bitmap__int__double__double__point_2d_ref__vector_2d_ref(__sklib_ptr bmp, int cell, double x, double y, __sklib_point_2d origin, __sklib_vector_2d heading);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_rectangle_collision__bitmap__point_2d_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_rectangle_collision__bitmap__point_2d_ref__rectangle_ref(__sklib_ptr bmp, __sklib_point_2d pt, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_rectangle_collision__bitmap__double__double__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_rectangle_collision__bitmap__double__double__rectangle_ref(__sklib_ptr bmp, double x, double y, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_rectangle_collision__bitmap__int__matrix_2d_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_rectangle_collision__bitmap__int__matrix_2d_ref__rectangle_ref(__sklib_ptr bmp, int cell, __sklib_matrix_2d translation, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_rectangle_collision__bitmap__int__point_2d_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_rectangle_collision__bitmap__int__point_2d_ref__rectangle_ref(__sklib_ptr bmp, int cell, __sklib_point_2d pt, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_rectangle_collision__bitmap__int__double__double__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_rectangle_collision__bitmap__int__double__double__rectangle_ref(__sklib_ptr bmp, int cell, double x, double y, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_triangle_collision__bitmap__point_2d_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_triangle_collision__bitmap__point_2d_ref__triangle_ref(__sklib_ptr bmp, __sklib_point_2d pt, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_triangle_collision__bitmap__double__double__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_triangle_collision__bitmap__double__double__triangle_ref(__sklib_ptr bmp, double x, double y, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_triangle_collision__bitmap__int__matrix_2d_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_triangle_collision__bitmap__int__matrix_2d_ref__triangle_ref(__sklib_ptr bmp, int cell, __sklib_matrix_2d translation, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_triangle_collision__bitmap__int__point_2d_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_triangle_collision__bitmap__int__point_2d_ref__triangle_ref(__sklib_ptr bmp, int cell, __sklib_point_2d pt, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_triangle_collision__bitmap__int__double__double__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_triangle_collision__bitmap__int__double__double__triangle_ref(__sklib_ptr bmp, int cell, double x, double y, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__quad_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__quad_ref__quad_ref(__sklib_quad collider, __sklib_quad collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__circle_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__circle_ref__circle_ref(__sklib_circle collider, __sklib_circle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__circle_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__circle_ref__quad_ref(__sklib_circle collider, __sklib_quad collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__circle_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__circle_ref__rectangle_ref(__sklib_circle collider, __sklib_rectangle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__circle_ref__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__circle_ref__sprite(__sklib_circle collider, __sklib_ptr collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__circle_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__circle_ref__triangle_ref(__sklib_circle collider, __sklib_triangle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__quad_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__quad_ref__circle_ref(__sklib_quad collider, __sklib_circle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__quad_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__quad_ref__rectangle_ref(__sklib_quad collider, __sklib_rectangle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__quad_ref__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__quad_ref__sprite(__sklib_quad collider, __sklib_ptr collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__quad_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__quad_ref__triangle_ref(__sklib_quad collider, __sklib_triangle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__rectangle_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__rectangle_ref__circle_ref(__sklib_rectangle collider, __sklib_circle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__rectangle_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__rectangle_ref__quad_ref(__sklib_rectangle collider, __sklib_quad collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__rectangle_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__rectangle_ref__rectangle_ref(__sklib_rectangle collider, __sklib_rectangle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__rectangle_ref__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__rectangle_ref__sprite(__sklib_rectangle collider, __sklib_ptr collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__rectangle_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__rectangle_ref__triangle_ref(__sklib_rectangle collider, __sklib_triangle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__sprite__circle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__sprite__circle_ref(__sklib_ptr collider, __sklib_circle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__sprite__quad_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__sprite__quad_ref(__sklib_ptr collider, __sklib_quad collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__sprite__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__sprite__rectangle_ref(__sklib_ptr collider, __sklib_rectangle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__sprite__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__sprite__sprite(__sklib_ptr collider, __sklib_ptr collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__sprite__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__sprite__triangle_ref(__sklib_ptr collider, __sklib_triangle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__triangle_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__triangle_ref__circle_ref(__sklib_triangle collider, __sklib_circle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__triangle_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__triangle_ref__quad_ref(__sklib_triangle collider, __sklib_quad collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__triangle_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__triangle_ref__rectangle_ref(__sklib_triangle collider, __sklib_rectangle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__triangle_ref__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__triangle_ref__sprite(__sklib_triangle collider, __sklib_ptr collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__calculate_collision_direction__triangle_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__calculate_collision_direction__triangle_ref__triangle_ref(__sklib_triangle collider, __sklib_triangle collidee);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__quad_ref__quad_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__quad_ref__quad_ref__vector_2d_ref(ref __sklib_quad collider, __sklib_quad collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__circle_ref__circle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__circle_ref__circle_ref__vector_2d_ref(ref __sklib_circle collider, __sklib_circle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__circle_ref__quad_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__circle_ref__quad_ref__vector_2d_ref(ref __sklib_circle collider, __sklib_quad collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__circle_ref__rectangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__circle_ref__rectangle_ref__vector_2d_ref(ref __sklib_circle collider, __sklib_rectangle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__circle_ref__sprite__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__circle_ref__sprite__vector_2d_ref(ref __sklib_circle collider, __sklib_ptr collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__circle_ref__triangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__circle_ref__triangle_ref__vector_2d_ref(ref __sklib_circle collider, __sklib_triangle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__quad_ref__circle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__quad_ref__circle_ref__vector_2d_ref(ref __sklib_quad collider, __sklib_circle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__quad_ref__rectangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__quad_ref__rectangle_ref__vector_2d_ref(ref __sklib_quad collider, __sklib_rectangle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__quad_ref__sprite__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__quad_ref__sprite__vector_2d_ref(ref __sklib_quad collider, __sklib_ptr collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__quad_ref__triangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__quad_ref__triangle_ref__vector_2d_ref(ref __sklib_quad collider, __sklib_triangle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__rectangle_ref__circle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__rectangle_ref__circle_ref__vector_2d_ref(ref __sklib_rectangle collider, __sklib_circle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__rectangle_ref__quad_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__rectangle_ref__quad_ref__vector_2d_ref(ref __sklib_rectangle collider, __sklib_quad collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__rectangle_ref__rectangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__rectangle_ref__rectangle_ref__vector_2d_ref(ref __sklib_rectangle collider, __sklib_rectangle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__rectangle_ref__sprite__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__rectangle_ref__sprite__vector_2d_ref(ref __sklib_rectangle collider, __sklib_ptr collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__rectangle_ref__triangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__rectangle_ref__triangle_ref__vector_2d_ref(ref __sklib_rectangle collider, __sklib_triangle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__sprite__circle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__sprite__circle_ref__vector_2d_ref(__sklib_ptr collider, __sklib_circle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__sprite__quad_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__sprite__quad_ref__vector_2d_ref(__sklib_ptr collider, __sklib_quad collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__sprite__rectangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__sprite__rectangle_ref__vector_2d_ref(__sklib_ptr collider, __sklib_rectangle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__sprite__sprite__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__sprite__sprite__vector_2d_ref(__sklib_ptr collider, __sklib_ptr collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__sprite__triangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__sprite__triangle_ref__vector_2d_ref(__sklib_ptr collider, __sklib_triangle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__triangle_ref__circle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__triangle_ref__circle_ref__vector_2d_ref(ref __sklib_triangle collider, __sklib_circle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__triangle_ref__quad_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__triangle_ref__quad_ref__vector_2d_ref(ref __sklib_triangle collider, __sklib_quad collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__triangle_ref__rectangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__triangle_ref__rectangle_ref__vector_2d_ref(ref __sklib_triangle collider, __sklib_rectangle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__triangle_ref__sprite__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__triangle_ref__sprite__vector_2d_ref(ref __sklib_triangle collider, __sklib_ptr collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resolve_collision__triangle_ref__triangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__resolve_collision__triangle_ref__triangle_ref__vector_2d_ref(ref __sklib_triangle collider, __sklib_triangle collidee, __sklib_vector_2d direction);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_bitmap_collision__sprite__bitmap__double__double", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_bitmap_collision__sprite__bitmap__double__double(__sklib_ptr s, __sklib_ptr bmp, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_bitmap_collision__sprite__bitmap__int__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_bitmap_collision__sprite__bitmap__int__point_2d_ref(__sklib_ptr s, __sklib_ptr bmp, int cell, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_bitmap_collision__sprite__bitmap__int__double__double", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_bitmap_collision__sprite__bitmap__int__double__double(__sklib_ptr s, __sklib_ptr bmp, int cell, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_circle_collision__sprite__circle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_circle_collision__sprite__circle_ref(__sklib_ptr s, __sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_collision__sprite__sprite", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_collision__sprite__sprite(__sklib_ptr s1, __sklib_ptr s2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_point_collision__sprite__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_point_collision__sprite__point_2d_ref(__sklib_ptr s, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_quad_collision__sprite__quad_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_quad_collision__sprite__quad_ref(__sklib_ptr s, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_ray_collision__sprite__point_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_ray_collision__sprite__point_2d_ref__vector_2d_ref(__sklib_ptr s, __sklib_point_2d origin, __sklib_vector_2d heading);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_rectangle_collision__sprite__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_rectangle_collision__sprite__rectangle_ref(__sklib_ptr s, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_triangle_collision__sprite__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_triangle_collision__sprite__triangle_ref(__sklib_ptr s, __sklib_triangle t);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__alpha_of__color", CharSet=CharSet.Ansi)]
    private static extern int __sklib__alpha_of__color(__sklib_color c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__blue_of__color", CharSet=CharSet.Ansi)]
    private static extern int __sklib__blue_of__color(__sklib_color c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__brightness_of__color", CharSet=CharSet.Ansi)]
    private static extern double __sklib__brightness_of__color(__sklib_color c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_alice_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_alice_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_antique_white", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_antique_white();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_aqua", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_aqua();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_aquamarine", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_aquamarine();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_azure", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_azure();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_beige", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_beige();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_bisque", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_bisque();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_black", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_black();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_blanched_almond", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_blanched_almond();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_blue_violet", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_blue_violet();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_bright_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_bright_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_brown", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_brown();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_burly_wood", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_burly_wood();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_cadet_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_cadet_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_chartreuse", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_chartreuse();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_chocolate", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_chocolate();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_coral", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_coral();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_cornflower_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_cornflower_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_cornsilk", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_cornsilk();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_crimson", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_crimson();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_cyan", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_cyan();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_cyan", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_cyan();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_goldenrod", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_goldenrod();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_gray", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_gray();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_khaki", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_khaki();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_magenta", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_magenta();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_olive_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_olive_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_orange", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_orange();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_orchid", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_orchid();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_red", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_red();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_salmon", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_salmon();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_sea_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_sea_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_slate_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_slate_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_slate_gray", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_slate_gray();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_turquoise", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_turquoise();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dark_violet", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dark_violet();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_deep_pink", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_deep_pink();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_deep_sky_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_deep_sky_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dim_gray", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dim_gray();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_dodger_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_dodger_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_firebrick", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_firebrick();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_floral_white", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_floral_white();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_forest_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_forest_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_fuchsia", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_fuchsia();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_gainsboro", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_gainsboro();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_ghost_white", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_ghost_white();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_gold", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_gold();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_goldenrod", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_goldenrod();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_gray", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_gray();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_green_yellow", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_green_yellow();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_honeydew", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_honeydew();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_hot_pink", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_hot_pink();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_indian_red", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_indian_red();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_indigo", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_indigo();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_ivory", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_ivory();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_khaki", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_khaki();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_lavender", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_lavender();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_lavender_blush", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_lavender_blush();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_lawn_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_lawn_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_lemon_chiffon", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_lemon_chiffon();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_coral", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_coral();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_cyan", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_cyan();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_goldenrod_yellow", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_goldenrod_yellow();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_gray", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_gray();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_pink", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_pink();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_salmon", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_salmon();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_sea_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_sea_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_sky_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_sky_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_slate_gray", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_slate_gray();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_steel_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_steel_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_light_yellow", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_light_yellow();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_lime", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_lime();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_lime_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_lime_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_linen", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_linen();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_magenta", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_magenta();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_maroon", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_maroon();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_medium_aquamarine", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_medium_aquamarine();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_medium_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_medium_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_medium_orchid", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_medium_orchid();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_medium_purple", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_medium_purple();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_medium_sea_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_medium_sea_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_medium_slate_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_medium_slate_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_medium_spring_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_medium_spring_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_medium_turquoise", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_medium_turquoise();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_medium_violet_red", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_medium_violet_red();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_midnight_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_midnight_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_mint_cream", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_mint_cream();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_misty_rose", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_misty_rose();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_moccasin", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_moccasin();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_navajo_white", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_navajo_white();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_navy", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_navy();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_old_lace", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_old_lace();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_olive", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_olive();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_olive_drab", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_olive_drab();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_orange", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_orange();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_orange_red", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_orange_red();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_orchid", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_orchid();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_pale_goldenrod", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_pale_goldenrod();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_pale_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_pale_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_pale_turquoise", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_pale_turquoise();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_pale_violet_red", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_pale_violet_red();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_papaya_whip", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_papaya_whip();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_peach_puff", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_peach_puff();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_peru", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_peru();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_pink", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_pink();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_plum", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_plum();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_powder_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_powder_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_purple", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_purple();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_red", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_red();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_rosy_brown", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_rosy_brown();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_royal_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_royal_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_saddle_brown", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_saddle_brown();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_salmon", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_salmon();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_sandy_brown", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_sandy_brown();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_sea_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_sea_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_sea_shell", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_sea_shell();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_sienna", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_sienna();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_silver", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_silver();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_sky_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_sky_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_slate_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_slate_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_slate_gray", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_slate_gray();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_snow", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_snow();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_spring_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_spring_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_steel_blue", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_steel_blue();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_swinburne_red", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_swinburne_red();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_tan", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_tan();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_teal", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_teal();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_thistle", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_thistle();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_to_string__color", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__color_to_string__color(__sklib_color c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_tomato", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_tomato();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_transparent", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_transparent();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_turquoise", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_turquoise();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_violet", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_violet();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_wheat", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_wheat();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_white", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_white();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_white_smoke", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_white_smoke();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_yellow", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_yellow();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_yellow_green", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_yellow_green();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__green_of__color", CharSet=CharSet.Ansi)]
    private static extern int __sklib__green_of__color(__sklib_color c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__hsb_color__double__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__hsb_color__double__double__double(double hue, double saturation, double brightness);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__hue_of__color", CharSet=CharSet.Ansi)]
    private static extern double __sklib__hue_of__color(__sklib_color c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__random_color", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__random_color();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__random_rgb_color__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__random_rgb_color__int(int alpha);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__red_of__color", CharSet=CharSet.Ansi)]
    private static extern int __sklib__red_of__color(__sklib_color c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rgb_color__double__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__rgb_color__double__double__double(double red, double green, double blue);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rgb_color__int__int__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__rgb_color__int__int__int(int red, int green, int blue);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rgba_color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__rgba_color__double__double__double__double(double red, double green, double blue, double alpha);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rgba_color__int__int__int__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__rgba_color__int__int__int__int(int red, int green, int blue, int alpha);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__saturation_of__color", CharSet=CharSet.Ansi)]
    private static extern double __sklib__saturation_of__color(__sklib_color c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__string_to_color__string", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__string_to_color__string(__sklib_string str);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_defaults", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_defaults();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_draw_to__bitmap", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_draw_to__bitmap(__sklib_ptr dest);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_draw_to__bitmap__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_draw_to__bitmap__drawing_options(__sklib_ptr dest, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_draw_to__window", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_draw_to__window(__sklib_ptr dest);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_draw_to__window__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_draw_to__window__drawing_options(__sklib_ptr dest, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_flip_x", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_flip_x();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_flip_x__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_flip_x__drawing_options(__sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_flip_xy", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_flip_xy();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_flip_xy__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_flip_xy__drawing_options(__sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_flip_y", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_flip_y();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_flip_y__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_flip_y__drawing_options(__sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_line_width__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_line_width__int(int width);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_line_width__int__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_line_width__int__drawing_options(int width, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_part_bmp__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_part_bmp__double__double__double__double(double x, double y, double w, double h);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_part_bmp__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_part_bmp__double__double__double__double__drawing_options(double x, double y, double w, double h, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_part_bmp__rectangle", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_part_bmp__rectangle(__sklib_rectangle part);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_part_bmp__rectangle__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_part_bmp__rectangle__drawing_options(__sklib_rectangle part, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_rotate_bmp__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_rotate_bmp__double(double angle);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_rotate_bmp__double__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_rotate_bmp__double__double__double(double angle, double anchorX, double anchorY);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_rotate_bmp__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_rotate_bmp__double__double__double__drawing_options(double angle, double anchorX, double anchorY, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_rotate_bmp__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_rotate_bmp__double__drawing_options(double angle, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_scale_bmp__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_scale_bmp__double__double(double scaleX, double scaleY);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_scale_bmp__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_scale_bmp__double__double__drawing_options(double scaleX, double scaleY, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_to_screen", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_to_screen();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_to_screen__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_to_screen__drawing_options(__sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_to_world", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_to_world();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_to_world__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_to_world__drawing_options(__sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_with_animation__animation", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_with_animation__animation(__sklib_ptr anim);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_with_animation__animation__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_with_animation__animation__drawing_options(__sklib_ptr anim, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_with_bitmap_cell__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_with_bitmap_cell__int(int cell);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__option_with_bitmap_cell__int__drawing_options", CharSet=CharSet.Ansi)]
    private static extern __sklib_drawing_options __sklib__option_with_bitmap_cell__int__drawing_options(int cell, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_ellipse__color__rectangle", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_ellipse__color__rectangle(__sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_ellipse__color__rectangle__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_ellipse__color__rectangle__drawing_options(__sklib_color clr, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_ellipse__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_ellipse__color__double__double__double__double(__sklib_color clr, double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_ellipse__color__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_ellipse__color__double__double__double__double__drawing_options(__sklib_color clr, double x, double y, double width, double height, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_ellipse_on_bitmap__bitmap__color__rectangle", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_ellipse_on_bitmap__bitmap__color__rectangle(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_ellipse_on_bitmap__bitmap__color__rectangle__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_ellipse_on_bitmap__bitmap__color__rectangle__drawing_options(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_ellipse_on_bitmap__bitmap__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_ellipse_on_bitmap__bitmap__color__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_ellipse_on_bitmap__bitmap__color__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_ellipse_on_bitmap__bitmap__color__double__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_ellipse_on_window__window__color__rectangle", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_ellipse_on_window__window__color__rectangle(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_ellipse_on_window__window__color__rectangle__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_ellipse_on_window__window__color__rectangle__drawing_options(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_ellipse_on_window__window__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_ellipse_on_window__window__color__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_ellipse_on_window__window__color__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_ellipse_on_window__window__color__double__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_ellipse__color__rectangle", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_ellipse__color__rectangle(__sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_ellipse__color__rectangle__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_ellipse__color__rectangle__drawing_options(__sklib_color clr, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_ellipse__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_ellipse__color__double__double__double__double(__sklib_color clr, double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_ellipse__color__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_ellipse__color__double__double__double__double__drawing_options(__sklib_color clr, double x, double y, double width, double height, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_ellipse_on_bitmap__bitmap__color__rectangle", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_ellipse_on_bitmap__bitmap__color__rectangle(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_ellipse_on_bitmap__bitmap__color__rectangle__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_ellipse_on_bitmap__bitmap__color__rectangle__drawing_options(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_ellipse_on_bitmap__bitmap__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_ellipse_on_bitmap__bitmap__color__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_ellipse_on_bitmap__bitmap__color__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_ellipse_on_bitmap__bitmap__color__double__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_ellipse_on_window__window__color__rectangle", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_ellipse_on_window__window__color__rectangle(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_ellipse_on_window__window__color__rectangle__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_ellipse_on_window__window__color__rectangle__drawing_options(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_ellipse_on_window__window__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_ellipse_on_window__window__color__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_ellipse_on_window__window__color__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_ellipse_on_window__window__color__double__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__cosine__float", CharSet=CharSet.Ansi)]
    private static extern float __sklib__cosine__float(float degrees);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sine__float", CharSet=CharSet.Ansi)]
    private static extern float __sklib__sine__float(float degrees);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__tangent__float", CharSet=CharSet.Ansi)]
    private static extern float __sklib__tangent__float(float degrees);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__clear_screen", CharSet=CharSet.Ansi)]
    private static extern void __sklib__clear_screen();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__clear_screen__color", CharSet=CharSet.Ansi)]
    private static extern void __sklib__clear_screen__color(__sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__display_details__unsigned_int", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__display_details__unsigned_int(uint index);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__display_height__display", CharSet=CharSet.Ansi)]
    private static extern int __sklib__display_height__display(__sklib_ptr disp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__display_name__display", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__display_name__display(__sklib_ptr disp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__display_width__display", CharSet=CharSet.Ansi)]
    private static extern int __sklib__display_width__display(__sklib_ptr disp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__display_x__display", CharSet=CharSet.Ansi)]
    private static extern int __sklib__display_x__display(__sklib_ptr disp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__display_y__display", CharSet=CharSet.Ansi)]
    private static extern int __sklib__display_y__display(__sklib_ptr disp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__number_of_displays", CharSet=CharSet.Ansi)]
    private static extern int __sklib__number_of_displays();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__refresh_screen", CharSet=CharSet.Ansi)]
    private static extern void __sklib__refresh_screen();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__refresh_screen__unsigned_int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__refresh_screen__unsigned_int(uint targetFps);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__save_bitmap__bitmap__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__save_bitmap__bitmap__string_ref(__sklib_ptr bmp, __sklib_string basename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__screen_height", CharSet=CharSet.Ansi)]
    private static extern int __sklib__screen_height();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__screen_width", CharSet=CharSet.Ansi)]
    private static extern int __sklib__screen_width();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__take_screenshot__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__take_screenshot__string_ref(__sklib_string basename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__take_screenshot__window__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__take_screenshot__window__string_ref(__sklib_ptr wind, __sklib_string basename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_bounding_circle__bitmap__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_circle __sklib__bitmap_bounding_circle__bitmap__point_2d_ref(__sklib_ptr bmp, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_bounding_rectangle__bitmap", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__bitmap_bounding_rectangle__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_bounding_rectangle__bitmap__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__bitmap_bounding_rectangle__bitmap__double__double(__sklib_ptr bmp, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_cell_center__bitmap", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__bitmap_cell_center__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_cell_circle__bitmap__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_circle __sklib__bitmap_cell_circle__bitmap__double__double(__sklib_ptr bmp, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_cell_circle__bitmap__point_2d", CharSet=CharSet.Ansi)]
    private static extern __sklib_circle __sklib__bitmap_cell_circle__bitmap__point_2d(__sklib_ptr bmp, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_cell_circle__bitmap__point_2d__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_circle __sklib__bitmap_cell_circle__bitmap__point_2d__double(__sklib_ptr bmp, __sklib_point_2d pt, double scale);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_cell_columns__bitmap", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_cell_columns__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_cell_count__bitmap", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_cell_count__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_cell_height__bitmap", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_cell_height__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_cell_offset__bitmap__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__bitmap_cell_offset__bitmap__int(__sklib_ptr src, int cell);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_cell_rectangle__bitmap", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__bitmap_cell_rectangle__bitmap(__sklib_ptr src);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_cell_rectangle__bitmap__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__bitmap_cell_rectangle__bitmap__point_2d_ref(__sklib_ptr src, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_cell_rows__bitmap", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_cell_rows__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_cell_width__bitmap", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_cell_width__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_center__bitmap", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__bitmap_center__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_filename__bitmap", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__bitmap_filename__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_height__bitmap", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_height__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_height__string", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_height__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_name__bitmap", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__bitmap_name__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_named__string", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__bitmap_named__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_rectangle_of_cell__bitmap__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__bitmap_rectangle_of_cell__bitmap__int(__sklib_ptr src, int cell);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_set_cell_details__bitmap__int__int__int__int__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__bitmap_set_cell_details__bitmap__int__int__int__int__int(__sklib_ptr bmp, int width, int height, int columns, int rows, int count);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_valid__bitmap", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_valid__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_width__bitmap", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_width__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_width__string", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_width__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__clear_bitmap__bitmap__color", CharSet=CharSet.Ansi)]
    private static extern void __sklib__clear_bitmap__bitmap__color(__sklib_ptr bmp, __sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__clear_bitmap__string__color", CharSet=CharSet.Ansi)]
    private static extern void __sklib__clear_bitmap__string__color(__sklib_string name, __sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_bitmap__string__int__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_bitmap__string__int__int(__sklib_string name, int width, int height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_bitmap__bitmap__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_bitmap__bitmap__double__double(__sklib_ptr bmp, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_bitmap__bitmap__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_bitmap__bitmap__double__double__drawing_options(__sklib_ptr bmp, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_bitmap__string__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_bitmap__string__double__double(__sklib_string name, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_bitmap__string__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_bitmap__string__double__double__drawing_options(__sklib_string name, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_bitmap_on_bitmap__bitmap__bitmap__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_bitmap_on_bitmap__bitmap__bitmap__double__double(__sklib_ptr destination, __sklib_ptr bmp, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_bitmap_on_bitmap__bitmap__bitmap__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_bitmap_on_bitmap__bitmap__bitmap__double__double__drawing_options(__sklib_ptr destination, __sklib_ptr bmp, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_bitmap_on_window__window__bitmap__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_bitmap_on_window__window__bitmap__double__double(__sklib_ptr destination, __sklib_ptr bmp, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_bitmap_on_window__window__bitmap__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_bitmap_on_window__window__bitmap__double__double__drawing_options(__sklib_ptr destination, __sklib_ptr bmp, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_all_bitmaps", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_all_bitmaps();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_bitmap__bitmap", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_bitmap__bitmap(__sklib_ptr toDelete);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_bitmap__string", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_bitmap__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__load_bitmap__string__string", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__load_bitmap__string__string(__sklib_string name, __sklib_string filename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__pixel_drawn_at_point__bitmap__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__pixel_drawn_at_point__bitmap__point_2d_ref(__sklib_ptr bmp, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__pixel_drawn_at_point__bitmap__double__double", CharSet=CharSet.Ansi)]
    private static extern int __sklib__pixel_drawn_at_point__bitmap__double__double(__sklib_ptr bmp, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__pixel_drawn_at_point__bitmap__int__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__pixel_drawn_at_point__bitmap__int__point_2d_ref(__sklib_ptr bmp, int cell, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__pixel_drawn_at_point__bitmap__int__double__double", CharSet=CharSet.Ansi)]
    private static extern int __sklib__pixel_drawn_at_point__bitmap__int__double__double(__sklib_ptr bmp, int cell, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__setup_collision_mask__bitmap", CharSet=CharSet.Ansi)]
    private static extern void __sklib__setup_collision_mask__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__process_events", CharSet=CharSet.Ansi)]
    private static extern void __sklib__process_events();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__quit_requested", CharSet=CharSet.Ansi)]
    private static extern int __sklib__quit_requested();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__reset_quit", CharSet=CharSet.Ansi)]
    private static extern void __sklib__reset_quit();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__add_column__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__add_column__int(int width);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__add_column_relative__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__add_column_relative__double(double width);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_button__bitmap", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_button__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_button__bitmap__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_button__bitmap__rectangle_ref(__sklib_ptr bmp, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_button__bitmap__rectangle_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_button__bitmap__rectangle_ref__drawing_options(__sklib_ptr bmp, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_button__bitmap__drawing_options", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_button__bitmap__drawing_options(__sklib_ptr bmp, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_button__string_ref__bitmap", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_button__string_ref__bitmap(__sklib_string labelText, __sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__bitmap_button__string_ref__bitmap__drawing_options", CharSet=CharSet.Ansi)]
    private static extern int __sklib__bitmap_button__string_ref__bitmap__drawing_options(__sklib_string labelText, __sklib_ptr bmp, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__button__string_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__button__string_ref__rectangle_ref(__sklib_string text, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__button__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__button__string_ref(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__button__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__button__string_ref__string_ref(__sklib_string labelText, __sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__checkbox__string_ref__bool_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__checkbox__string_ref__bool_ref__rectangle_ref(__sklib_string text, int value, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__checkbox__string_ref__bool_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__checkbox__string_ref__bool_ref(__sklib_string text, int value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__checkbox__string_ref__string_ref__bool_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__checkbox__string_ref__string_ref__bool_ref(__sklib_string labelText, __sklib_string text, int value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_slider__color_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_slider__color_ref__rectangle_ref(__sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_slider__color_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_slider__color_ref(__sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__color_slider__string_ref__color_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__color_slider__string_ref__color_ref(__sklib_string labelText, __sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__disable_interface", CharSet=CharSet.Ansi)]
    private static extern void __sklib__disable_interface();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_interface", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_interface();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__enable_interface", CharSet=CharSet.Ansi)]
    private static extern void __sklib__enable_interface();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__end_inset__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__end_inset__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__end_panel__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__end_panel__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__end_popup__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__end_popup__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__end_treenode__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__end_treenode__string_ref(__sklib_string labelText);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__enter_column", CharSet=CharSet.Ansi)]
    private static extern void __sklib__enter_column();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__get_interface_label_width", CharSet=CharSet.Ansi)]
    private static extern int __sklib__get_interface_label_width();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__header__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__header__string_ref(__sklib_string labelText);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__hsb_color_slider__color_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__hsb_color_slider__color_ref__rectangle_ref(__sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__hsb_color_slider__color_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__hsb_color_slider__color_ref(__sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__hsb_color_slider__string_ref__color_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__hsb_color_slider__string_ref__color_ref(__sklib_string labelText, __sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__interface_enabled", CharSet=CharSet.Ansi)]
    private static extern int __sklib__interface_enabled();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__interface_style_panel__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__interface_style_panel__rectangle_ref(__sklib_rectangle initialRectangle);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__label_element__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__label_element__string_ref(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__label_element__string_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__label_element__string_ref__rectangle_ref(__sklib_string text, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__last_element_changed", CharSet=CharSet.Ansi)]
    private static extern int __sklib__last_element_changed();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__last_element_confirmed", CharSet=CharSet.Ansi)]
    private static extern int __sklib__last_element_confirmed();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__leave_column", CharSet=CharSet.Ansi)]
    private static extern void __sklib__leave_column();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__number_box__float_ref__float__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern float __sklib__number_box__float_ref__float__rectangle_ref(float value, float step, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__number_box__float_ref__float", CharSet=CharSet.Ansi)]
    private static extern float __sklib__number_box__float_ref__float(float value, float step);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__number_box__string_ref__float_ref__float", CharSet=CharSet.Ansi)]
    private static extern float __sklib__number_box__string_ref__float_ref__float(__sklib_string labelText, float value, float step);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__open_popup__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__open_popup__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__paragraph__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__paragraph__string_ref(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__paragraph__string_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__paragraph__string_ref__rectangle_ref(__sklib_string text, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__reset_layout", CharSet=CharSet.Ansi)]
    private static extern void __sklib__reset_layout();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_accent_color__color__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_accent_color__color__float(__sklib_color clr, float contrast);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_border_color__color", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_border_color__color(__sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_colors_auto__color__color__float__float__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_colors_auto__color__color__float__float__float(__sklib_color mainClr, __sklib_color accentClr, float contrast, float accentContrast, float borderContrast);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_element_color__color__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_element_color__color__float(__sklib_color clr, float contrast);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_element_shadows__int__color__point_2d", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_element_shadows__int__color__point_2d(int radius, __sklib_color clr, __sklib_point_2d offset);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_font__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_font__string_ref(__sklib_string fnt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_font__font", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_font__font(__sklib_ptr fnt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_font_size__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_font_size__int(int size);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_label_width__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_label_width__int(int width);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_panel_shadows__int__color__point_2d", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_panel_shadows__int__color__point_2d(int radius, __sklib_color clr, __sklib_point_2d offset);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_root_text_color__color", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_root_text_color__color(__sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_shadows__int__color__point_2d", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_shadows__int__color__point_2d(int radius, __sklib_color clr, __sklib_point_2d offset);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_spacing__int__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_spacing__int__int(int spacing, int padding);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_style__interface_style", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_style__interface_style(int style);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_style__interface_style__color", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_style__interface_style__color(int style, __sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_interface_text_color__color", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_interface_text_color__color(__sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_layout_height__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_layout_height__int(int height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__single_line_layout", CharSet=CharSet.Ansi)]
    private static extern void __sklib__single_line_layout();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__slider__float_ref__float__float__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern float __sklib__slider__float_ref__float__float__rectangle_ref(float value, float minValue, float maxValue, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__slider__float_ref__float__float", CharSet=CharSet.Ansi)]
    private static extern float __sklib__slider__float_ref__float__float(float value, float minValue, float maxValue);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__slider__string_ref__float_ref__float__float", CharSet=CharSet.Ansi)]
    private static extern float __sklib__slider__string_ref__float_ref__float__float(__sklib_string labelText, float value, float minValue, float maxValue);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__split_into_columns__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__split_into_columns__int(int count);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__split_into_columns__int__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__split_into_columns__int__int(int count, int lastWidth);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__split_into_columns_relative__int__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__split_into_columns_relative__int__double(int count, double lastWidth);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_custom_layout", CharSet=CharSet.Ansi)]
    private static extern void __sklib__start_custom_layout();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_inset__string_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__start_inset__string_ref__rectangle_ref(__sklib_string name, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_inset__string_ref__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__start_inset__string_ref__int(__sklib_string name, int height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_panel__string_ref__rectangle", CharSet=CharSet.Ansi)]
    private static extern int __sklib__start_panel__string_ref__rectangle(__sklib_string name, __sklib_rectangle initialRectangle);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_popup__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__start_popup__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_treenode__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__start_treenode__string_ref(__sklib_string labelText);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__text_box__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__text_box__string_ref(__sklib_string value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__text_box__string_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__text_box__string_ref__rectangle_ref(__sklib_string value, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__text_box__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__text_box__string_ref__string_ref(__sklib_string labelText, __sklib_string value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_json", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_json();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_json__string", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_json__string(__sklib_string jsonString);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_all_json", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_all_json();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_json__json", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_json__json(__sklib_ptr j);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_count_keys__json", CharSet=CharSet.Ansi)]
    private static extern int __sklib__json_count_keys__json(__sklib_ptr j);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_from_color__color", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__json_from_color__color(__sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_from_file__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__json_from_file__string_ref(__sklib_string filename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_from_string__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__json_from_string__string_ref(__sklib_string jString);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_has_key__json__string", CharSet=CharSet.Ansi)]
    private static extern int __sklib__json_has_key__json__string(__sklib_ptr j, __sklib_string key);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_read_array__json__string__vector_double_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_read_array__json__string__vector_double_ref(__sklib_ptr j, __sklib_string key, ref __sklib_vector_double outResult);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_read_array__json__string__vector_json_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_read_array__json__string__vector_json_ref(__sklib_ptr j, __sklib_string key, ref __sklib_vector_json outResult);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_read_array__json__string__vector_string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_read_array__json__string__vector_string_ref(__sklib_ptr j, __sklib_string key, ref __sklib_vector_string outResult);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_read_array__json__string__vector_bool_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_read_array__json__string__vector_bool_ref(__sklib_ptr j, __sklib_string key, ref __sklib_vector_bool outResult);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_read_bool__json__string", CharSet=CharSet.Ansi)]
    private static extern int __sklib__json_read_bool__json__string(__sklib_ptr j, __sklib_string key);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_read_number__json__string", CharSet=CharSet.Ansi)]
    private static extern float __sklib__json_read_number__json__string(__sklib_ptr j, __sklib_string key);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_read_number_as_double__json__string", CharSet=CharSet.Ansi)]
    private static extern double __sklib__json_read_number_as_double__json__string(__sklib_ptr j, __sklib_string key);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_read_number_as_int__json__string", CharSet=CharSet.Ansi)]
    private static extern int __sklib__json_read_number_as_int__json__string(__sklib_ptr j, __sklib_string key);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_read_object__json__string", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__json_read_object__json__string(__sklib_ptr j, __sklib_string key);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_read_string__json__string", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__json_read_string__json__string(__sklib_ptr j, __sklib_string key);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_set_array__json__string__vector_string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_set_array__json__string__vector_string(__sklib_ptr j, __sklib_string key, __sklib_vector_string value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_set_array__json__string__vector_double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_set_array__json__string__vector_double(__sklib_ptr j, __sklib_string key, __sklib_vector_double value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_set_array__json__string__vector_bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_set_array__json__string__vector_bool(__sklib_ptr j, __sklib_string key, __sklib_vector_bool value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_set_array__json__string__vector_json", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_set_array__json__string__vector_json(__sklib_ptr j, __sklib_string key, __sklib_vector_json value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_set_bool__json__string__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_set_bool__json__string__bool(__sklib_ptr j, __sklib_string key, int value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_set_number__json__string__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_set_number__json__string__int(__sklib_ptr j, __sklib_string key, int value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_set_number__json__string__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_set_number__json__string__double(__sklib_ptr j, __sklib_string key, double value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_set_number__json__string__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_set_number__json__string__float(__sklib_ptr j, __sklib_string key, float value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_set_object__json__string__json", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_set_object__json__string__json(__sklib_ptr j, __sklib_string key, __sklib_ptr obj);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_set_string__json__string__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_set_string__json__string__string(__sklib_ptr j, __sklib_string key, __sklib_string value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_to_color__json", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__json_to_color__json(__sklib_ptr j);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_to_file__json__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__json_to_file__json__string_ref(__sklib_ptr j, __sklib_string filename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__json_to_string__json", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__json_to_string__json(__sklib_ptr j);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__any_key_pressed", CharSet=CharSet.Ansi)]
    private static extern int __sklib__any_key_pressed();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__deregister_callback_on_key_down__key_callback_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__deregister_callback_on_key_down__key_callback_ptr(KeyCallback callback);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__deregister_callback_on_key_typed__key_callback_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__deregister_callback_on_key_typed__key_callback_ptr(KeyCallback callback);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__deregister_callback_on_key_up__key_callback_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__deregister_callback_on_key_up__key_callback_ptr(KeyCallback callback);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__key_down__key_code", CharSet=CharSet.Ansi)]
    private static extern int __sklib__key_down__key_code(int key);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__key_name__key_code", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__key_name__key_code(int key);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__key_released__key_code", CharSet=CharSet.Ansi)]
    private static extern int __sklib__key_released__key_code(int key);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__key_typed__key_code", CharSet=CharSet.Ansi)]
    private static extern int __sklib__key_typed__key_code(int key);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__key_up__key_code", CharSet=CharSet.Ansi)]
    private static extern int __sklib__key_up__key_code(int key);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__register_callback_on_key_down__key_callback_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__register_callback_on_key_down__key_callback_ptr(KeyCallback callback);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__register_callback_on_key_typed__key_callback_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__register_callback_on_key_typed__key_callback_ptr(KeyCallback callback);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__register_callback_on_key_up__key_callback_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__register_callback_on_key_up__key_callback_ptr(KeyCallback callback);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line__color__line_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line__color__line_ref(__sklib_color clr, __sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line__color__line_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line__color__line_ref__drawing_options(__sklib_color clr, __sklib_line l, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line__color__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line__color__point_2d_ref__point_2d_ref(__sklib_color clr, __sklib_point_2d fromPt, __sklib_point_2d toPt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line__color__point_2d_ref__point_2d_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line__color__point_2d_ref__point_2d_ref__drawing_options_ref(__sklib_color clr, __sklib_point_2d fromPt, __sklib_point_2d toPt, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line__color__double__double__double__double(__sklib_color clr, double x1, double y1, double x2, double y2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line__color__double__double__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line__color__double__double__double__double__drawing_options_ref(__sklib_color clr, double x1, double y1, double x2, double y2, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line_on_bitmap__bitmap__color__line_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line_on_bitmap__bitmap__color__line_ref(__sklib_ptr destination, __sklib_color clr, __sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line_on_bitmap__bitmap__color__line_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line_on_bitmap__bitmap__color__line_ref__drawing_options(__sklib_ptr destination, __sklib_color clr, __sklib_line l, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line_on_bitmap__bitmap__color__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line_on_bitmap__bitmap__color__point_2d_ref__point_2d_ref(__sklib_ptr destination, __sklib_color clr, __sklib_point_2d fromPt, __sklib_point_2d toPt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line_on_bitmap__bitmap__color__point_2d_ref__point_2d_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line_on_bitmap__bitmap__color__point_2d_ref__point_2d_ref__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, __sklib_point_2d fromPt, __sklib_point_2d toPt, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line_on_bitmap__bitmap__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line_on_bitmap__bitmap__color__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x1, double y1, double x2, double y2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line_on_bitmap__bitmap__color__double__double__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line_on_bitmap__bitmap__color__double__double__double__double__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, double x1, double y1, double x2, double y2, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line_on_window__window__color__line_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line_on_window__window__color__line_ref(__sklib_ptr destination, __sklib_color clr, __sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line_on_window__window__color__line_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line_on_window__window__color__line_ref__drawing_options(__sklib_ptr destination, __sklib_color clr, __sklib_line l, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line_on_window__window__color__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line_on_window__window__color__point_2d_ref__point_2d_ref(__sklib_ptr destination, __sklib_color clr, __sklib_point_2d fromPt, __sklib_point_2d toPt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line_on_window__window__color__point_2d_ref__point_2d_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line_on_window__window__color__point_2d_ref__point_2d_ref__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, __sklib_point_2d fromPt, __sklib_point_2d toPt, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line_on_window__window__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line_on_window__window__color__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x1, double y1, double x2, double y2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_line_on_window__window__color__double__double__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_line_on_window__window__color__double__double__double__double__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, double x1, double y1, double x2, double y2, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__closest_point_on_line__point_2d__line_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__closest_point_on_line__point_2d__line_ref(__sklib_point_2d fromPt, __sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__closest_point_on_lines__point_2d__vector_line_ref__int_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__closest_point_on_lines__point_2d__vector_line_ref__int_ref(__sklib_point_2d fromPt, __sklib_vector_line lines, ref int lineIdx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_from__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_line __sklib__line_from__point_2d_ref__point_2d_ref(__sklib_point_2d start, __sklib_point_2d endPt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_from__point_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_line __sklib__line_from__point_2d_ref__vector_2d_ref(__sklib_point_2d start, __sklib_vector_2d offset);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_from__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_line __sklib__line_from__vector_2d_ref(__sklib_vector_2d v);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_from__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_line __sklib__line_from__double__double__double__double(double x1, double y1, double x2, double y2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_intersection_point__line_ref__line_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__line_intersection_point__line_ref__line_ref__point_2d_ref(__sklib_line line1, __sklib_line line2, ref __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_intersects_circle__line_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__line_intersects_circle__line_ref__circle_ref(__sklib_line l, __sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_intersects_lines__line_ref__vector_line_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__line_intersects_lines__line_ref__vector_line_ref(__sklib_line l, __sklib_vector_line lines);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_intersects_rect__line_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__line_intersects_rect__line_ref__rectangle_ref(__sklib_line l, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_length__line_ref", CharSet=CharSet.Ansi)]
    private static extern float __sklib__line_length__line_ref(__sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_length_squared__line_ref", CharSet=CharSet.Ansi)]
    private static extern float __sklib__line_length_squared__line_ref(__sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_mid_point__line_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__line_mid_point__line_ref(__sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_normal__line_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__line_normal__line_ref(__sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__line_to_string__line_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__line_to_string__line_ref(__sklib_line ln);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__lines_from__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_line __sklib__lines_from__rectangle_ref(__sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__lines_from__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_line __sklib__lines_from__triangle_ref(__sklib_triangle t);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__lines_intersect__line_ref__line_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__lines_intersect__line_ref__line_ref(__sklib_line l1, __sklib_line l2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_log_process", CharSet=CharSet.Ansi)]
    private static extern void __sklib__close_log_process();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__init_custom_logger__log_mode", CharSet=CharSet.Ansi)]
    private static extern void __sklib__init_custom_logger__log_mode(int mode);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__init_custom_logger__string__bool__log_mode", CharSet=CharSet.Ansi)]
    private static extern void __sklib__init_custom_logger__string__bool__log_mode(__sklib_string appName, int overridePrevLog, int mode);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__log__log_level__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__log__log_level__string(int level, __sklib_string message);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__apply_matrix__matrix_2d_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__apply_matrix__matrix_2d_ref__quad_ref(__sklib_matrix_2d matrix, ref __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__apply_matrix__matrix_2d_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__apply_matrix__matrix_2d_ref__triangle_ref(__sklib_matrix_2d m, ref __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__identity_matrix", CharSet=CharSet.Ansi)]
    private static extern __sklib_matrix_2d __sklib__identity_matrix();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__matrix_inverse__matrix_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_matrix_2d __sklib__matrix_inverse__matrix_2d_ref(__sklib_matrix_2d m);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__matrix_multiply__matrix_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__matrix_multiply__matrix_2d_ref__point_2d_ref(__sklib_matrix_2d m, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__matrix_multiply__matrix_2d_ref__matrix_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_matrix_2d __sklib__matrix_multiply__matrix_2d_ref__matrix_2d_ref(__sklib_matrix_2d m1, __sklib_matrix_2d m2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__matrix_multiply__matrix_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__matrix_multiply__matrix_2d_ref__vector_2d_ref(__sklib_matrix_2d m, __sklib_vector_2d v);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__matrix_to_string__matrix_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__matrix_to_string__matrix_2d_ref(__sklib_matrix_2d matrix);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rotation_matrix__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_matrix_2d __sklib__rotation_matrix__double(double deg);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__scale_matrix__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_matrix_2d __sklib__scale_matrix__point_2d_ref(__sklib_point_2d scale);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__scale_matrix__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_matrix_2d __sklib__scale_matrix__vector_2d_ref(__sklib_vector_2d scale);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__scale_matrix__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_matrix_2d __sklib__scale_matrix__double(double scale);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__scale_rotate_translate_matrix__point_2d_ref__double__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_matrix_2d __sklib__scale_rotate_translate_matrix__point_2d_ref__double__point_2d_ref(__sklib_point_2d scale, double deg, __sklib_point_2d translate);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__translation_matrix__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_matrix_2d __sklib__translation_matrix__point_2d_ref(__sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__translation_matrix__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_matrix_2d __sklib__translation_matrix__vector_2d_ref(__sklib_vector_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__translation_matrix__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_matrix_2d __sklib__translation_matrix__double__double(double dx, double dy);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__hide_mouse", CharSet=CharSet.Ansi)]
    private static extern void __sklib__hide_mouse();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__mouse_clicked__mouse_button", CharSet=CharSet.Ansi)]
    private static extern int __sklib__mouse_clicked__mouse_button(int button);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__mouse_down__mouse_button", CharSet=CharSet.Ansi)]
    private static extern int __sklib__mouse_down__mouse_button(int button);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__mouse_movement", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__mouse_movement();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__mouse_position", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__mouse_position();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__mouse_position_vector", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__mouse_position_vector();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__mouse_shown", CharSet=CharSet.Ansi)]
    private static extern int __sklib__mouse_shown();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__mouse_up__mouse_button", CharSet=CharSet.Ansi)]
    private static extern int __sklib__mouse_up__mouse_button(int button);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__mouse_wheel_scroll", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__mouse_wheel_scroll();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__mouse_x", CharSet=CharSet.Ansi)]
    private static extern float __sklib__mouse_x();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__mouse_y", CharSet=CharSet.Ansi)]
    private static extern float __sklib__mouse_y();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_mouse__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_mouse__double__double(double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_mouse__point_2d", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_mouse__point_2d(__sklib_point_2d point);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__show_mouse", CharSet=CharSet.Ansi)]
    private static extern void __sklib__show_mouse();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__show_mouse__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__show_mouse__bool(int show);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fade_music_in__string_ref__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fade_music_in__string_ref__int(__sklib_string name, int ms);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fade_music_in__string_ref__int__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fade_music_in__string_ref__int__int(__sklib_string name, int times, int ms);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fade_music_in__music__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fade_music_in__music__int(__sklib_ptr data, int ms);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fade_music_in__music__int__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fade_music_in__music__int__int(__sklib_ptr data, int times, int ms);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fade_music_out__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fade_music_out__int(int ms);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_all_music", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_all_music();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_music__music", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_music__music(__sklib_ptr effect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_music__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_music__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__load_music__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__load_music__string_ref__string_ref(__sklib_string name, __sklib_string filename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__music_filename__music", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__music_filename__music(__sklib_ptr data);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__music_name__music", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__music_name__music(__sklib_ptr data);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__music_named__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__music_named__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__music_playing", CharSet=CharSet.Ansi)]
    private static extern int __sklib__music_playing();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__music_valid__music", CharSet=CharSet.Ansi)]
    private static extern int __sklib__music_valid__music(__sklib_ptr m);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__music_volume", CharSet=CharSet.Ansi)]
    private static extern double __sklib__music_volume();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__pause_music", CharSet=CharSet.Ansi)]
    private static extern void __sklib__pause_music();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_music__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_music__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_music__string_ref__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_music__string_ref__int(__sklib_string name, int times);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_music__music", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_music__music(__sklib_ptr data);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_music__music__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_music__music__int(__sklib_ptr data, int times);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_music__music__int__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_music__music__int__double(__sklib_ptr data, int times, double volume);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resume_music", CharSet=CharSet.Ansi)]
    private static extern void __sklib__resume_music();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_music_volume__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_music_volume__double(double volume);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__stop_music", CharSet=CharSet.Ansi)]
    private static extern void __sklib__stop_music();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__accept_all_new_connections", CharSet=CharSet.Ansi)]
    private static extern int __sklib__accept_all_new_connections();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__accept_new_connection__server_socket", CharSet=CharSet.Ansi)]
    private static extern int __sklib__accept_new_connection__server_socket(__sklib_ptr server);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__broadcast_message__string_ref__server_socket", CharSet=CharSet.Ansi)]
    private static extern void __sklib__broadcast_message__string_ref__server_socket(__sklib_string aMsg, __sklib_ptr svr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__broadcast_message__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__broadcast_message__string_ref(__sklib_string aMsg);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__broadcast_message__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__broadcast_message__string_ref__string_ref(__sklib_string aMsg, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__check_network_activity", CharSet=CharSet.Ansi)]
    private static extern void __sklib__check_network_activity();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__clear_messages__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__clear_messages__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__clear_messages__connection", CharSet=CharSet.Ansi)]
    private static extern void __sklib__clear_messages__connection(__sklib_ptr aConnection);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__clear_messages__server_socket", CharSet=CharSet.Ansi)]
    private static extern void __sklib__clear_messages__server_socket(__sklib_ptr svr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_all_connections", CharSet=CharSet.Ansi)]
    private static extern void __sklib__close_all_connections();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_all_servers", CharSet=CharSet.Ansi)]
    private static extern void __sklib__close_all_servers();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_connection__connection", CharSet=CharSet.Ansi)]
    private static extern int __sklib__close_connection__connection(__sklib_ptr aConnection);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_connection__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__close_connection__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_message__message", CharSet=CharSet.Ansi)]
    private static extern void __sklib__close_message__message(__sklib_ptr msg);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_server__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__close_server__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_server__server_socket", CharSet=CharSet.Ansi)]
    private static extern int __sklib__close_server__server_socket(__sklib_ptr svr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__connection_count__string_ref", CharSet=CharSet.Ansi)]
    private static extern uint __sklib__connection_count__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__connection_count__server_socket", CharSet=CharSet.Ansi)]
    private static extern uint __sklib__connection_count__server_socket(__sklib_ptr server);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__connection_ip__connection", CharSet=CharSet.Ansi)]
    private static extern uint __sklib__connection_ip__connection(__sklib_ptr aConnection);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__connection_ip__string_ref", CharSet=CharSet.Ansi)]
    private static extern uint __sklib__connection_ip__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__connection_named__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__connection_named__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__connection_port__connection", CharSet=CharSet.Ansi)]
    private static extern ushort __sklib__connection_port__connection(__sklib_ptr aConnection);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__connection_port__string_ref", CharSet=CharSet.Ansi)]
    private static extern ushort __sklib__connection_port__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_server__string_ref__unsigned_short", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_server__string_ref__unsigned_short(__sklib_string name, ushort port);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_server__string_ref__unsigned_short__connection_type", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_server__string_ref__unsigned_short__connection_type(__sklib_string name, ushort port, int protocol);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__dec_to_hex__unsigned_int", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__dec_to_hex__unsigned_int(uint aDec);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__dec_to_ipv4__unsigned_int", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__dec_to_ipv4__unsigned_int(uint ip);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fetch_new_connection__server_socket", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__fetch_new_connection__server_socket(__sklib_ptr server);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_connection__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_connection__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_messages", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_messages();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_messages__connection", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_messages__connection(__sklib_ptr con);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_messages__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_messages__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_messages__server_socket", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_messages__server_socket(__sklib_ptr svr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_new_connections", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_new_connections();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_server__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_server__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__hex_str_to_ipv4__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__hex_str_to_ipv4__string_ref(__sklib_string aHex);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__hex_to_dec_string__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__hex_to_dec_string__string_ref(__sklib_string aHex);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__ipv4_to_dec__string_ref", CharSet=CharSet.Ansi)]
    private static extern uint __sklib__ipv4_to_dec__string_ref(__sklib_string aIP);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__ipv4_to_hex__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__ipv4_to_hex__string_ref(__sklib_string aIP);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_connection_open__connection", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_connection_open__connection(__sklib_ptr con);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_connection_open__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_connection_open__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_valid_ipv4__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_valid_ipv4__string_ref(__sklib_string ip);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__last_connection__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__last_connection__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__last_connection__server_socket", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__last_connection__server_socket(__sklib_ptr server);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__message_connection__message", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__message_connection__message(__sklib_ptr msg);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__message_count__server_socket", CharSet=CharSet.Ansi)]
    private static extern uint __sklib__message_count__server_socket(__sklib_ptr svr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__message_count__connection", CharSet=CharSet.Ansi)]
    private static extern uint __sklib__message_count__connection(__sklib_ptr aConnection);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__message_count__string_ref", CharSet=CharSet.Ansi)]
    private static extern uint __sklib__message_count__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__message_data__message", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__message_data__message(__sklib_ptr msg);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__message_data_bytes__message", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_int8_t __sklib__message_data_bytes__message(__sklib_ptr msg);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__message_host__message", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__message_host__message(__sklib_ptr msg);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__message_port__message", CharSet=CharSet.Ansi)]
    private static extern ushort __sklib__message_port__message(__sklib_ptr msg);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__message_protocol__message", CharSet=CharSet.Ansi)]
    private static extern int __sklib__message_protocol__message(__sklib_ptr msg);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__my_ip", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__my_ip();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__name_for_connection__string__unsigned_int", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__name_for_connection__string__unsigned_int(__sklib_string host, uint port);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__new_connection_count__server_socket", CharSet=CharSet.Ansi)]
    private static extern int __sklib__new_connection_count__server_socket(__sklib_ptr server);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__open_connection__string_ref__string_ref__unsigned_short", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__open_connection__string_ref__string_ref__unsigned_short(__sklib_string name, __sklib_string host, ushort port);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__open_connection__string_ref__string_ref__unsigned_short__connection_type", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__open_connection__string_ref__string_ref__unsigned_short__connection_type(__sklib_string name, __sklib_string host, ushort port, int protocol);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__read_message", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__read_message();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__read_message__connection", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__read_message__connection(__sklib_ptr aConnection);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__read_message__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__read_message__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__read_message__server_socket", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__read_message__server_socket(__sklib_ptr svr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__read_message_data__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__read_message_data__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__read_message_data__connection", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__read_message_data__connection(__sklib_ptr aConnection);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__read_message_data__server_socket", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__read_message_data__server_socket(__sklib_ptr svr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__reconnect__connection", CharSet=CharSet.Ansi)]
    private static extern void __sklib__reconnect__connection(__sklib_ptr aConnection);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__reconnect__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__reconnect__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__release_all_connections", CharSet=CharSet.Ansi)]
    private static extern void __sklib__release_all_connections();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__reset_new_connection_count__server_socket", CharSet=CharSet.Ansi)]
    private static extern void __sklib__reset_new_connection_count__server_socket(__sklib_ptr server);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__retrieve_connection__string_ref__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__retrieve_connection__string_ref__int(__sklib_string name, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__retrieve_connection__server_socket__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__retrieve_connection__server_socket__int(__sklib_ptr server, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_message_to__string_ref__connection", CharSet=CharSet.Ansi)]
    private static extern int __sklib__send_message_to__string_ref__connection(__sklib_string aMsg, __sklib_ptr aConnection);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_message_to__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__send_message_to__string_ref__string_ref(__sklib_string aMsg, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__server_has_new_connection__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__server_has_new_connection__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__server_has_new_connection__server_socket", CharSet=CharSet.Ansi)]
    private static extern int __sklib__server_has_new_connection__server_socket(__sklib_ptr server);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__server_named__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__server_named__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_udp_packet_size__unsigned_int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_udp_packet_size__unsigned_int(uint udpPacketSize);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__udp_packet_size", CharSet=CharSet.Ansi)]
    private static extern uint __sklib__udp_packet_size();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_pixel__color__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_pixel__color__point_2d_ref(__sklib_color clr, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_pixel__color__point_2d_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_pixel__color__point_2d_ref__drawing_options(__sklib_color clr, __sklib_point_2d pt, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_pixel__color__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_pixel__color__double__double(__sklib_color clr, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_pixel__color__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_pixel__color__double__double__drawing_options(__sklib_color clr, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_pixel_on_bitmap__bitmap__color__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_pixel_on_bitmap__bitmap__color__point_2d_ref(__sklib_ptr destination, __sklib_color clr, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_pixel_on_bitmap__bitmap__color__point_2d_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_pixel_on_bitmap__bitmap__color__point_2d_ref__drawing_options(__sklib_ptr destination, __sklib_color clr, __sklib_point_2d pt, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_pixel_on_bitmap__bitmap__color__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_pixel_on_bitmap__bitmap__color__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_pixel_on_bitmap__bitmap__color__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_pixel_on_bitmap__bitmap__color__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_pixel_on_window__window__color__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_pixel_on_window__window__color__point_2d_ref(__sklib_ptr destination, __sklib_color clr, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_pixel_on_window__window__color__point_2d_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_pixel_on_window__window__color__point_2d_ref__drawing_options(__sklib_ptr destination, __sklib_color clr, __sklib_point_2d pt, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_pixel_on_window__window__color__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_pixel_on_window__window__color__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_pixel_on_window__window__color__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_pixel_on_window__window__color__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__get_pixel__bitmap__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__get_pixel__bitmap__point_2d_ref(__sklib_ptr bmp, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__get_pixel__bitmap__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__get_pixel__bitmap__double__double(__sklib_ptr bmp, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__get_pixel__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__get_pixel__point_2d_ref(__sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__get_pixel__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__get_pixel__double__double(double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__get_pixel__window__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__get_pixel__window__point_2d_ref(__sklib_ptr wnd, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__get_pixel__window__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__get_pixel__window__double__double(__sklib_ptr wnd, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__get_pixel_from_window__window__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__get_pixel_from_window__window__point_2d_ref(__sklib_ptr destination, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__get_pixel_from_window__window__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_color __sklib__get_pixel_from_window__window__double__double(__sklib_ptr destination, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_at__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__point_at__double__double(double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_at_origin", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__point_at_origin();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_in_circle__point_2d_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__point_in_circle__point_2d_ref__circle_ref(__sklib_point_2d pt, __sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_in_circle__double__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern int __sklib__point_in_circle__double__double__double__double__double(double ptx, double pty, double cx, double cy, double radius);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_in_quad__point_2d_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__point_in_quad__point_2d_ref__quad_ref(__sklib_point_2d pt, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_in_rectangle__point_2d_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__point_in_rectangle__point_2d_ref__rectangle_ref(__sklib_point_2d pt, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_in_rectangle__double__double__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern int __sklib__point_in_rectangle__double__double__double__double__double__double(double ptx, double pty, double rectX, double rectY, double rectWidth, double rectHeight);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_in_triangle__point_2d_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__point_in_triangle__point_2d_ref__triangle_ref(__sklib_point_2d pt, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_line_distance__point_2d_ref__line_ref", CharSet=CharSet.Ansi)]
    private static extern float __sklib__point_line_distance__point_2d_ref__line_ref(__sklib_point_2d pt, __sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_offset_by__point_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__point_offset_by__point_2d_ref__vector_2d_ref(__sklib_point_2d startPoint, __sklib_vector_2d offset);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_offset_from_origin__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__point_offset_from_origin__vector_2d_ref(__sklib_vector_2d offset);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_on_line__point_2d_ref__line_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__point_on_line__point_2d_ref__line_ref(__sklib_point_2d pt, __sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_on_line__point_2d_ref__line_ref__float", CharSet=CharSet.Ansi)]
    private static extern int __sklib__point_on_line__point_2d_ref__line_ref__float(__sklib_point_2d pt, __sklib_line l, float proximity);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_point_angle__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern float __sklib__point_point_angle__point_2d_ref__point_2d_ref(__sklib_point_2d pt1, __sklib_point_2d pt2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_point_distance__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern double __sklib__point_point_distance__point_2d_ref__point_2d_ref(__sklib_point_2d pt1, __sklib_point_2d pt2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__point_to_string__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__point_to_string__point_2d_ref(__sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__random_bitmap_point__bitmap", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__random_bitmap_point__bitmap(__sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__random_screen_point", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__random_screen_point();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__random_window_point__window", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__random_window_point__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__same_point__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__same_point__point_2d_ref__point_2d_ref(__sklib_point_2d pt1, __sklib_point_2d pt2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__quad_from__point_2d_ref__point_2d_ref__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_quad __sklib__quad_from__point_2d_ref__point_2d_ref__double(__sklib_point_2d lineOrigin, __sklib_point_2d lineEnd, double width);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__quad_from__point_2d_ref__point_2d_ref__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_quad __sklib__quad_from__point_2d_ref__point_2d_ref__point_2d_ref__point_2d_ref(__sklib_point_2d p1, __sklib_point_2d p2, __sklib_point_2d p3, __sklib_point_2d p4);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__quad_from__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_quad __sklib__quad_from__rectangle_ref(__sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__quad_from__rectangle_ref__matrix_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_quad __sklib__quad_from__rectangle_ref__matrix_2d_ref(__sklib_rectangle rect, __sklib_matrix_2d transform);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__quad_from__double__double__double__double__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_quad __sklib__quad_from__double__double__double__double__double__double__double__double(double xTopLeft, double yTopLeft, double xTopRight, double yTopRight, double xBottomLeft, double yBottomLeft, double xBottomRight, double yBottomRight);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__quad_ray_intersection__point_2d_ref__vector_2d_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__quad_ray_intersection__point_2d_ref__vector_2d_ref__quad_ref(__sklib_point_2d origin, __sklib_vector_2d heading, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__quad_ray_intersection__point_2d_ref__vector_2d_ref__quad_ref__point_2d_ref__double_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__quad_ray_intersection__point_2d_ref__vector_2d_ref__quad_ref__point_2d_ref__double_ref(__sklib_point_2d origin, __sklib_vector_2d heading, __sklib_quad q, ref __sklib_point_2d hitPoint, ref double hitDistance);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__quads_intersect__quad_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__quads_intersect__quad_ref__quad_ref(__sklib_quad q1, __sklib_quad q2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_quad_point__quad_ref__int__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_quad_point__quad_ref__int__point_2d_ref(ref __sklib_quad q, int idx, __sklib_point_2d value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__triangles_from__quad_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_triangle __sklib__triangles_from__quad_ref(__sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rnd__int__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__rnd__int__int(int min, int max);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rnd", CharSet=CharSet.Ansi)]
    private static extern float __sklib__rnd();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rnd__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__rnd__int(int ubound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_gpio", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_gpio();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_cleanup", CharSet=CharSet.Ansi)]
    private static extern void __sklib__raspi_cleanup();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_get_mode__pins", CharSet=CharSet.Ansi)]
    private static extern int __sklib__raspi_get_mode__pins(int pin);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_init", CharSet=CharSet.Ansi)]
    private static extern void __sklib__raspi_init();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_read__pins", CharSet=CharSet.Ansi)]
    private static extern int __sklib__raspi_read__pins(int pin);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_set_mode__pins__pin_modes", CharSet=CharSet.Ansi)]
    private static extern void __sklib__raspi_set_mode__pins__pin_modes(int pin, int mode);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_set_pull_up_down__pins__pull_up_down", CharSet=CharSet.Ansi)]
    private static extern void __sklib__raspi_set_pull_up_down__pins__pull_up_down(int pin, int pud);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_set_pwm_dutycycle__pins__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__raspi_set_pwm_dutycycle__pins__int(int pin, int dutycycle);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_set_pwm_frequency__pins__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__raspi_set_pwm_frequency__pins__int(int pin, int frequency);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_set_pwm_range__pins__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__raspi_set_pwm_range__pins__int(int pin, int range);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_spi_close__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__raspi_spi_close__int(int handle);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_spi_open__int__int__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__raspi_spi_open__int__int__int(int channel, int speed, int spiFlags);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_spi_transfer__int__string__string__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__raspi_spi_transfer__int__string__string__int(int handle, __sklib_string sendbuf, __sklib_string recvbuf, int count);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__raspi_write__pins__pin_values", CharSet=CharSet.Ansi)]
    private static extern void __sklib__raspi_write__pins__pin_values(int pin, int value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_quad__color__quad_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_quad__color__quad_ref(__sklib_color clr, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_quad__color__quad_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_quad__color__quad_ref__drawing_options_ref(__sklib_color clr, __sklib_quad q, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_quad_on_bitmap__bitmap__color__quad_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_quad_on_bitmap__bitmap__color__quad_ref(__sklib_ptr destination, __sklib_color clr, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_quad_on_bitmap__bitmap__color__quad_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_quad_on_bitmap__bitmap__color__quad_ref__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, __sklib_quad q, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_quad_on_window__window__color__quad_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_quad_on_window__window__color__quad_ref(__sklib_ptr destination, __sklib_color clr, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_quad_on_window__window__color__quad_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_quad_on_window__window__color__quad_ref__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, __sklib_quad q, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_rectangle__color__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_rectangle__color__rectangle_ref(__sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_rectangle__color__rectangle_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_rectangle__color__rectangle_ref__drawing_options_ref(__sklib_color clr, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_rectangle__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_rectangle__color__double__double__double__double(__sklib_color clr, double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_rectangle__color__double__double__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_rectangle__color__double__double__double__double__drawing_options_ref(__sklib_color clr, double x, double y, double width, double height, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_rectangle_on_bitmap__bitmap__color__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_rectangle_on_bitmap__bitmap__color__rectangle_ref(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_rectangle_on_bitmap__bitmap__color__rectangle_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_rectangle_on_bitmap__bitmap__color__rectangle_ref__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_rectangle_on_bitmap__bitmap__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_rectangle_on_bitmap__bitmap__color__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_rectangle_on_bitmap__bitmap__color__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_rectangle_on_bitmap__bitmap__color__double__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_rectangle_on_window__window__color__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_rectangle_on_window__window__color__rectangle_ref(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_rectangle_on_window__window__color__rectangle_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_rectangle_on_window__window__color__rectangle_ref__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_rectangle_on_window__window__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_rectangle_on_window__window__color__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_rectangle_on_window__window__color__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_rectangle_on_window__window__color__double__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_quad__color__quad_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_quad__color__quad_ref(__sklib_color clr, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_quad__color__quad_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_quad__color__quad_ref__drawing_options_ref(__sklib_color clr, __sklib_quad q, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_quad_on_bitmap__bitmap__color__quad_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_quad_on_bitmap__bitmap__color__quad_ref(__sklib_ptr destination, __sklib_color clr, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_quad_on_bitmap__bitmap__color__quad_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_quad_on_bitmap__bitmap__color__quad_ref__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, __sklib_quad q, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_quad_on_window__window__color__quad_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_quad_on_window__window__color__quad_ref(__sklib_ptr destination, __sklib_color clr, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_quad_on_window__window__color__quad_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_quad_on_window__window__color__quad_ref__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, __sklib_quad q, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_rectangle__color__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_rectangle__color__rectangle_ref(__sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_rectangle__color__rectangle_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_rectangle__color__rectangle_ref__drawing_options_ref(__sklib_color clr, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_rectangle__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_rectangle__color__double__double__double__double(__sklib_color clr, double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_rectangle__color__double__double__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_rectangle__color__double__double__double__double__drawing_options_ref(__sklib_color clr, double x, double y, double width, double height, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_rectangle_on_bitmap__bitmap__color__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_rectangle_on_bitmap__bitmap__color__rectangle_ref(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_rectangle_on_bitmap__bitmap__color__rectangle_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_rectangle_on_bitmap__bitmap__color__rectangle_ref__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_rectangle_on_bitmap__bitmap__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_rectangle_on_bitmap__bitmap__color__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_rectangle_on_bitmap__bitmap__color__double__double__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_rectangle_on_bitmap__bitmap__color__double__double__double__double__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_rectangle_on_window__window__color__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_rectangle_on_window__window__color__rectangle_ref(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_rectangle_on_window__window__color__rectangle_ref__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_rectangle_on_window__window__color__rectangle_ref__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, __sklib_rectangle rect, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_rectangle_on_window__window__color__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_rectangle_on_window__window__color__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_rectangle_on_window__window__color__double__double__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_rectangle_on_window__window__color__double__double__double__double__drawing_options_ref(__sklib_ptr destination, __sklib_color clr, double x, double y, double width, double height, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__inset_rectangle__rectangle_ref__float", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__inset_rectangle__rectangle_ref__float(__sklib_rectangle rect, float insetAmount);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__intersection__rectangle_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__intersection__rectangle_ref__rectangle_ref(__sklib_rectangle rect1, __sklib_rectangle rect2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_around__circle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__rectangle_around__circle_ref(__sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_around__line_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__rectangle_around__line_ref(__sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_around__quad_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__rectangle_around__quad_ref(__sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_around__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__rectangle_around__triangle_ref(__sklib_triangle t);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_bottom__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern double __sklib__rectangle_bottom__rectangle_ref(__sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_center__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__rectangle_center__rectangle_ref(__sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_circle_intersect__rectangle_ref__circle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__rectangle_circle_intersect__rectangle_ref__circle_ref(__sklib_rectangle rect, __sklib_circle c);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_from__point_2d__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__rectangle_from__point_2d__double__double(__sklib_point_2d pt, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_from__point_2d__point_2d", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__rectangle_from__point_2d__point_2d(__sklib_point_2d pt1, __sklib_point_2d pt2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_from__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__rectangle_from__double__double__double__double(double x, double y, double width, double height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_left__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern double __sklib__rectangle_left__rectangle_ref(__sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_offset_by__rectangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__rectangle_offset_by__rectangle_ref__vector_2d_ref(__sklib_rectangle rect, __sklib_vector_2d offset);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_ray_intersection__point_2d_ref__vector_2d_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__rectangle_ray_intersection__point_2d_ref__vector_2d_ref__rectangle_ref(__sklib_point_2d origin, __sklib_vector_2d heading, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_ray_intersection__point_2d_ref__vector_2d_ref__rectangle_ref__point_2d_ref__double_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__rectangle_ray_intersection__point_2d_ref__vector_2d_ref__rectangle_ref__point_2d_ref__double_ref(__sklib_point_2d origin, __sklib_vector_2d heading, __sklib_rectangle rect, ref __sklib_point_2d hitPoint, ref double hitDistance);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_right__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern double __sklib__rectangle_right__rectangle_ref(__sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_to_string__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__rectangle_to_string__rectangle_ref(__sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangle_top__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern double __sklib__rectangle_top__rectangle_ref(__sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__rectangles_intersect__rectangle_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__rectangles_intersect__rectangle_ref__rectangle_ref(__sklib_rectangle rect1, __sklib_rectangle rect2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__deregister_free_notifier__free_notifier_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__deregister_free_notifier__free_notifier_ptr(FreeNotifier handler);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__path_to_resource__string_ref__resource_kind", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__path_to_resource__string_ref__resource_kind(__sklib_string filename, int kind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__path_to_resources", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__path_to_resources();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__path_to_resources__resource_kind", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__path_to_resources__resource_kind(int kind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__register_free_notifier__free_notifier_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__register_free_notifier__free_notifier_ptr(FreeNotifier fn);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_resources_path__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_resources_path__string_ref(__sklib_string path);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fade_all_sound_effects_out__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fade_all_sound_effects_out__int(int ms);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fade_sound_effect_out__sound_effect__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fade_sound_effect_out__sound_effect__int(__sklib_ptr effect, int ms);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_all_sound_effects", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_all_sound_effects();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_sound_effect__sound_effect", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_sound_effect__sound_effect(__sklib_ptr effect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_sound_effect__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_sound_effect__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__load_sound_effect__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__load_sound_effect__string_ref__string_ref(__sklib_string name, __sklib_string filename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_sound_effect__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_sound_effect__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_sound_effect__string_ref__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_sound_effect__string_ref__double(__sklib_string name, double volume);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_sound_effect__string_ref__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_sound_effect__string_ref__int(__sklib_string name, int times);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_sound_effect__string_ref__int__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_sound_effect__string_ref__int__double(__sklib_string name, int times, double volume);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_sound_effect__sound_effect", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_sound_effect__sound_effect(__sklib_ptr effect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_sound_effect__sound_effect__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_sound_effect__sound_effect__double(__sklib_ptr effect, double volume);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_sound_effect__sound_effect__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_sound_effect__sound_effect__int(__sklib_ptr effect, int times);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__play_sound_effect__sound_effect__int__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__play_sound_effect__sound_effect__int__double(__sklib_ptr effect, int times, double volume);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sound_effect_filename__sound_effect", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__sound_effect_filename__sound_effect(__sklib_ptr effect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sound_effect_name__sound_effect", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__sound_effect_name__sound_effect(__sklib_ptr effect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sound_effect_named__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__sound_effect_named__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sound_effect_playing__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sound_effect_playing__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sound_effect_playing__sound_effect", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sound_effect_playing__sound_effect(__sklib_ptr effect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sound_effect_valid__sound_effect", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sound_effect_valid__sound_effect(__sklib_ptr effect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__stop_sound_effect__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__stop_sound_effect__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__stop_sound_effect__sound_effect", CharSet=CharSet.Ansi)]
    private static extern void __sklib__stop_sound_effect__sound_effect(__sklib_ptr effect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__call_for_all_sprites__sprite_float_function_ptr__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__call_for_all_sprites__sprite_float_function_ptr__float(SpriteFloatFunction fn, float val);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__call_for_all_sprites__sprite_function_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__call_for_all_sprites__sprite_function_ptr(SpriteFunction fn);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__call_on_sprite_event__sprite_event_handler_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__call_on_sprite_event__sprite_event_handler_ptr(SpriteEventHandler handler);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_sprite__bitmap", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_sprite__bitmap(__sklib_ptr layer);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_sprite__bitmap__animation_script", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_sprite__bitmap__animation_script(__sklib_ptr layer, __sklib_ptr ani);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_sprite__string_ref(__sklib_string bitmapName);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_sprite__string_ref__bitmap", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_sprite__string_ref__bitmap(__sklib_string name, __sklib_ptr layer);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_sprite__string_ref__bitmap__animation_script", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_sprite__string_ref__bitmap__animation_script(__sklib_string name, __sklib_ptr layer, __sklib_ptr ani);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_sprite__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_sprite__string_ref__string_ref(__sklib_string bitmapName, __sklib_string animationName);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_sprite_pack__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__create_sprite_pack__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_sprite_pack", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__current_sprite_pack();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_all_sprites", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_all_sprites();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_sprite__sprite__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_sprite__sprite__vector_2d_ref(__sklib_ptr s, __sklib_vector_2d offset);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_sprite__sprite", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_sprite__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_sprite__sprite__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_sprite__sprite__double__double(__sklib_ptr s, double xOffset, double yOffset);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_all_sprites", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_all_sprites();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_sprite__sprite", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_sprite__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_sprite_pack__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_sprite_pack__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_sprite__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_sprite_pack__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_sprite_pack__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_sprite__sprite", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_sprite__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_sprite__sprite__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_sprite__sprite__vector_2d_ref(__sklib_ptr s, __sklib_vector_2d distance);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_sprite__sprite__vector_2d_ref__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_sprite__sprite__vector_2d_ref__float(__sklib_ptr s, __sklib_vector_2d distance, float pct);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_sprite__sprite__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_sprite__sprite__float(__sklib_ptr s, float pct);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_sprite_to__sprite__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_sprite_to__sprite__double__double(__sklib_ptr s, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__select_sprite_pack__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__select_sprite_pack__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_add_layer__sprite__bitmap__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_add_layer__sprite__bitmap__string_ref(__sklib_ptr s, __sklib_ptr newLayer, __sklib_string layerName);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_add_to_velocity__sprite__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_add_to_velocity__sprite__vector_2d_ref(__sklib_ptr s, __sklib_vector_2d value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_add_value__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_add_value__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_add_value__sprite__string_ref__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_add_value__sprite__string_ref__float(__sklib_ptr s, __sklib_string name, float initVal);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_anchor_point__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__sprite_anchor_point__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_anchor_position__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__sprite_anchor_position__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_animation_has_ended__sprite", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_animation_has_ended__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_animation_name__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__sprite_animation_name__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_at__sprite__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_at__sprite__point_2d_ref(__sklib_ptr s, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_bring_layer_forward__sprite__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_bring_layer_forward__sprite__int(__sklib_ptr s, int visibleLayer);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_bring_layer_to_front__sprite__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_bring_layer_to_front__sprite__int(__sklib_ptr s, int visibleLayer);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_call_on_event__sprite__sprite_event_handler_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_call_on_event__sprite__sprite_event_handler_ptr(__sklib_ptr s, SpriteEventHandler handler);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_center_point__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__sprite_center_point__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_circle__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_circle __sklib__sprite_circle__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_collision_bitmap__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__sprite_collision_bitmap__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_collision_circle__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_circle __sklib__sprite_collision_circle__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_collision_kind__sprite", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_collision_kind__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_collision_rectangle__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__sprite_collision_rectangle__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_current_cell__sprite", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_current_cell__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_current_cell_rectangle__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__sprite_current_cell_rectangle__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_dx__sprite", CharSet=CharSet.Ansi)]
    private static extern double __sklib__sprite_dx__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_dy__sprite", CharSet=CharSet.Ansi)]
    private static extern double __sklib__sprite_dy__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_has_value__sprite__string", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_has_value__sprite__string(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_heading__sprite", CharSet=CharSet.Ansi)]
    private static extern float __sklib__sprite_heading__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_height__sprite", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_height__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_hide_layer__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_hide_layer__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_hide_layer__sprite__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_hide_layer__sprite__int(__sklib_ptr s, int id);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__sprite_layer__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer__sprite__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__sprite_layer__sprite__int(__sklib_ptr s, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_circle__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_circle __sklib__sprite_layer_circle__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_circle__sprite__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_circle __sklib__sprite_layer_circle__sprite__int(__sklib_ptr s, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_count__sprite", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_layer_count__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_height__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_layer_height__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_height__sprite__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_layer_height__sprite__int(__sklib_ptr s, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_index__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_layer_index__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_name__sprite__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__sprite_layer_name__sprite__int(__sklib_ptr s, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_offset__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__sprite_layer_offset__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_offset__sprite__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__sprite_layer_offset__sprite__int(__sklib_ptr s, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_rectangle__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__sprite_layer_rectangle__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_rectangle__sprite__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__sprite_layer_rectangle__sprite__int(__sklib_ptr s, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_width__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_layer_width__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_layer_width__sprite__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_layer_width__sprite__int(__sklib_ptr s, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_location_matrix__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_matrix_2d __sklib__sprite_location_matrix__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_mass__sprite", CharSet=CharSet.Ansi)]
    private static extern float __sklib__sprite_mass__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_move_from_anchor_point__sprite", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_move_from_anchor_point__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_move_to__sprite__point_2d_ref__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_move_to__sprite__point_2d_ref__float(__sklib_ptr s, __sklib_point_2d pt, float takingSeconds);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_name__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__sprite_name__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_named__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__sprite_named__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_offscreen__sprite", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_offscreen__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_on_screen_at__sprite__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_on_screen_at__sprite__point_2d_ref(__sklib_ptr s, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_on_screen_at__sprite__double__double", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_on_screen_at__sprite__double__double(__sklib_ptr s, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_position__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__sprite_position__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_replay_animation__sprite", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_replay_animation__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_replay_animation__sprite__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_replay_animation__sprite__bool(__sklib_ptr s, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_rotation__sprite", CharSet=CharSet.Ansi)]
    private static extern float __sklib__sprite_rotation__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_scale__sprite", CharSet=CharSet.Ansi)]
    private static extern float __sklib__sprite_scale__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_screen_rectangle__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_rectangle __sklib__sprite_screen_rectangle__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_send_layer_backward__sprite__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_send_layer_backward__sprite__int(__sklib_ptr s, int visibleLayer);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_send_layer_to_back__sprite__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_send_layer_to_back__sprite__int(__sklib_ptr s, int visibleLayer);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_anchor_point__sprite__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_anchor_point__sprite__point_2d_ref(__sklib_ptr s, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_collision_bitmap__sprite__bitmap", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_collision_bitmap__sprite__bitmap(__sklib_ptr s, __sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_collision_kind__sprite__collision_test_kind", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_collision_kind__sprite__collision_test_kind(__sklib_ptr s, int value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_dx__sprite__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_dx__sprite__double(__sklib_ptr s, double value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_dy__sprite__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_dy__sprite__double(__sklib_ptr s, double value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_heading__sprite__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_heading__sprite__float(__sklib_ptr s, float value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_layer_offset__sprite__string_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_layer_offset__sprite__string_ref__vector_2d_ref(__sklib_ptr s, __sklib_string name, __sklib_vector_2d value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_layer_offset__sprite__int__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_layer_offset__sprite__int__vector_2d_ref(__sklib_ptr s, int idx, __sklib_vector_2d value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_mass__sprite__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_mass__sprite__float(__sklib_ptr s, float value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_move_from_anchor_point__sprite__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_move_from_anchor_point__sprite__bool(__sklib_ptr s, int value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_position__sprite__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_position__sprite__point_2d_ref(__sklib_ptr s, __sklib_point_2d value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_rotation__sprite__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_rotation__sprite__float(__sklib_ptr s, float value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_scale__sprite__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_scale__sprite__float(__sklib_ptr s, float value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_speed__sprite__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_speed__sprite__double(__sklib_ptr s, double value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_value__sprite__string_ref__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_value__sprite__string_ref__float(__sklib_ptr s, __sklib_string name, float val);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_velocity__sprite__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_velocity__sprite__vector_2d_ref(__sklib_ptr s, __sklib_vector_2d value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_x__sprite__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_x__sprite__double(__sklib_ptr s, double value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_set_y__sprite__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_set_y__sprite__double(__sklib_ptr s, double value);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_show_layer__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_show_layer__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_show_layer__sprite__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_show_layer__sprite__int(__sklib_ptr s, int id);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_speed__sprite", CharSet=CharSet.Ansi)]
    private static extern double __sklib__sprite_speed__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_start_animation__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_start_animation__sprite__string_ref(__sklib_ptr s, __sklib_string named);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_start_animation__sprite__string_ref__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_start_animation__sprite__string_ref__bool(__sklib_ptr s, __sklib_string named, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_start_animation__sprite__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_start_animation__sprite__int(__sklib_ptr s, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_start_animation__sprite__int__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_start_animation__sprite__int__bool(__sklib_ptr s, int idx, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_stop_calling_on_event__sprite__sprite_event_handler_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_stop_calling_on_event__sprite__sprite_event_handler_ptr(__sklib_ptr s, SpriteEventHandler handler);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_toggle_layer_visible__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_toggle_layer_visible__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_toggle_layer_visible__sprite__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__sprite_toggle_layer_visible__sprite__int(__sklib_ptr s, int id);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_value__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern float __sklib__sprite_value__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_value_count__sprite", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_value_count__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_velocity__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__sprite_velocity__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_visible_index_of_layer__sprite__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_visible_index_of_layer__sprite__string_ref(__sklib_ptr s, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_visible_index_of_layer__sprite__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_visible_index_of_layer__sprite__int(__sklib_ptr s, int id);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_visible_layer__sprite__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_visible_layer__sprite__int(__sklib_ptr s, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_visible_layer_count__sprite", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_visible_layer_count__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_visible_layer_id__sprite__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_visible_layer_id__sprite__int(__sklib_ptr s, int idx);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_width__sprite", CharSet=CharSet.Ansi)]
    private static extern int __sklib__sprite_width__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_x__sprite", CharSet=CharSet.Ansi)]
    private static extern double __sklib__sprite_x__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__sprite_y__sprite", CharSet=CharSet.Ansi)]
    private static extern double __sklib__sprite_y__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__stop_calling_on_sprite_event__sprite_event_handler_ptr", CharSet=CharSet.Ansi)]
    private static extern void __sklib__stop_calling_on_sprite_event__sprite_event_handler_ptr(SpriteEventHandler handler);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_all_sprites", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_all_sprites();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_all_sprites__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_all_sprites__float(float pct);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_sprite__sprite", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_sprite__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_sprite__sprite__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_sprite__sprite__bool(__sklib_ptr s, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_sprite__sprite__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_sprite__sprite__float(__sklib_ptr s, float pct);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_sprite__sprite__float__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_sprite__sprite__float__bool(__sklib_ptr s, float pct, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_sprite_animation__sprite", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_sprite_animation__sprite(__sklib_ptr s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_sprite_animation__sprite__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_sprite_animation__sprite__bool(__sklib_ptr s, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_sprite_animation__sprite__float", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_sprite_animation__sprite__float(__sklib_ptr s, float pct);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__update_sprite_animation__sprite__float__bool", CharSet=CharSet.Ansi)]
    private static extern void __sklib__update_sprite_animation__sprite__float__bool(__sklib_ptr s, float pct, int withSound);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_from_center_sprite_to_point__sprite__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_from_center_sprite_to_point__sprite__point_2d_ref(__sklib_ptr s, __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_from_to__sprite__sprite", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_from_to__sprite__sprite(__sklib_ptr s1, __sklib_ptr s2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__read_char", CharSet=CharSet.Ansi)]
    private static extern char __sklib__read_char();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__read_line", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__read_line();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__terminal_has_input", CharSet=CharSet.Ansi)]
    private static extern int __sklib__terminal_has_input();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__write__char", CharSet=CharSet.Ansi)]
    private static extern void __sklib__write__char(char data);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__write__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__write__double(double data);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__write__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__write__int(int data);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__write__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__write__string(__sklib_string text);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__write_line__char", CharSet=CharSet.Ansi)]
    private static extern void __sklib__write_line__char(char data);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__write_line", CharSet=CharSet.Ansi)]
    private static extern void __sklib__write_line();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__write_line__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__write_line__double(double data);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__write_line__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__write_line__int(int data);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__write_line__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__write_line__string(__sklib_string line);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text__string_ref__color_ref__string_ref__int__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text__string_ref__color_ref__string_ref__int__double__double(__sklib_string text, __sklib_color clr, __sklib_string fnt, int fontSize, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text__string_ref__color_ref__string_ref__int__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text__string_ref__color_ref__string_ref__int__double__double__drawing_options_ref(__sklib_string text, __sklib_color clr, __sklib_string fnt, int fontSize, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text__string_ref__color_ref__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text__string_ref__color_ref__double__double(__sklib_string text, __sklib_color clr, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text__string_ref__color_ref__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text__string_ref__color_ref__double__double__drawing_options_ref(__sklib_string text, __sklib_color clr, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text__string_ref__color_ref__font__int__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text__string_ref__color_ref__font__int__double__double(__sklib_string text, __sklib_color clr, __sklib_ptr fnt, int fontSize, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text__string_ref__color_ref__font__int__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text__string_ref__color_ref__font__int__double__double__drawing_options_ref(__sklib_string text, __sklib_color clr, __sklib_ptr fnt, int fontSize, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__string_ref__int__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__string_ref__int__double__double(__sklib_ptr bmp, __sklib_string text, __sklib_color clr, __sklib_string fnt, int fontSize, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__string_ref__int__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__string_ref__int__double__double__drawing_options_ref(__sklib_ptr bmp, __sklib_string text, __sklib_color clr, __sklib_string fnt, int fontSize, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__double__double(__sklib_ptr bmp, __sklib_string text, __sklib_color clr, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__double__double__drawing_options_ref(__sklib_ptr bmp, __sklib_string text, __sklib_color clr, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__font__int__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__font__int__double__double(__sklib_ptr bmp, __sklib_string text, __sklib_color clr, __sklib_ptr fnt, int fontSize, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__font__int__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__font__int__double__double__drawing_options_ref(__sklib_ptr bmp, __sklib_string text, __sklib_color clr, __sklib_ptr fnt, int fontSize, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text_on_window__window__string_ref__color_ref__string_ref__int__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text_on_window__window__string_ref__color_ref__string_ref__int__double__double(__sklib_ptr wnd, __sklib_string text, __sklib_color clr, __sklib_string fnt, int fontSize, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text_on_window__window__string_ref__color_ref__string_ref__int__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text_on_window__window__string_ref__color_ref__string_ref__int__double__double__drawing_options_ref(__sklib_ptr wnd, __sklib_string text, __sklib_color clr, __sklib_string fnt, int fontSize, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text_on_window__window__string_ref__color_ref__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text_on_window__window__string_ref__color_ref__double__double(__sklib_ptr wnd, __sklib_string text, __sklib_color clr, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text_on_window__window__string_ref__color_ref__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text_on_window__window__string_ref__color_ref__double__double__drawing_options_ref(__sklib_ptr wnd, __sklib_string text, __sklib_color clr, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text_on_window__window__string_ref__color_ref__font__int__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text_on_window__window__string_ref__color_ref__font__int__double__double(__sklib_ptr wnd, __sklib_string text, __sklib_color clr, __sklib_ptr fnt, int fontSize, double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_text_on_window__window__string_ref__color_ref__font__int__double__double__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_text_on_window__window__string_ref__color_ref__font__int__double__double__drawing_options_ref(__sklib_ptr wnd, __sklib_string text, __sklib_color clr, __sklib_ptr fnt, int fontSize, double x, double y, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__font_has_size__string_ref__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__font_has_size__string_ref__int(__sklib_string name, int fontSize);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__font_has_size__font__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__font_has_size__font__int(__sklib_ptr fnt, int fontSize);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__font_load_size__string_ref__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__font_load_size__string_ref__int(__sklib_string name, int fontSize);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__font_load_size__font__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__font_load_size__font__int(__sklib_ptr fnt, int fontSize);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__font_named__string", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__font_named__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_all_fonts", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_all_fonts();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_font__font", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_font__font(__sklib_ptr fnt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__get_font_style__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__get_font_style__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__get_font_style__font", CharSet=CharSet.Ansi)]
    private static extern int __sklib__get_font_style__font(__sklib_ptr fnt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__get_system_font", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__get_system_font();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_font__font", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_font__font(__sklib_ptr fnt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_font__string", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_font__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__load_font__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__load_font__string_ref__string_ref(__sklib_string name, __sklib_string filename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_font_style__string_ref__font_style", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_font_style__string_ref__font_style(__sklib_string name, int style);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_font_style__font__font_style", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_font_style__font__font_style(__sklib_ptr fnt, int style);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__text_height__string_ref__string_ref__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__text_height__string_ref__string_ref__int(__sklib_string text, __sklib_string fnt, int fontSize);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__text_height__string_ref__font__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__text_height__string_ref__font__int(__sklib_string text, __sklib_ptr fnt, int fontSize);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__text_width__string_ref__string_ref__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__text_width__string_ref__string_ref__int(__sklib_string text, __sklib_string fnt, int fontSize);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__text_width__string_ref__font__int", CharSet=CharSet.Ansi)]
    private static extern int __sklib__text_width__string_ref__font__int(__sklib_string text, __sklib_ptr fnt, int fontSize);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_collected_text__color__font__int__drawing_options_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_collected_text__color__font__int__drawing_options_ref(__sklib_color clr, __sklib_ptr fnt, int fontSize, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__end_reading_text", CharSet=CharSet.Ansi)]
    private static extern void __sklib__end_reading_text();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__end_reading_text__window", CharSet=CharSet.Ansi)]
    private static extern void __sklib__end_reading_text__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__reading_text", CharSet=CharSet.Ansi)]
    private static extern int __sklib__reading_text();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__reading_text__window", CharSet=CharSet.Ansi)]
    private static extern int __sklib__reading_text__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_reading_text__rectangle", CharSet=CharSet.Ansi)]
    private static extern void __sklib__start_reading_text__rectangle(__sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_reading_text__rectangle__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__start_reading_text__rectangle__string(__sklib_rectangle rect, __sklib_string initialText);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_reading_text__window__rectangle", CharSet=CharSet.Ansi)]
    private static extern void __sklib__start_reading_text__window__rectangle(__sklib_ptr wind, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_reading_text__window__rectangle__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__start_reading_text__window__rectangle__string(__sklib_ptr wind, __sklib_rectangle rect, __sklib_string initialText);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__text_entry_cancelled", CharSet=CharSet.Ansi)]
    private static extern int __sklib__text_entry_cancelled();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__text_entry_cancelled__window", CharSet=CharSet.Ansi)]
    private static extern int __sklib__text_entry_cancelled__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__text_input", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__text_input();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__text_input__window", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__text_input__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__create_timer__string", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__create_timer__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_all_timers", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_all_timers();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_timer__timer", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_timer__timer(__sklib_ptr toFree);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_timer__string", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_timer__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__pause_timer__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__pause_timer__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__pause_timer__timer", CharSet=CharSet.Ansi)]
    private static extern void __sklib__pause_timer__timer(__sklib_ptr toPause);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__reset_timer__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__reset_timer__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__reset_timer__timer", CharSet=CharSet.Ansi)]
    private static extern void __sklib__reset_timer__timer(__sklib_ptr tmr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resume_timer__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__resume_timer__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resume_timer__timer", CharSet=CharSet.Ansi)]
    private static extern void __sklib__resume_timer__timer(__sklib_ptr toResume);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_timer__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__start_timer__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_timer__timer", CharSet=CharSet.Ansi)]
    private static extern void __sklib__start_timer__timer(__sklib_ptr toStart);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__stop_timer__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__stop_timer__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__stop_timer__timer", CharSet=CharSet.Ansi)]
    private static extern void __sklib__stop_timer__timer(__sklib_ptr toStop);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__timer_named__string", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__timer_named__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__timer_paused__string", CharSet=CharSet.Ansi)]
    private static extern int __sklib__timer_paused__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__timer_paused__timer", CharSet=CharSet.Ansi)]
    private static extern int __sklib__timer_paused__timer(__sklib_ptr toGet);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__timer_started__string", CharSet=CharSet.Ansi)]
    private static extern int __sklib__timer_started__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__timer_started__timer", CharSet=CharSet.Ansi)]
    private static extern int __sklib__timer_started__timer(__sklib_ptr toGet);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__timer_ticks__string", CharSet=CharSet.Ansi)]
    private static extern uint __sklib__timer_ticks__string(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__timer_ticks__timer", CharSet=CharSet.Ansi)]
    private static extern uint __sklib__timer_ticks__timer(__sklib_ptr toGet);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_triangle__color__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_triangle__color__triangle_ref(__sklib_color clr, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_triangle__color__triangle_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_triangle__color__triangle_ref__drawing_options(__sklib_color clr, __sklib_triangle tri, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_triangle__color__double__double__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_triangle__color__double__double__double__double__double__double(__sklib_color clr, double x1, double y1, double x2, double y2, double x3, double y3);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_triangle__color__double__double__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_triangle__color__double__double__double__double__double__double__drawing_options(__sklib_color clr, double x1, double y1, double x2, double y2, double x3, double y3, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_triangle_on_bitmap__bitmap__color__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_triangle_on_bitmap__bitmap__color__triangle_ref(__sklib_ptr destination, __sklib_color clr, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_triangle_on_bitmap__bitmap__color__triangle_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_triangle_on_bitmap__bitmap__color__triangle_ref__drawing_options(__sklib_ptr destination, __sklib_color clr, __sklib_triangle tri, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_triangle_on_bitmap__bitmap__color__double__double__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_triangle_on_bitmap__bitmap__color__double__double__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x1, double y1, double x2, double y2, double x3, double y3);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_triangle_on_bitmap__bitmap__color__double__double__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_triangle_on_bitmap__bitmap__color__double__double__double__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x1, double y1, double x2, double y2, double x3, double y3, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_triangle_on_window__window__color__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_triangle_on_window__window__color__triangle_ref(__sklib_ptr destination, __sklib_color clr, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_triangle_on_window__window__color__triangle_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_triangle_on_window__window__color__triangle_ref__drawing_options(__sklib_ptr destination, __sklib_color clr, __sklib_triangle tri, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_triangle_on_window__window__color__double__double__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_triangle_on_window__window__color__double__double__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x1, double y1, double x2, double y2, double x3, double y3);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__draw_triangle_on_window__window__color__double__double__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__draw_triangle_on_window__window__color__double__double__double__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x1, double y1, double x2, double y2, double x3, double y3, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_triangle__color__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_triangle__color__triangle_ref(__sklib_color clr, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_triangle__color__triangle_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_triangle__color__triangle_ref__drawing_options(__sklib_color clr, __sklib_triangle tri, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_triangle__color__double__double__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_triangle__color__double__double__double__double__double__double(__sklib_color clr, double x1, double y1, double x2, double y2, double x3, double y3);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_triangle__color__double__double__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_triangle__color__double__double__double__double__double__double__drawing_options(__sklib_color clr, double x1, double y1, double x2, double y2, double x3, double y3, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_triangle_on_bitmap__bitmap__color__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_triangle_on_bitmap__bitmap__color__triangle_ref(__sklib_ptr destination, __sklib_color clr, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_triangle_on_bitmap__bitmap__color__triangle_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_triangle_on_bitmap__bitmap__color__triangle_ref__drawing_options(__sklib_ptr destination, __sklib_color clr, __sklib_triangle tri, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_triangle_on_bitmap__bitmap__color__double__double__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_triangle_on_bitmap__bitmap__color__double__double__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x1, double y1, double x2, double y2, double x3, double y3);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_triangle_on_bitmap__bitmap__color__double__double__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_triangle_on_bitmap__bitmap__color__double__double__double__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x1, double y1, double x2, double y2, double x3, double y3, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_triangle_on_window__window__color__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_triangle_on_window__window__color__triangle_ref(__sklib_ptr destination, __sklib_color clr, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_triangle_on_window__window__color__triangle_ref__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_triangle_on_window__window__color__triangle_ref__drawing_options(__sklib_ptr destination, __sklib_color clr, __sklib_triangle tri, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_triangle_on_window__window__color__double__double__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_triangle_on_window__window__color__double__double__double__double__double__double(__sklib_ptr destination, __sklib_color clr, double x1, double y1, double x2, double y2, double x3, double y3);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__fill_triangle_on_window__window__color__double__double__double__double__double__double__drawing_options", CharSet=CharSet.Ansi)]
    private static extern void __sklib__fill_triangle_on_window__window__color__double__double__double__double__double__double__drawing_options(__sklib_ptr destination, __sklib_color clr, double x1, double y1, double x2, double y2, double x3, double y3, __sklib_drawing_options opts);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__triangle_barycenter__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__triangle_barycenter__triangle_ref(__sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__triangle_from__point_2d_ref__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_triangle __sklib__triangle_from__point_2d_ref__point_2d_ref__point_2d_ref(__sklib_point_2d p1, __sklib_point_2d p2, __sklib_point_2d p3);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__triangle_from__double__double__double__double__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_triangle __sklib__triangle_from__double__double__double__double__double__double(double x1, double y1, double x2, double y2, double x3, double y3);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__triangle_quad_intersect__triangle_ref__quad_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__triangle_quad_intersect__triangle_ref__quad_ref(__sklib_triangle tri, __sklib_quad q);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__triangle_ray_intersection__point_2d_ref__vector_2d_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__triangle_ray_intersection__point_2d_ref__vector_2d_ref__triangle_ref(__sklib_point_2d origin, __sklib_vector_2d heading, __sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__triangle_ray_intersection__point_2d_ref__vector_2d_ref__triangle_ref__point_2d_ref__double_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__triangle_ray_intersection__point_2d_ref__vector_2d_ref__triangle_ref__point_2d_ref__double_ref(__sklib_point_2d origin, __sklib_vector_2d heading, __sklib_triangle tri, ref __sklib_point_2d hitPoint, ref double hitDistance);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__triangle_rectangle_intersect__triangle_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__triangle_rectangle_intersect__triangle_ref__rectangle_ref(__sklib_triangle tri, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__triangle_to_string__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__triangle_to_string__triangle_ref(__sklib_triangle tri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__triangles_intersect__triangle_ref__triangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__triangles_intersect__triangle_ref__triangle_ref(__sklib_triangle t1, __sklib_triangle t2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_ticks", CharSet=CharSet.Ansi)]
    private static extern uint __sklib__current_ticks();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__delay__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__delay__int(int milliseconds);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__display_dialog__string_ref__string_ref__font__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__display_dialog__string_ref__string_ref__font__int(__sklib_string title, __sklib_string msg, __sklib_ptr outputFont, int fontSize);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__file_as_string__string__resource_kind", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__file_as_string__string__resource_kind(__sklib_string filename, int kind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__angle_between__vector_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern double __sklib__angle_between__vector_2d_ref__vector_2d_ref(__sklib_vector_2d v1, __sklib_vector_2d v2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__dot_product__vector_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern double __sklib__dot_product__vector_2d_ref__vector_2d_ref(__sklib_vector_2d v1, __sklib_vector_2d v2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_zero_vector__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_zero_vector__vector_2d_ref(__sklib_vector_2d v);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__ray_intersection_point__point_2d_ref__vector_2d_ref__line_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__ray_intersection_point__point_2d_ref__vector_2d_ref__line_ref__point_2d_ref(__sklib_point_2d fromPt, __sklib_vector_2d heading, __sklib_line l, ref __sklib_point_2d pt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__unit_vector__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__unit_vector__vector_2d_ref(__sklib_vector_2d v);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_add__vector_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_add__vector_2d_ref__vector_2d_ref(__sklib_vector_2d v1, __sklib_vector_2d v2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_angle__vector_2d", CharSet=CharSet.Ansi)]
    private static extern double __sklib__vector_angle__vector_2d(__sklib_vector_2d v);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_from_angle__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_from_angle__double__double(double angle, double magnitude);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_from_line__line_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_from_line__line_ref(__sklib_line l);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_from_point_to_rect__point_2d_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_from_point_to_rect__point_2d_ref__rectangle_ref(__sklib_point_2d pt, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_in_rect__vector_2d_ref__rectangle_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__vector_in_rect__vector_2d_ref__rectangle_ref(__sklib_vector_2d v, __sklib_rectangle rect);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_invert__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_invert__vector_2d_ref(__sklib_vector_2d v);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_limit__vector_2d_ref__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_limit__vector_2d_ref__double(__sklib_vector_2d v, double limit);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_magnitude__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern double __sklib__vector_magnitude__vector_2d_ref(__sklib_vector_2d v);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_magnitude_squared__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern double __sklib__vector_magnitude_squared__vector_2d_ref(__sklib_vector_2d v);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_multiply__vector_2d_ref__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_multiply__vector_2d_ref__double(__sklib_vector_2d v1, double s);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_normal__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_normal__vector_2d_ref(__sklib_vector_2d v);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_out_of_circle_from_circle__circle_ref__circle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_out_of_circle_from_circle__circle_ref__circle_ref__vector_2d_ref(__sklib_circle src, __sklib_circle bounds, __sklib_vector_2d velocity);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_out_of_circle_from_point__point_2d_ref__circle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_out_of_circle_from_point__point_2d_ref__circle_ref__vector_2d_ref(__sklib_point_2d pt, __sklib_circle c, __sklib_vector_2d velocity);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_out_of_rect_from_circle__circle_ref__rectangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_out_of_rect_from_circle__circle_ref__rectangle_ref__vector_2d_ref(__sklib_circle c, __sklib_rectangle rect, __sklib_vector_2d velocity);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_out_of_rect_from_point__point_2d_ref__rectangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_out_of_rect_from_point__point_2d_ref__rectangle_ref__vector_2d_ref(__sklib_point_2d pt, __sklib_rectangle rect, __sklib_vector_2d velocity);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_out_of_rect_from_rect__rectangle_ref__rectangle_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_out_of_rect_from_rect__rectangle_ref__rectangle_ref__vector_2d_ref(__sklib_rectangle src, __sklib_rectangle bounds, __sklib_vector_2d velocity);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_point_to_point__point_2d_ref__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_point_to_point__point_2d_ref__point_2d_ref(__sklib_point_2d start, __sklib_point_2d endPt);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_subtract__vector_2d_ref__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_subtract__vector_2d_ref__vector_2d_ref(__sklib_vector_2d v1, __sklib_vector_2d v2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_to__point_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_to__point_2d_ref(__sklib_point_2d p1);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_to__double__double", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_2d __sklib__vector_to__double__double(double x, double y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vector_to_string__vector_2d_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__vector_to_string__vector_2d_ref(__sklib_vector_2d v);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vectors_equal__vector_2d_ref__vector_2d", CharSet=CharSet.Ansi)]
    private static extern int __sklib__vectors_equal__vector_2d_ref__vector_2d(__sklib_vector_2d v1, __sklib_vector_2d v2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__vectors_not_equal__vector_2d_ref__vector_2d", CharSet=CharSet.Ansi)]
    private static extern int __sklib__vectors_not_equal__vector_2d_ref__vector_2d(__sklib_vector_2d v1, __sklib_vector_2d v2);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__download_bitmap__string_ref__string_ref__unsigned_short", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__download_bitmap__string_ref__string_ref__unsigned_short(__sklib_string name, __sklib_string url, ushort port);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__download_font__string_ref__string_ref__unsigned_short", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__download_font__string_ref__string_ref__unsigned_short(__sklib_string name, __sklib_string url, ushort port);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__download_music__string_ref__string_ref__unsigned_short", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__download_music__string_ref__string_ref__unsigned_short(__sklib_string name, __sklib_string url, ushort port);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__download_sound_effect__string_ref__string_ref__unsigned_short", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__download_sound_effect__string_ref__string_ref__unsigned_short(__sklib_string name, __sklib_string url, ushort port);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__free_response__http_response", CharSet=CharSet.Ansi)]
    private static extern void __sklib__free_response__http_response(__sklib_ptr response);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__http_get__string_ref__unsigned_short", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__http_get__string_ref__unsigned_short(__sklib_string url, ushort port);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__http_post__string_ref__unsigned_short__string_ref__vector_string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__http_post__string_ref__unsigned_short__string_ref__vector_string_ref(__sklib_string url, ushort port, __sklib_string body, __sklib_vector_string headers);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__http_post__string_ref__unsigned_short__string", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__http_post__string_ref__unsigned_short__string(__sklib_string url, ushort port, __sklib_string body);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__http_response_to_string__http_response", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__http_response_to_string__http_response(__sklib_ptr response);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__save_response_to_file__http_response__string", CharSet=CharSet.Ansi)]
    private static extern void __sklib__save_response_to_file__http_response__string(__sklib_ptr response, __sklib_string path);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_incoming_requests__web_server", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_incoming_requests__web_server(__sklib_ptr server);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_delete_request_for__http_request__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_delete_request_for__http_request__string_ref(__sklib_ptr request, __sklib_string path);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_get_request_for__http_request__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_get_request_for__http_request__string_ref(__sklib_ptr request, __sklib_string path);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_options_request_for__http_request__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_options_request_for__http_request__string_ref(__sklib_ptr request, __sklib_string path);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_post_request_for__http_request__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_post_request_for__http_request__string_ref(__sklib_ptr request, __sklib_string path);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_put_request_for__http_request__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_put_request_for__http_request__string_ref(__sklib_ptr request, __sklib_string path);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_request_for__http_request__http_method__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_request_for__http_request__http_method__string_ref(__sklib_ptr request, int method, __sklib_string path);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_trace_request_for__http_request__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_trace_request_for__http_request__string_ref(__sklib_ptr request, __sklib_string path);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__next_web_request__web_server", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__next_web_request__web_server(__sklib_ptr server);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__request_body__http_request", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__request_body__http_request(__sklib_ptr r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__request_has_query_parameter__http_request__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__request_has_query_parameter__http_request__string_ref(__sklib_ptr r, __sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__request_headers__http_request", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_string __sklib__request_headers__http_request(__sklib_ptr r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__request_method__http_request", CharSet=CharSet.Ansi)]
    private static extern int __sklib__request_method__http_request(__sklib_ptr r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__request_query_parameter__http_request__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__request_query_parameter__http_request__string_ref__string_ref(__sklib_ptr r, __sklib_string name, __sklib_string defaultValue);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__request_query_string__http_request", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__request_query_string__http_request(__sklib_ptr r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__request_uri__http_request", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__request_uri__http_request(__sklib_ptr r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__request_uri_stubs__http_request", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_string __sklib__request_uri_stubs__http_request(__sklib_ptr r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_css_file_response__http_request__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__send_css_file_response__http_request__string_ref(__sklib_ptr r, __sklib_string filename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_file_response__http_request__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__send_file_response__http_request__string_ref__string_ref(__sklib_ptr r, __sklib_string filename, __sklib_string contentType);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_html_file_response__http_request__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__send_html_file_response__http_request__string_ref(__sklib_ptr r, __sklib_string filename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_javascript_file_response__http_request__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__send_javascript_file_response__http_request__string_ref(__sklib_ptr r, __sklib_string filename);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_response__http_request", CharSet=CharSet.Ansi)]
    private static extern void __sklib__send_response__http_request(__sklib_ptr r);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_response__http_request__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__send_response__http_request__string_ref(__sklib_ptr r, __sklib_string message);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_response__http_request__http_status_code", CharSet=CharSet.Ansi)]
    private static extern void __sklib__send_response__http_request__http_status_code(__sklib_ptr r, int code);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_response__http_request__http_status_code__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__send_response__http_request__http_status_code__string_ref(__sklib_ptr r, int code, __sklib_string message);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_response__http_request__http_status_code__string_ref__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__send_response__http_request__http_status_code__string_ref__string_ref(__sklib_ptr r, int code, __sklib_string message, __sklib_string contentType);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_response__http_request__http_status_code__string_ref__string_ref__vector_string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__send_response__http_request__http_status_code__string_ref__string_ref__vector_string_ref(__sklib_ptr r, int code, __sklib_string message, __sklib_string contentType, __sklib_vector_string headers);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__send_response__http_request__json", CharSet=CharSet.Ansi)]
    private static extern void __sklib__send_response__http_request__json(__sklib_ptr r, __sklib_ptr j);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__split_uri_stubs__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_vector_string __sklib__split_uri_stubs__string_ref(__sklib_string uri);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_web_server", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__start_web_server();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__start_web_server__unsigned_short", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__start_web_server__unsigned_short(ushort port);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__stop_web_server__web_server", CharSet=CharSet.Ansi)]
    private static extern void __sklib__stop_web_server__web_server(__sklib_ptr server);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__clear_window__window__color", CharSet=CharSet.Ansi)]
    private static extern void __sklib__clear_window__window__color(__sklib_ptr wind, __sklib_color clr);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_all_windows", CharSet=CharSet.Ansi)]
    private static extern void __sklib__close_all_windows();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_current_window", CharSet=CharSet.Ansi)]
    private static extern void __sklib__close_current_window();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_window__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__close_window__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__close_window__window", CharSet=CharSet.Ansi)]
    private static extern void __sklib__close_window__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_window", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__current_window();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_window_has_border", CharSet=CharSet.Ansi)]
    private static extern int __sklib__current_window_has_border();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_window_height", CharSet=CharSet.Ansi)]
    private static extern int __sklib__current_window_height();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_window_is_fullscreen", CharSet=CharSet.Ansi)]
    private static extern int __sklib__current_window_is_fullscreen();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_window_position", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__current_window_position();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_window_toggle_border", CharSet=CharSet.Ansi)]
    private static extern void __sklib__current_window_toggle_border();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_window_toggle_fullscreen", CharSet=CharSet.Ansi)]
    private static extern void __sklib__current_window_toggle_fullscreen();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_window_width", CharSet=CharSet.Ansi)]
    private static extern int __sklib__current_window_width();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_window_x", CharSet=CharSet.Ansi)]
    private static extern int __sklib__current_window_x();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__current_window_y", CharSet=CharSet.Ansi)]
    private static extern int __sklib__current_window_y();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__has_window__string", CharSet=CharSet.Ansi)]
    private static extern int __sklib__has_window__string(__sklib_string caption);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__is_current_window__window", CharSet=CharSet.Ansi)]
    private static extern int __sklib__is_current_window__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_current_window_to__int__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_current_window_to__int__int(int x, int y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_window_to__string_ref__int__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_window_to__string_ref__int__int(__sklib_string name, int x, int y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__move_window_to__window__int__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__move_window_to__window__int__int(__sklib_ptr wind, int x, int y);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__open_window__string__int__int", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__open_window__string__int__int(__sklib_string caption, int width, int height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__refresh_window__window", CharSet=CharSet.Ansi)]
    private static extern void __sklib__refresh_window__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__refresh_window__window__unsigned_int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__refresh_window__window__unsigned_int(__sklib_ptr wind, uint targetFps);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resize_current_window__int__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__resize_current_window__int__int(int width, int height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__resize_window__window__int__int", CharSet=CharSet.Ansi)]
    private static extern void __sklib__resize_window__window__int__int(__sklib_ptr wnd, int width, int height);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_current_window__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_current_window__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__set_current_window__window", CharSet=CharSet.Ansi)]
    private static extern void __sklib__set_current_window__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_caption__window", CharSet=CharSet.Ansi)]
    private static extern __sklib_string __sklib__window_caption__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_close_requested__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_close_requested__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_close_requested__window", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_close_requested__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_has_border__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_has_border__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_has_border__window", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_has_border__window(__sklib_ptr wnd);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_has_focus__window", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_has_focus__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_height__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_height__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_height__window", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_height__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_is_fullscreen__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_is_fullscreen__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_is_fullscreen__window", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_is_fullscreen__window(__sklib_ptr wnd);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_named__string", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__window_named__string(__sklib_string caption);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_position__string_ref", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__window_position__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_position__window", CharSet=CharSet.Ansi)]
    private static extern __sklib_point_2d __sklib__window_position__window(__sklib_ptr wnd);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_set_icon__window__bitmap", CharSet=CharSet.Ansi)]
    private static extern void __sklib__window_set_icon__window__bitmap(__sklib_ptr wind, __sklib_ptr bmp);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_toggle_border__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__window_toggle_border__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_toggle_border__window", CharSet=CharSet.Ansi)]
    private static extern void __sklib__window_toggle_border__window(__sklib_ptr wnd);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_toggle_fullscreen__string_ref", CharSet=CharSet.Ansi)]
    private static extern void __sklib__window_toggle_fullscreen__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_toggle_fullscreen__window", CharSet=CharSet.Ansi)]
    private static extern void __sklib__window_toggle_fullscreen__window(__sklib_ptr wnd);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_width__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_width__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_width__window", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_width__window(__sklib_ptr wind);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_with_focus", CharSet=CharSet.Ansi)]
    private static extern __sklib_ptr __sklib__window_with_focus();

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_x__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_x__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_x__window", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_x__window(__sklib_ptr wnd);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_y__string_ref", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_y__string_ref(__sklib_string name);

    [DllImport("SplashKit", CallingConvention=CallingConvention.Cdecl, EntryPoint="__sklib__window_y__window", CharSet=CharSet.Ansi)]
    private static extern int __sklib__window_y__window(__sklib_ptr wnd);

    /// <summary>
    /// Returns the number of `animation`s within an `animation_script`.
    /// </summary>
    /// <param name="script"> The `animation_script` to count the animations in.</param>
    /// <returns>Returns an `int` equal to the total number of animations in the script.</returns>
    public static int AnimationCount(AnimationScript script)
    {
      __sklib_ptr __skparam__script;
      int __skreturn;
      __skparam__script = __skadapter__to_sklib_animation_script(script);
      __skreturn = __sklib__animation_count__animation_script(__skparam__script);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the current cell (the part of the image or sprite) of this animation. This can be used to animate an image or sprite.
    /// </summary>
    /// <param name="anim"> The `animation` to return the cell of.</param>
    /// <returns>Returns the current cell of the animation passed to the method.</returns>
    public static int AnimationCurrentCell(Animation anim)
    {
      __sklib_ptr __skparam__anim;
      int __skreturn;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skreturn = __sklib__animation_current_cell__animation(__skparam__anim);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the `vector_2d` assigned to the current frame in the animation.
    /// </summary>
    /// <param name="anim"> The animation to check the vector of.</param>
    /// <returns>Returns the `vector_2d` assigned to the current frame in the animation.</returns>
    public static Vector2D AnimationCurrentVector(Animation anim)
    {
      __sklib_ptr __skparam__anim;
      __sklib_vector_2d __skreturn;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skreturn = __sklib__animation_current_vector__animation(__skparam__anim);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Checks if an `animation` has ended.
    /// </summary>
    /// <param name="anim"> The animation to check.</param>
    /// <returns>Returns a `bool` denoting whether the `animation` has ended.</returns>
    public static bool AnimationEnded(Animation anim)
    {
      __sklib_ptr __skparam__anim;
      int __skreturn;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skreturn = __sklib__animation_ended__animation(__skparam__anim);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true if the `animation` entered a new frame on its last update. This can be used to trigger actions on frames within an animation.
    /// </summary>
    /// <param name="anim"> The animation to check.</param>
    /// <returns>Returns a `bool` denoting whether the `animation` has ended.</returns>
    public static bool AnimationEnteredFrame(Animation anim)
    {
      __sklib_ptr __skparam__anim;
      int __skreturn;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skreturn = __sklib__animation_entered_frame__animation(__skparam__anim);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the amount of time spent in the current frame. When this exceeds the frames duration the animation moves to the next frame.
    /// </summary>
    /// <param name="anim"> The animation to check.</param>
    /// <returns>Returns the amount of time spent in the current frame as a `float`.</returns>
    public static float AnimationFrameTime(Animation anim)
    {
      __sklib_ptr __skparam__anim;
      float __skreturn;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skreturn = __sklib__animation_frame_time__animation(__skparam__anim);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Searches an `animation_script` for an `animation` and returns its index.
    /// </summary>
    /// <param name="script"> The `animation_script` to look for the `animation` in.</param>
    /// <param name="name"> The name of the `animation` to look for.</param>
    /// <returns>Returns the index of the `animation` in the `animation_script`</returns>
    public static int AnimationIndex(AnimationScript script, string name)
    {
      __sklib_ptr __skparam__script;
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__script = __skadapter__to_sklib_animation_script(script);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__animation_index__animation_script__string_ref(__skparam__script, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Searches an `animation_script` for an animation and returns its name.
    /// </summary>
    /// <param name="temp"> The `animation` to search for.</param>
    /// <returns>Returns the name of the `animation` in the `animation_script`.</returns>
    public static string AnimationName(Animation temp)
    {
      __sklib_ptr __skparam__temp;
      __sklib_string __skreturn;
      __skparam__temp = __skadapter__to_sklib_animation(temp);
      __skreturn = __sklib__animation_name__animation(__skparam__temp);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Retuns the name of an `animation_script`.
    /// </summary>
    /// <param name="script"> The `animation_script` to return the name of.</param>
    /// <returns>Returns a `string` that is the name of the animation script passed to the method.</returns>
    public static string AnimationScriptName(AnimationScript script)
    {
      __sklib_ptr __skparam__script;
      __sklib_string __skreturn;
      __skparam__script = __skadapter__to_sklib_animation_script(script);
      __skreturn = __sklib__animation_script_name__animation_script(__skparam__script);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Loads and returns a `animation_script`. The supplied filename is used to locate the `animation_script` to load. The supplied name indicates the name to use to refer to this in SplashKit. The `animation_script` can then be retrieved by passing this name to the animation_script_named method.
    /// </summary>
    /// <param name="name"> Indicates the name used to locate the animation_script to load</param>
    /// <returns>Returns the newly loaded `animation_script`.</returns>
    public static AnimationScript AnimationScriptNamed(string name)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__animation_script_named__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_animation_script(__skreturn);
    }
    /// <summary>
    /// Setup an `animation` to follow the script from an indicated name. This will switch the animation to use the supplied script. It locates the name of the animation with the animation script and sets the `anim` to start at that point in the script.
    /// </summary>
    /// <param name="anim"> The `animation` to be assigned.</param>
    /// <param name="script"> The `animation_script` to assign the `animation` to.</param>
    /// <param name="name"> The name of the `animation` to be assigned.</param>
    public static void AssignAnimation(Animation anim, AnimationScript script, string name)
    {
      __sklib_ptr __skparam__anim;
      __sklib_ptr __skparam__script;
      __sklib_string __skparam__name;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__script = __skadapter__to_sklib_animation_script(script);
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__assign_animation__animation__animation_script__string_ref(__skparam__anim, __skparam__script, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Assigns an `animation` to an `animation_script`. This may play a sound effect if the animation is set to play a sound effect on its first frame.
    /// </summary>
    /// <param name="anim"> The `animation` to be assigned.</param>
    /// <param name="script"> The `animation_script` to assign the `animation` to.</param>
    /// <param name="name"> The name of the `animation` to be assigned.</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public static void AssignAnimation(Animation anim, AnimationScript script, string name, bool withSound)
    {
      __sklib_ptr __skparam__anim;
      __sklib_ptr __skparam__script;
      __sklib_string __skparam__name;
      int __skparam__with_sound;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__script = __skadapter__to_sklib_animation_script(script);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__assign_animation__animation__animation_script__string_ref__bool(__skparam__anim, __skparam__script, __skparam__name, __skparam__with_sound);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Assigns an `animation` to an `animation_script`.
    /// </summary>
    /// <param name="anim"> The `animation` to be assigned.</param>
    /// <param name="script"> The `animation_script` to assign the `animation` to.</param>
    /// <param name="idx"> The index of the `animation` to create.</param>
    public static void AssignAnimation(Animation anim, AnimationScript script, int idx)
    {
      __sklib_ptr __skparam__anim;
      __sklib_ptr __skparam__script;
      int __skparam__idx;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__script = __skadapter__to_sklib_animation_script(script);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __sklib__assign_animation__animation__animation_script__int(__skparam__anim, __skparam__script, __skparam__idx);
    }
    /// <summary>
    /// Assigns an `animation` to an `animation_script`. This may play a sound effect if the animation is set to play a sound effect on its first frame.
    /// </summary>
    /// <param name="anim"> The `animation` to be assigned.</param>
    /// <param name="script"> The `animation_script` to assign the `animation` to.</param>
    /// <param name="idx"> The index of the `animation` to create.</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public static void AssignAnimation(Animation anim, AnimationScript script, int idx, bool withSound)
    {
      __sklib_ptr __skparam__anim;
      __sklib_ptr __skparam__script;
      int __skparam__idx;
      int __skparam__with_sound;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__script = __skadapter__to_sklib_animation_script(script);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__assign_animation__animation__animation_script__int__bool(__skparam__anim, __skparam__script, __skparam__idx, __skparam__with_sound);
    }
    /// <summary>
    /// Assigns an `animation` to an `animation_script`.
    /// </summary>
    /// <param name="anim"> The `animation` to be assigned.</param>
    /// <param name="scriptName"> The name of the `animation_script` to assign the `animation` to.</param>
    /// <param name="name"> The name of the `animation` to be assigned.</param>
    public static void AssignAnimation(Animation anim, string scriptName, string name)
    {
      __sklib_ptr __skparam__anim;
      __sklib_string __skparam__script_name;
      __sklib_string __skparam__name;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__script_name = __skadapter__to_sklib_string(scriptName);
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__assign_animation__animation__string_ref__string_ref(__skparam__anim, __skparam__script_name, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__script_name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Assigns an `animation` to an `animation_script`. This may play a sound effect if the animation is set to play a sound effect on its first frame.
    /// </summary>
    /// <param name="anim"> The `animation` to be assigned.</param>
    /// <param name="scriptName"> The name of the `animation_script` to assign the `animation` to.</param>
    /// <param name="name"> The name of the `animation` to be assigned</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public static void AssignAnimation(Animation anim, string scriptName, string name, bool withSound)
    {
      __sklib_ptr __skparam__anim;
      __sklib_string __skparam__script_name;
      __sklib_string __skparam__name;
      int __skparam__with_sound;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__script_name = __skadapter__to_sklib_string(scriptName);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__assign_animation__animation__string_ref__string_ref__bool(__skparam__anim, __skparam__script_name, __skparam__name, __skparam__with_sound);
    __skadapter__free__sklib_string(ref __skparam__script_name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Setup an `animation` to follow the script from an indicated index. This uses the index from the current animation script and sets the supplied animation to start at that point in the script.
    /// </summary>
    /// <param name="anim"> The `animation` to be assigned.</param>
    /// <param name="idx"> The index of the animation to use from its current script.</param>
    public static void AssignAnimation(Animation anim, int idx)
    {
      __sklib_ptr __skparam__anim;
      int __skparam__idx;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __sklib__assign_animation__animation__int(__skparam__anim, __skparam__idx);
    }
    /// <summary>
    /// Setup an `animation` to follow the script from an indicated index. This uses the index from the current animation script and sets the supplied animation to start at that point in the script.
    /// </summary>
    /// <param name="anim"> The `animation` to be assigned.</param>
    /// <param name="idx"> The index of the animation to use from its current script.</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public static void AssignAnimation(Animation anim, int idx, bool withSound)
    {
      __sklib_ptr __skparam__anim;
      int __skparam__idx;
      int __skparam__with_sound;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__assign_animation__animation__int__bool(__skparam__anim, __skparam__idx, __skparam__with_sound);
    }
    /// <summary>
    /// Setup an `animation` to follow the script from an indicated name. This locates the name of the animation from the current animation script and sets the supplied animation to start at that point in the script.
    /// </summary>
    /// <param name="anim"> The `animation` to be assigned.</param>
    /// <param name="name"> The name of the animation to use from its current script.</param>
    public static void AssignAnimation(Animation anim, string name)
    {
      __sklib_ptr __skparam__anim;
      __sklib_string __skparam__name;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__assign_animation__animation__string(__skparam__anim, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Setup an `animation` to follow the script from an indicated name. This locates the name of the animation from the current animation script and sets the supplied animation to start at that point in the script.
    /// </summary>
    /// <param name="anim"> The `animation` to be assigned.</param>
    /// <param name="name"> The name of the animation to use from its current script.</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public static void AssignAnimation(Animation anim, string name, bool withSound)
    {
      __sklib_ptr __skparam__anim;
      __sklib_string __skparam__name;
      int __skparam__with_sound;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__assign_animation__animation__string__bool(__skparam__anim, __skparam__name, __skparam__with_sound);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Creates an animation from an `animation_script`. This may play a sound effect if the animation is set to play a sound effect on its first frame.
    /// </summary>
    /// <param name="script"> The `animation_script` to create the `animation` from.</param>
    /// <param name="idx"> The index of the `animation` to create.</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    /// <returns>Returns the newly created `animation_script`.</returns>
    public static Animation CreateAnimation(AnimationScript script, int idx, bool withSound)
    {
      __sklib_ptr __skparam__script;
      int __skparam__idx;
      int __skparam__with_sound;
      __sklib_ptr __skreturn;
      __skparam__script = __skadapter__to_sklib_animation_script(script);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __skreturn = __sklib__create_animation__animation_script__int__bool(__skparam__script, __skparam__idx, __skparam__with_sound);
      return __skadapter__to_animation(__skreturn);
    }
    /// <summary>
    /// Creates an animation from an `animation_script`.
    /// </summary>
    /// <param name="script"> The `animation_script` to create the `animation` from</param>
    /// <param name="name"> The name for the new `animation`</param>
    /// <returns>Returns the newly created `animation`</returns>
    public static Animation CreateAnimation(AnimationScript script, string name)
    {
      __sklib_ptr __skparam__script;
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__script = __skadapter__to_sklib_animation_script(script);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__create_animation__animation_script__string_ref(__skparam__script, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_animation(__skreturn);
    }
    /// <summary>
    /// Creates an animation from a `animation_script`. This may play a sound effect if the animation is set to play a sound effect on its first frame.
    /// </summary>
    /// <param name="script"> The `animation_script` to create the `animation` from</param>
    /// <param name="name"> The name for the new `animation`</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    /// <returns>Returns the newly created `animation`.</returns>
    public static Animation CreateAnimation(AnimationScript script, string name, bool withSound)
    {
      __sklib_ptr __skparam__script;
      __sklib_string __skparam__name;
      int __skparam__with_sound;
      __sklib_ptr __skreturn;
      __skparam__script = __skadapter__to_sklib_animation_script(script);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __skreturn = __sklib__create_animation__animation_script__string_ref__bool(__skparam__script, __skparam__name, __skparam__with_sound);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_animation(__skreturn);
    }
    /// <summary>
    /// Creates an animation from an `animation_script`'s name. This may play a sound effect if the animation is set to play a sound effect on its first frame.
    /// </summary>
    /// <param name="scriptName"> The name of the `animation_script` to create the `animation` from</param>
    /// <param name="name"> The name for the new `animation`</param>
    /// <returns>Returns the newly created `animation`</returns>
    public static Animation CreateAnimation(string scriptName, string name)
    {
      __sklib_string __skparam__script_name;
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__script_name = __skadapter__to_sklib_string(scriptName);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__create_animation__string_ref__string_ref(__skparam__script_name, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__script_name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_animation(__skreturn);
    }
    /// <summary>
    /// Creates an animation from an `animation_script`'s name. This may play a sound effect if the animation is set to play a sound effect on its first frame.
    /// </summary>
    /// <param name="scriptName"> The name of the `animation_script` to create the `animation` from</param>
    /// <param name="name"> The name for the new `animation`</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    /// <returns>Returns the newly created `animation`</returns>
    public static Animation CreateAnimation(string scriptName, string name, bool withSound)
    {
      __sklib_string __skparam__script_name;
      __sklib_string __skparam__name;
      int __skparam__with_sound;
      __sklib_ptr __skreturn;
      __skparam__script_name = __skadapter__to_sklib_string(scriptName);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __skreturn = __sklib__create_animation__string_ref__string_ref__bool(__skparam__script_name, __skparam__name, __skparam__with_sound);
    __skadapter__free__sklib_string(ref __skparam__script_name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_animation(__skreturn);
    }
    /// <summary>
    /// Frees all loaded `animation_script`s.
    /// </summary>
    public static void FreeAllAnimationScripts()
    {
      __sklib__free_all_animation_scripts();
    }
    /// <summary>
    /// Disposes of the resources used in the animation.
    /// </summary>
    /// <param name="ani"> The `animation` to be disposed of.</param>
    public static void FreeAnimation(Animation ani)
    {
      __sklib_ptr __skparam__ani;
      __skparam__ani = __skadapter__to_sklib_animation(ani);
      __sklib__free_animation__animation(__skparam__ani);
    }
    /// <summary>
    /// Frees loaded animation frames data. Use this when you will no longer be using the animation for any purpose, including within sprite.
    /// </summary>
    /// <param name="scriptToFree"> The `animation_script` to be freed.</param>
    public static void FreeAnimationScript(AnimationScript scriptToFree)
    {
      __sklib_ptr __skparam__script_to_free;
      __skparam__script_to_free = __skadapter__to_sklib_animation_script(scriptToFree);
      __sklib__free_animation_script__animation_script(__skparam__script_to_free);
    }
    /// <summary>
    /// Frees loaded `animation_script` data. Use this when you will no longer be using the animation for any purpose, including within sprite.
    /// </summary>
    /// <param name="name"> The name of the `animation_script` to be freed.</param>
    public static void FreeAnimationScript(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__free_animation_script__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Returns whether an `animation_script` has been loaded with the given name.
    /// </summary>
    /// <param name="script"> The `animation_script` to check.</param>
    /// <param name="name"> The name of the `animation_script` to look for.</param>
    /// <returns>Returns a `bool` that denotes whether the `animation_script` has been loaded.</returns>
    public static bool HasAnimationNamed(AnimationScript script, string name)
    {
      __sklib_ptr __skparam__script;
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__script = __skadapter__to_sklib_animation_script(script);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_animation_named__animation_script__string_ref(__skparam__script, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Determines if SplashKit has animation frames loaded for the supplied name. This checks against all loaded animation frames, those loaded without a name are assigned the filename as a default.
    /// </summary>
    /// <param name="name"> The name of the animation script to look for.</param>
    /// <returns>Returns the `bool` that denotes if the animation has the `animation_script`</returns>
    public static bool HasAnimationScript(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_animation_script__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Load animation details from an animation frames file.
    /// </summary>
    /// <param name="name"> The name of the `animation_script`.</param>
    /// <param name="filename"> The file to load the `animation_script` from.</param>
    /// <returns>Returns the newly loaded `animation_script`.</returns>
    public static AnimationScript LoadAnimationScript(string name, string filename)
    {
      __sklib_string __skparam__name;
      __sklib_string __skparam__filename;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __skreturn = __sklib__load_animation_script__string_ref__string_ref(__skparam__name, __skparam__filename);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__filename);
      return __skadapter__to_animation_script(__skreturn);
    }
    /// <summary>
    /// Restarts an `animation`.
    /// </summary>
    /// <param name="anim"> The `animation` to restart.</param>
    public static void RestartAnimation(Animation anim)
    {
      __sklib_ptr __skparam__anim;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __sklib__restart_animation__animation(__skparam__anim);
    }
    /// <summary>
    /// Restarts an `animation`. This may play a sound effect if the first frame triggers a sound.
    /// </summary>
    /// <param name="anim"> The `animation` to restart.</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public static void RestartAnimation(Animation anim, bool withSound)
    {
      __sklib_ptr __skparam__anim;
      int __skparam__with_sound;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__restart_animation__animation__bool(__skparam__anim, __skparam__with_sound);
    }
    /// <summary>
    /// Updates the animation, updating the time spent and possibly moving to a new frame in the animation. This may play a sound effect if the new frame triggers a sound.
    /// </summary>
    /// <param name="anim"> The `animation` to update.</param>
    /// <param name="pct"> The amount that the frame time will be incremented</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public static void UpdateAnimation(Animation anim, float pct, bool withSound)
    {
      __sklib_ptr __skparam__anim;
      float __skparam__pct;
      int __skparam__with_sound;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__pct = __skadapter__to_sklib_float(pct);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__update_animation__animation__float__bool(__skparam__anim, __skparam__pct, __skparam__with_sound);
    }
    /// <summary>
    /// Updates the animation, updating the time spent and possibly moving to a new frame in the animation. This may play a sound effect if the new frame triggers a sound.
    /// </summary>
    /// <param name="anim"> The `animation` to update.</param>
    public static void UpdateAnimation(Animation anim)
    {
      __sklib_ptr __skparam__anim;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __sklib__update_animation__animation(__skparam__anim);
    }
    /// <summary>
    /// Updates the animation, updating the time spent and possibly moving to a new frame in the animation. This may play a sound effect if the new frame triggers a sound.
    /// </summary>
    /// <param name="anim"> The `animation` to update.</param>
    /// <param name="pct"> The amount that the frame time will be incremented</param>
    public static void UpdateAnimation(Animation anim, float pct)
    {
      __sklib_ptr __skparam__anim;
      float __skparam__pct;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__pct = __skadapter__to_sklib_float(pct);
      __sklib__update_animation__animation__float(__skparam__anim, __skparam__pct);
    }
    /// <summary>
    /// Checks if SplashKit audio currently ready to be used.  Should this return `false`, you may want to use `open_audio` to enable audio.
    /// </summary>
    /// <returns>Returns `true` if the audio has been initalised.</returns>
    public static bool AudioReady()
    {
      int __skreturn;
      __skreturn = __sklib__audio_ready();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Turns off audio, stopping all current sounds effects and music.
    /// </summary>
    public static void CloseAudio()
    {
      __sklib__close_audio();
    }
    /// <summary>
    /// Starts the SplashKit audio system working.
    /// </summary>
    public static void OpenAudio()
    {
      __sklib__open_audio();
    }
    /// <summary>
    /// Returns true if the string contains the substring.
    /// </summary>
    /// <param name="text"> The text to search</param>
    /// <param name="subtext"> The substring to search for</param>
    /// <returns>True if the substring is found in the text.</returns>
    public static bool Contains(string text, string subtext)
    {
      __sklib_string __skparam__text;
      __sklib_string __skparam__subtext;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__subtext = __skadapter__to_sklib_string(subtext);
      __skreturn = __sklib__contains__string_ref__string_ref(__skparam__text, __skparam__subtext);
    __skadapter__free__sklib_string(ref __skparam__text);
    __skadapter__free__sklib_string(ref __skparam__subtext);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Convert the passed in string into a double. This can fail in an error if the value is not a number, consider using `is_number` to check before converting a string.
    /// </summary>
    /// <param name="text"> The text to convert.</param>
    /// <returns>The double value read from the text.</returns>
    public static double ConvertToDouble(string text)
    {
      __sklib_string __skparam__text;
      double __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skreturn = __sklib__convert_to_double__string_ref(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Convert the passed in string into an integer. This can fail in an error if the value is not an integer, consider using `is_integer` to check before converting a string.
    /// </summary>
    /// <param name="text"> The text to convert.</param>
    /// <returns>The integer value read from the text.</returns>
    public static int ConvertToInteger(string text)
    {
      __sklib_string __skparam__text;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skreturn = __sklib__convert_to_integer__string_ref(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the index of the first occurrence of the substring in the text.
    /// </summary>
    /// <param name="text"> The text to search</param>
    /// <param name="subtext"> The substring to search for</param>
    /// <returns>The index of the first occurrence of the substring in the text, or -1 if the substring is not found.</returns>
    public static int IndexOf(string text, string subtext)
    {
      __sklib_string __skparam__text;
      __sklib_string __skparam__subtext;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__subtext = __skadapter__to_sklib_string(subtext);
      __skreturn = __sklib__index_of__string_ref__string_ref(__skparam__text, __skparam__subtext);
    __skadapter__free__sklib_string(ref __skparam__text);
    __skadapter__free__sklib_string(ref __skparam__subtext);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Checks if a string contains a number.
    /// </summary>
    /// <param name="text"> The text to check.</param>
    /// <returns>True if the text contains a number (and only a number).</returns>
    public static bool IsDouble(string text)
    {
      __sklib_string __skparam__text;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skreturn = __sklib__is_double__string_ref(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if a string contains an integer value.
    /// </summary>
    /// <param name="text"> The text to check.</param>
    /// <returns>True if the text contains a whole number (and only a whole number).</returns>
    public static bool IsInteger(string text)
    {
      __sklib_string __skparam__text;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skreturn = __sklib__is_integer__string_ref(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if a string contains a number.
    /// </summary>
    /// <param name="text"> The text to check.</param>
    /// <returns>True if the text contains a number (and only a number).</returns>
    public static bool IsNumber(string text)
    {
      __sklib_string __skparam__text;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skreturn = __sklib__is_number__string_ref(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the length of a string in characters.
    /// </summary>
    /// <param name="text"> The text to get the length of</param>
    /// <returns>The number of characters in the string.</returns>
    public static int LengthOf(string text)
    {
      __sklib_string __skparam__text;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skreturn = __sklib__length_of__string_ref(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Replace all occurrences of a substring in a string with another string.
    /// </summary>
    /// <param name="text"> The text to search</param>
    /// <param name="substr"> The substring to find and replace</param>
    /// <param name="newText"> The string to replace the substring with</param>
    /// <returns>The text with all occurrences of the substring replaced with the new text.</returns>
    public static string ReplaceAll(string text, string substr, string newText)
    {
      __sklib_string __skparam__text;
      __sklib_string __skparam__substr;
      __sklib_string __skparam__new_text;
      __sklib_string __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__substr = __skadapter__to_sklib_string(substr);
      __skparam__new_text = __skadapter__to_sklib_string(newText);
      __skreturn = __sklib__replace_all__string_ref__string_ref__string_ref(__skparam__text, __skparam__substr, __skparam__new_text);
    __skadapter__free__sklib_string(ref __skparam__text);
    __skadapter__free__sklib_string(ref __skparam__substr);
    __skadapter__free__sklib_string(ref __skparam__new_text);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Split a string into an array of strings based on a delimiter.
    /// </summary>
    /// <param name="text"> The text to split</param>
    /// <param name="delimiter"> The character to split the text on</param>
    /// <returns>An array of strings</returns>
    public static List<string> Split(string text, char delimiter)
    {
      __sklib_string __skparam__text;
      char __skparam__delimiter;
      __sklib_vector_string __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__delimiter = __skadapter__to_sklib_char(delimiter);
      __skreturn = __sklib__split__string_ref__char(__skparam__text, __skparam__delimiter);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_vector_string(__skreturn);
    }
    /// <summary>
    /// Return a lowercase version of the passed in string.
    /// </summary>
    /// <param name="text"> The text to convert.</param>
    /// <returns>A lower case version of the passed in text.</returns>
    public static string ToLowercase(string text)
    {
      __sklib_string __skparam__text;
      __sklib_string __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skreturn = __sklib__to_lowercase__string_ref(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Return a UPPERCASE version of the passed in string.
    /// </summary>
    /// <param name="text"> The text to convert.</param>
    /// <returns>An upper case version of the passed in text.</returns>
    public static string ToUppercase(string text)
    {
      __sklib_string __skparam__text;
      __sklib_string __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skreturn = __sklib__to_uppercase__string_ref(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Return a new string that removes the spaces from the start and end of the input string.
    /// </summary>
    /// <param name="text"> The string to trim.</param>
    /// <returns>A new string with the contents of `text`, after removing spaces from the start and end.</returns>
    public static string Trim(string text)
    {
      __sklib_string __skparam__text;
      __sklib_string __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skreturn = __sklib__trim__string_ref(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// When you are finished with the resources in a bundle, you can free them all by calling this procedure. It will free the resource bundle and all of the associated resources.
    /// </summary>
    /// <param name="name"> The name of the resource bundle to be freed</param>
    public static void FreeResourceBundle(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__free_resource_bundle__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Returns true when the named resource bundle has already been loaded.
    /// </summary>
    /// <param name="name"> The name of the resource bundle.</param>
    /// <returns>True when the bundle is already loaded.</returns>
    public static bool HasResourceBundle(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_resource_bundle__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Loads all of the resources in the resource bundle. The resource bundle is a text file that describes the resources you want to load. These rescources are then loaded when you call this procedure, and can all be released when you call `release_resource_bundle`.  Save the resource bundle text files into your projects `Resources` in the `bundles` folder. Use the following as the format for each of the resources.  Start a line with a `//` to have it ignored when the bundle is loaded. This can be used to add comments to your bundle.   -  To load an **animation** use the format:  ``` ANIM,name,filename ```  For example, the following will load an animation named "WalkingScript" that loads the animation from "kermit.txt" in your games animation `Resources`.  ``` ANIM,WalkingScript,kermit.txt ```  -  To load a **bitmap** use the format:   ``` BMP,name,filename ```  For example, the following will load a bitmap named "Logo" using the "Logo.png" file.  ``` BITMAP,Logo,logo.png ```  -  To load a **bitmap** that has a number of cells, you can extend the bitmap format with the cell details. This has the format:  ``` BMP,name,filename,cell-width,cell-height,columns,rows,count ```  The following will setup the "Player" bitmap to have cells that are 75 pixels wide, and 42 pixels height. There are 4 columns in 1 row, giving a total of 4 cells.  ``` BITMAP,Player,player.png,75,42,4,1,4 ```  -  To load a font use FONT,name,filename. For example, the following loads a font named "GameFont" that represents the "demolition.otf".  ``` FONT,GameFont,demolition.otf ```  -  To load music, use MUSIC,name,filename. The following loads "GameMusic" for the "magical_night.ogg" file.  ``` MUSIC,GameMusic,magical_night.ogg ```  -  To load a sound effect, use SOUND,name,filename. For example the following loads "error" from the "error.wav" file.  ``` SOUND,error,error.wav ```  -  To create a timer use TIMER,name. The following creates a timer named as "my timer".  ``` TIMER,my timer ```  -  You can also load another resource bundle using BUNDLE,name,filename. The following loads "another bundle" from the "another.txt" file.  ``` BUNDLE,another bundle,another.txt ```
    /// </summary>
    /// <param name="name"> The name of the bundle when it is loaded.</param>
    /// <param name="filename"> The filename to load.</param>
    public static void LoadResourceBundle(string name, string filename)
    {
      __sklib_string __skparam__name;
      __sklib_string __skparam__filename;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __sklib__load_resource_bundle__string_ref__string_ref(__skparam__name, __skparam__filename);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__filename);
    }
    /// <summary>
    /// Returns the position of the camera in game coordinates. This will be the coordinate of the upper left corner of the screen.
    /// </summary>
    /// <returns>The position of the camera as a point_2d.</returns>
    public static Point2D CameraPosition()
    {
      __sklib_point_2d __skreturn;
      __skreturn = __sklib__camera_position();
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns the x location of the camera in game coordinates. This represents the left most x value shown on the screen, with the right of the screen being at camera x + screen width.
    /// </summary>
    /// <returns>The x location of the camera in game coordinates.</returns>
    public static double CameraX()
    {
      double __skreturn;
      __skreturn = __sklib__camera_x();
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Returns the y location of the camera in game coordinates. This represents the stop most y value shown on the screen, with bottom of screen being at camera y + screen height.
    /// </summary>
    /// <returns>The y location of the camera in game coordinates.</returns>
    public static double CameraY()
    {
      double __skreturn;
      __skreturn = __sklib__camera_y();
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Set the camera view to be centered over the specific sprite. The offset vector allows you to move the sprite from the direct center of the screen.
    /// </summary>
    /// <param name="s"> The sprite to track.</param>
    /// <param name="offset"> The amount to offset the camera, allowing you to position the sprite away from the center of the screen.</param>
    public static void CenterCameraOn(Sprite s, Vector2D offset)
    {
      __sklib_ptr __skparam__s;
      __sklib_vector_2d __skparam__offset;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__offset = __skadapter__to_sklib_vector_2d(offset);
      __sklib__center_camera_on__sprite__vector_2d_ref(__skparam__s, __skparam__offset);
    }
    /// <summary>
    /// Set the camera view to be centered over the specific sprite. The offset vector allows you to move the sprite from the direct center of the screen.
    /// </summary>
    /// <param name="s"> The sprite to track.</param>
    /// <param name="offsetX"> An additional offset added to the camera, allowing you to position the sprite offset from the center of the screen.</param>
    /// <param name="offsetY"> An additional offset added to the camera, allowing you to position the sprite offset from the center of the screen.</param>
    public static void CenterCameraOn(Sprite s, double offsetX, double offsetY)
    {
      __sklib_ptr __skparam__s;
      double __skparam__offset_x;
      double __skparam__offset_y;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__offset_x = __skadapter__to_sklib_double(offsetX);
      __skparam__offset_y = __skadapter__to_sklib_double(offsetY);
      __sklib__center_camera_on__sprite__double__double(__skparam__s, __skparam__offset_x, __skparam__offset_y);
    }
    /// <summary>
    /// Move the camera (offset its world x and y values) using the specified vector. For example, if you move the camera by the same speed vector of a sprite the camera will "track" (be locked on to) the sprite as it moves.
    /// </summary>
    /// <param name="offset"> The amount to move the camera.</param>
    public static void MoveCameraBy(Vector2D offset)
    {
      __sklib_vector_2d __skparam__offset;
      __skparam__offset = __skadapter__to_sklib_vector_2d(offset);
      __sklib__move_camera_by__vector_2d_ref(__skparam__offset);
    }
    /// <summary>
    /// Move the camera (offset its world x and y values) using the specified dx (change in x) and dy (change in x) values.
    /// </summary>
    /// <param name="dx"> The amount to move the camera along the x axis.</param>
    /// <param name="dy"> The amount to move the camera along the y axis.</param>
    public static void MoveCameraBy(double dx, double dy)
    {
      double __skparam__dx;
      double __skparam__dy;
      __skparam__dx = __skadapter__to_sklib_double(dx);
      __skparam__dy = __skadapter__to_sklib_double(dy);
      __sklib__move_camera_by__double__double(__skparam__dx, __skparam__dy);
    }
    /// <summary>
    /// Move the camera view (screen top left) to a specified point in the world. This will be the new top left corner of the screen.
    /// </summary>
    /// <param name="pt"> The new camera location</param>
    public static void MoveCameraTo(Point2D pt)
    {
      __sklib_point_2d __skparam__pt;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __sklib__move_camera_to__point_2d_ref(__skparam__pt);
    }
    /// <summary>
    /// Move the camera view to a world location specified by the x and y values. This will be the new top left corner of the screen.
    /// </summary>
    /// <param name="x"> The new camera x location</param>
    /// <param name="y"> The new camera y location</param>
    public static void MoveCameraTo(double x, double y)
    {
      double __skparam__x;
      double __skparam__y;
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__move_camera_to__double__double(__skparam__x, __skparam__y);
    }
    /// <summary>
    /// Tests if the point is in the window.
    /// </summary>
    /// <param name="wind"> The window to check</param>
    /// <param name="pt"> The point to check.</param>
    /// <returns>True if the point is on the screen.</returns>
    public static bool PointInWindow(Window wind, Point2D pt)
    {
      __sklib_ptr __skparam__wind;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__point_in_window__window__point_2d_ref(__skparam__wind, __skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if the point is on the screen.
    /// </summary>
    /// <param name="pt"> The point to check.</param>
    /// <returns>True if the point is on the screen.</returns>
    public static bool PointOnScreen(Point2D pt)
    {
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__point_on_screen__point_2d_ref(__skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if the rectangle is within the bounds of the window.
    /// </summary>
    /// <param name="wind"> The window to check</param>
    /// <param name="rect"> The rectangle to check.</param>
    /// <returns>True if any part of the rectangle is in the window.</returns>
    public static bool RectInWindow(Window wind, Rectangle rect)
    {
      __sklib_ptr __skparam__wind;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__rect_in_window__window__rectangle_ref(__skparam__wind, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if the rectangle is on the screen.
    /// </summary>
    /// <param name="rect"> The rectangle to check.</param>
    /// <returns>True if any part of the rectangle is on the screen.</returns>
    public static bool RectOnScreen(Rectangle rect)
    {
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__rect_on_screen__rectangle_ref(__skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the center of the screen in world coordinates.
    /// </summary>
    /// <returns>The center of the screen in world coordinates.</returns>
    public static Point2D ScreenCenter()
    {
      __sklib_point_2d __skreturn;
      __skreturn = __sklib__screen_center();
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that represents the dimensions of the window.
    /// </summary>
    /// <returns>A rectangle representing the dimensions of the current window.</returns>
    public static Rectangle ScreenRectangle()
    {
      __sklib_rectangle __skreturn;
      __skreturn = __sklib__screen_rectangle();
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Change the position of the camera to a specified world coordinate. This will then be the new top left most position of the screen within the world.
    /// </summary>
    /// <param name="pos"> The new location of the camera.</param>
    public static void SetCameraPosition(Point2D pos)
    {
      __sklib_point_2d __skparam__pos;
      __skparam__pos = __skadapter__to_sklib_point_2d(pos);
      __sklib__set_camera_position__point_2d(__skparam__pos);
    }
    /// <summary>
    /// Change the X position of the camera to a specified world coordinate. This will then be the new left most position of the screen within the world.
    /// </summary>
    /// <param name="x"> The new x coordinate for the camera</param>
    public static void SetCameraX(double x)
    {
      double __skparam__x;
      __skparam__x = __skadapter__to_sklib_double(x);
      __sklib__set_camera_x__double(__skparam__x);
    }
    /// <summary>
    /// Change the Y position of the camera to a specified world coordinate. This will then be the new top most position of the screen within the world.
    /// </summary>
    /// <param name="y"> The new y coordinate for the camera</param>
    public static void SetCameraY(double y)
    {
      double __skparam__y;
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__set_camera_y__double(__skparam__y);
    }
    /// <summary>
    /// Convert the passed in world coordinates to screen coordinates.
    /// </summary>
    /// <param name="pt"> The point to convert - this should be in world coordinates.</param>
    /// <returns>A point that represents pt in screen coordinates.</returns>
    public static Point2D ToScreen(Point2D pt)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_point_2d __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__to_screen__point_2d_ref(__skparam__pt);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Convert the rectangle in world coordinates to screen coordinates.
    /// </summary>
    /// <param name="rect"> The rectangle to convert - this should be in world coordinates.</param>
    /// <returns>A rectangle that represents rect in screen coordinates.</returns>
    public static Rectangle ToScreen(Rectangle rect)
    {
      __sklib_rectangle __skparam__rect;
      __sklib_rectangle __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__to_screen__rectangle_ref(__skparam__rect);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Translate a world x value to the current screen x value which is based on the camera position.
    /// </summary>
    /// <param name="worldX"> The value of the x coordinate to translate to screen.</param>
    /// <returns>The x location of the world coordinate on the screen.</returns>
    public static double ToScreenX(double worldX)
    {
      double __skparam__world_x;
      double __skreturn;
      __skparam__world_x = __skadapter__to_sklib_double(worldX);
      __skreturn = __sklib__to_screen_x__double(__skparam__world_x);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Translate a world y value to the current screen y value set by the camera.
    /// </summary>
    /// <param name="worldY"> The value of the y coordinate to translate to screen.</param>
    /// <returns>The y location of the world coordinate on the screen.</returns>
    public static double ToScreenY(double worldY)
    {
      double __skparam__world_y;
      double __skreturn;
      __skparam__world_y = __skadapter__to_sklib_double(worldY);
      __skreturn = __sklib__to_screen_y__double(__skparam__world_y);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Converts the passed in point from screen coordinates to world coordinates.
    /// </summary>
    /// <param name="pt"> The point in screen coordinates.</param>
    /// <returns>The same point in world coordinates.</returns>
    public static Point2D ToWorld(Point2D pt)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_point_2d __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__to_world__point_2d_ref(__skparam__pt);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Translate a screen x value (based on the camera) to a world x value
    /// </summary>
    /// <param name="screenX"> The value of the x coordinate on screen to translate to the world.</param>
    /// <returns>The x location of the screen coordinate in the world.</returns>
    public static double ToWorldX(double screenX)
    {
      double __skparam__screen_x;
      double __skreturn;
      __skparam__screen_x = __skadapter__to_sklib_double(screenX);
      __skreturn = __sklib__to_world_x__double(__skparam__screen_x);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Translate a screen y value (based on the camera) to a world y value
    /// </summary>
    /// <param name="screenY"> The value of the y coordinate on screen to translate to the world.</param>
    /// <returns>The y location of the screen coordinate in the world.</returns>
    public static double ToWorldY(double screenY)
    {
      double __skparam__screen_y;
      double __skreturn;
      __skparam__screen_y = __skadapter__to_sklib_double(screenY);
      __skreturn = __sklib__to_world_y__double(__skparam__screen_y);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Returns a vector that can transform points from world to screen coordinates.
    /// </summary>
    /// <returns>A vector representing the distance and direction points need to move to map from world to screen coordinates.</returns>
    public static Vector2D VectorWorldToScreen()
    {
      __sklib_vector_2d __skreturn;
      __skreturn = __sklib__vector_world_to_screen();
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that represents the dimensions of the window based on the camera.
    /// </summary>
    /// <param name="wind"> The window</param>
    /// <returns>A rectangle representing the dimensions of the current window.</returns>
    public static Rectangle WindowArea(Window wind)
    {
      __sklib_ptr __skparam__wind;
      __sklib_rectangle __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skreturn = __sklib__window_area__window(__skparam__wind);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Draw a circle on the current window. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="c"> The circle being drawn</param>
    public static void DrawCircle(Color clr, Circle c)
    {
      __sklib_color __skparam__clr;
      __sklib_circle __skparam__c;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __sklib__draw_circle__color__circle_ref(__skparam__clr, __skparam__c);
    }
    /// <summary>
    /// Draw a circle with the provided drawing options, which may include options related to the drawing destination.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="c"> The circle being drawn</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public static void DrawCircle(Color clr, Circle c, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_circle __skparam__c;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_circle__color__circle_ref__drawing_options(__skparam__clr, __skparam__c, __skparam__opts);
    }
    /// <summary>
    /// Draw a circle onto the current window. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    public static void DrawCircle(Color clr, double x, double y, double radius)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __sklib__draw_circle__color__double__double__double(__skparam__clr, __skparam__x, __skparam__y, __skparam__radius);
    }
    /// <summary>
    /// Draw a circle using the supplied drawing options. The circle is centred on its x, y coordinates, and has the provided radius. This will use `drawing_options` to determine the destination.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public static void DrawCircle(Color clr, double x, double y, double radius, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_circle__color__double__double__double__drawing_options(__skparam__clr, __skparam__x, __skparam__y, __skparam__radius, __skparam__opts);
    }
    /// <summary>
    /// Draw a circle onto the destination bitmap. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    public static void DrawCircleOnBitmap(Bitmap destination, Color clr, double x, double y, double radius)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __sklib__draw_circle_on_bitmap__bitmap__color__double__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__radius);
    }
    /// <summary>
    /// Draw a circle to the bitmap using the supplied drawing options. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public static void DrawCircleOnBitmap(Bitmap destination, Color clr, double x, double y, double radius, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_circle_on_bitmap__bitmap__color__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__radius, __skparam__opts);
    }
    /// <summary>
    /// Draw a circle onto the destination window. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    public static void DrawCircleOnWindow(Window destination, Color clr, double x, double y, double radius)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __sklib__draw_circle_on_window__window__color__double__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__radius);
    }
    /// <summary>
    /// Draw a circle to the window using the supplied drawing options. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public static void DrawCircleOnWindow(Window destination, Color clr, double x, double y, double radius, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_circle_on_window__window__color__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__radius, __skparam__opts);
    }
    /// <summary>
    /// Draw a circle on the current window. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="c"> The circle being drawn</param>
    public static void FillCircle(Color clr, Circle c)
    {
      __sklib_color __skparam__clr;
      __sklib_circle __skparam__c;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __sklib__fill_circle__color__circle_ref(__skparam__clr, __skparam__c);
    }
    /// <summary>
    /// Fill a circle with the provided drawing options, which may include options related to the drawing destination.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="c"> The circle being drawn</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public static void FillCircle(Color clr, Circle c, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_circle __skparam__c;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_circle__color__circle_ref__drawing_options(__skparam__clr, __skparam__c, __skparam__opts);
    }
    /// <summary>
    /// Fill a circle onto the current window. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    public static void FillCircle(Color clr, double x, double y, double radius)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __sklib__fill_circle__color__double__double__double(__skparam__clr, __skparam__x, __skparam__y, __skparam__radius);
    }
    /// <summary>
    /// Fill a circle using the supplied drawing options. The circle is centred on its x, y coordinates, and has the provided radius. This will use `drawing_options` to determine the destination.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public static void FillCircle(Color clr, double x, double y, double radius, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_circle__color__double__double__double__drawing_options(__skparam__clr, __skparam__x, __skparam__y, __skparam__radius, __skparam__opts);
    }
    /// <summary>
    /// Fill a circle onto the destination bitmap. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    public static void FillCircleOnBitmap(Bitmap destination, Color clr, double x, double y, double radius)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __sklib__fill_circle_on_bitmap__bitmap__color__double__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__radius);
    }
    /// <summary>
    /// Fill a circle to the bitmap using the supplied drawing options. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public static void FillCircleOnBitmap(Bitmap destination, Color clr, double x, double y, double radius, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_circle_on_bitmap__bitmap__color__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__radius, __skparam__opts);
    }
    /// <summary>
    /// Fill a circle onto the destination window. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    public static void FillCircleOnWindow(Window destination, Color clr, double x, double y, double radius)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __sklib__fill_circle_on_window__window__color__double__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__radius);
    }
    /// <summary>
    /// Fill a circle to the window using the supplied drawing options. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public static void FillCircleOnWindow(Window destination, Color clr, double x, double y, double radius, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_circle_on_window__window__color__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__radius, __skparam__opts);
    }
    /// <summary>
    /// Returns the center point of the circle.
    /// </summary>
    /// <param name="c"> The circle to get the center point</param>
    /// <returns>The center point of the circle</returns>
    public static Point2D CenterPoint(Circle c)
    {
      __sklib_circle __skparam__c;
      __sklib_point_2d __skreturn;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skreturn = __sklib__center_point__circle_ref(__skparam__c);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns a circle at the indicated point and radius.
    /// </summary>
    /// <param name="pt"> The location of the center of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    /// <returns>A circle at the indicatd point and radius</returns>
    public static Circle CircleAt(Point2D pt, double radius)
    {
      __sklib_point_2d __skparam__pt;
      double __skparam__radius;
      __sklib_circle __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __skreturn = __sklib__circle_at__point_2d_ref__double(__skparam__pt, __skparam__radius);
      return __skadapter__to_circle(__skreturn);
    }
    /// <summary>
    /// Returns a circle at the indicated point and radius.
    /// </summary>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    /// <returns>A circle at the indicatd point and radius</returns>
    public static Circle CircleAt(double x, double y, double radius)
    {
      double __skparam__x;
      double __skparam__y;
      double __skparam__radius;
      __sklib_circle __skreturn;
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __skreturn = __sklib__circle_at__double__double__double(__skparam__x, __skparam__y, __skparam__radius);
      return __skadapter__to_circle(__skreturn);
    }
    /// <summary>
    /// Detects if a circle intersects with a quad.
    /// </summary>
    /// <param name="c"> The circle to test</param>
    /// <param name="q"> The quad to test</param>
    /// <returns>True if the circle and quad intersect, false otherwise</returns>
    public static bool CircleQuadIntersect(Circle c, Quad q)
    {
      __sklib_circle __skparam__c;
      __sklib_quad __skparam__q;
      int __skreturn;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skreturn = __sklib__circle_quad_intersect__circle_ref__quad_ref(__skparam__c, __skparam__q);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the circle radius.
    /// </summary>
    /// <param name="c"> The circle</param>
    /// <returns>The radius of the circle</returns>
    public static float CircleRadius(Circle c)
    {
      __sklib_circle __skparam__c;
      float __skreturn;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skreturn = __sklib__circle_radius__circle(__skparam__c);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Detects if a ray intersects a circle.
    /// </summary>
    /// <param name="origin"> The starting point of the ray</param>
    /// <param name="heading"> The direction of the ray as a vector</param>
    /// <param name="circ"> The circle to check for intersection</param>
    /// <returns>True if the ray intersects the circle, false otherwise</returns>
    public static bool CircleRayIntersection(Point2D origin, Vector2D heading, Circle circ)
    {
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      __sklib_circle __skparam__circ;
      int __skreturn;
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skparam__circ = __skadapter__to_sklib_circle(circ);
      __skreturn = __sklib__circle_ray_intersection__point_2d_ref__vector_2d_ref__circle_ref(__skparam__origin, __skparam__heading, __skparam__circ);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Detects if a ray intersects a circle. If an intersection is found, the `hit_point` and `hit_distance` are set to the point of intersection and the distance from the ray's origin to the intersection point. If the ray's `origin` is contained within the circle, `hit_point` is set to the `origin` and `hit_distance` is set to 0. If no intersection is found, `hit_point` and `hit_distance` are not modified.
    /// </summary>
    /// <param name="origin"> The starting point of the ray</param>
    /// <param name="heading"> The direction of the ray as a vector</param>
    /// <param name="circ"> The circle to check for intersection</param>
    /// <param name="hitPoint"> The point to set to where the ray intersects the circle</param>
    /// <param name="hitDistance"> The double to set to the distance from the ray's origin to the intersection point</param>
    /// <returns>True if the ray intersects the circle, false otherwise</returns>
    public static bool CircleRayIntersection(Point2D origin, Vector2D heading, Circle circ, ref Point2D hitPoint, ref double hitDistance)
    {
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      __sklib_circle __skparam__circ;
      __sklib_point_2d __skparam__hit_point;
      double __skparam__hit_distance;
      int __skreturn;
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skparam__circ = __skadapter__to_sklib_circle(circ);
      __skparam__hit_point = __skadapter__to_sklib_point_2d(hitPoint);
      __skparam__hit_distance = __skadapter__to_sklib_double(hitDistance);
      __skreturn = __sklib__circle_ray_intersection__point_2d_ref__vector_2d_ref__circle_ref__point_2d_ref__double_ref(__skparam__origin, __skparam__heading, __skparam__circ, ref __skparam__hit_point, ref __skparam__hit_distance);
      hitPoint = __skadapter__to_point_2d(__skparam__hit_point);
      hitDistance = __skadapter__to_double(__skparam__hit_distance);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Detects if a circle intersects with a triangle.
    /// </summary>
    /// <param name="c"> The circle to test</param>
    /// <param name="tri"> The triangle to test</param>
    /// <returns>True if the circle and triangle intersect</returns>
    public static bool CircleTriangleIntersect(Circle c, Triangle tri)
    {
      __sklib_circle __skparam__c;
      __sklib_triangle __skparam__tri;
      int __skreturn;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skreturn = __sklib__circle_triangle_intersect__circle_ref__triangle_ref(__skparam__c, __skparam__tri);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Detects if a circle intersects with a triangle. The closest point on the triangle to the circle is assigned to p, even if the circle and triangle do not intersect. If the centre of the circle is inside the triangle, the point assigned to p is the centre of the circle.
    /// </summary>
    /// <param name="c"> The circle to test</param>
    /// <param name="tri"> The triangle to test</param>
    /// <param name="p"> The point to set to the closest point on the triangle to the circle</param>
    /// <returns>True if the circle and triangle intersect</returns>
    public static bool CircleTriangleIntersect(Circle c, Triangle tri, ref Point2D p)
    {
      __sklib_circle __skparam__c;
      __sklib_triangle __skparam__tri;
      __sklib_point_2d __skparam__p;
      int __skreturn;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skparam__p = __skadapter__to_sklib_point_2d(p);
      __skreturn = __sklib__circle_triangle_intersect__circle_ref__triangle_ref__point_2d_ref(__skparam__c, __skparam__tri, ref __skparam__p);
      p = __skadapter__to_point_2d(__skparam__p);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the circle x value.
    /// </summary>
    /// <param name="c"> The circle</param>
    /// <returns>The x location of the center of the circle</returns>
    public static float CircleX(Circle c)
    {
      __sklib_circle __skparam__c;
      float __skreturn;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skreturn = __sklib__circle_x__circle_ref(__skparam__c);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Returns the circle y value.
    /// </summary>
    /// <param name="c"> The circle</param>
    /// <returns>The y location of the center of the circle</returns>
    public static float CircleY(Circle c)
    {
      __sklib_circle __skparam__c;
      float __skreturn;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skreturn = __sklib__circle_y__circle_ref(__skparam__c);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Detects if two circles intersect. This can be used to detect collisions between bounding circles.
    /// </summary>
    /// <param name="c1"> The circle to test if intersects with c2</param>
    /// <param name="c2"> The circle to test if intersects with c1</param>
    /// <returns>True if the two circles do intersect</returns>
    public static bool CirclesIntersect(Circle c1, Circle c2)
    {
      __sklib_circle __skparam__c1;
      __sklib_circle __skparam__c2;
      int __skreturn;
      __skparam__c1 = __skadapter__to_sklib_circle(c1);
      __skparam__c2 = __skadapter__to_sklib_circle(c2);
      __skreturn = __sklib__circles_intersect__circle__circle(__skparam__c1, __skparam__c2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Detects if two circles intersect. This can be used to detect collisions between bounding circles. The circle data is passed in as individual values.
    /// </summary>
    /// <param name="c1X"> the x location of the first circle</param>
    /// <param name="c1Y"> the y location of the first circle</param>
    /// <param name="c1Radius"> the radius of the first circle</param>
    /// <param name="c2X"> the x location of the second circle</param>
    /// <param name="c2Y"> the y location of the second circle</param>
    /// <param name="c2Radius"> the radius of the second circle</param>
    /// <returns>true when the two circles intersect</returns>
    public static bool CirclesIntersect(double c1X, double c1Y, double c1Radius, double c2X, double c2Y, double c2Radius)
    {
      double __skparam__c1_x;
      double __skparam__c1_y;
      double __skparam__c1_radius;
      double __skparam__c2_x;
      double __skparam__c2_y;
      double __skparam__c2_radius;
      int __skreturn;
      __skparam__c1_x = __skadapter__to_sklib_double(c1X);
      __skparam__c1_y = __skadapter__to_sklib_double(c1Y);
      __skparam__c1_radius = __skadapter__to_sklib_double(c1Radius);
      __skparam__c2_x = __skadapter__to_sklib_double(c2X);
      __skparam__c2_y = __skadapter__to_sklib_double(c2Y);
      __skparam__c2_radius = __skadapter__to_sklib_double(c2Radius);
      __skreturn = __sklib__circles_intersect__double__double__double__double__double__double(__skparam__c1_x, __skparam__c1_y, __skparam__c1_radius, __skparam__c2_x, __skparam__c2_y, __skparam__c2_radius);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the closest point on a circle's circumference to a given point. If the point is equal to the center of the circle, the center point is returned.
    /// </summary>
    /// <param name="fromPt"> The point to test from</param>
    /// <param name="c"> The circle</param>
    /// <returns>The point on `c`'s circumference that is closest to `from_point`, or the center of the circle if the point equals `c`'s center.</returns>
    public static Point2D ClosestPointOnCircle(Point2D fromPt, Circle c)
    {
      __sklib_point_2d __skparam__from_pt;
      __sklib_circle __skparam__c;
      __sklib_point_2d __skreturn;
      __skparam__from_pt = __skadapter__to_sklib_point_2d(fromPt);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skreturn = __sklib__closest_point_on_circle__point_2d_ref__circle_ref(__skparam__from_pt, __skparam__c);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns the closest point on a line to a circle.
    /// </summary>
    /// <param name="c"> The circle</param>
    /// <param name="l"> The line</param>
    /// <returns>The point that is closest to `c` on `l`</returns>
    public static Point2D ClosestPointOnLineFromCircle(Circle c, Line l)
    {
      __sklib_circle __skparam__c;
      __sklib_line __skparam__l;
      __sklib_point_2d __skreturn;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__l = __skadapter__to_sklib_line(l);
      __skreturn = __sklib__closest_point_on_line_from_circle__circle_ref__line_ref(__skparam__c, __skparam__l);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns the closest point on a rectangle's perimeter to a circle.
    /// </summary>
    /// <param name="c"> The circle</param>
    /// <param name="rect"> The rectangle</param>
    /// <returns>The point that is closest to `c` on `rect`'s perimeter</returns>
    public static Point2D ClosestPointOnRectFromCircle(Circle c, Rectangle rect)
    {
      __sklib_circle __skparam__c;
      __sklib_rectangle __skparam__rect;
      __sklib_point_2d __skreturn;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__closest_point_on_rect_from_circle__circle_ref__rectangle_ref(__skparam__c, __skparam__rect);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Calculates the closest point on a triangle to a circle. If the circle and triangle do not intersect, the closest point on the triangle to the circle is returned. If the circle and triangle do intersect, the center of the circle is returned.
    /// </summary>
    /// <param name="c"> The circle to test</param>
    /// <param name="tri"> The triangle to test</param>
    /// <returns>The closest point on the triangle to the circle</returns>
    public static Point2D ClosestPointOnTriangleFromCircle(Circle c, Triangle tri)
    {
      __sklib_circle __skparam__c;
      __sklib_triangle __skparam__tri;
      __sklib_point_2d __skreturn;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skreturn = __sklib__closest_point_on_triangle_from_circle__circle_ref__triangle_ref(__skparam__c, __skparam__tri);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// The furthest point on the circle to the given point.
    /// </summary>
    /// <param name="pt"> The point to test from</param>
    /// <param name="c"> The circle you want to get a point on its circumference</param>
    /// <returns>The point on c that is furthest from `pt`</returns>
    public static Point2D DistantPointOnCircle(Point2D pt, Circle c)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_circle __skparam__c;
      __sklib_point_2d __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skreturn = __sklib__distant_point_on_circle__point_2d_ref__circle_ref(__skparam__pt, __skparam__c);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Determines the opposite side of a circle given a collision point and a heading.
    /// </summary>
    /// <param name="pt"> The point from which the test is being made</param>
    /// <param name="c"> The circle</param>
    /// <param name="heading"> The direction the point is heading</param>
    /// <param name="oppositePt"> After the call, this is set to the point on the opposite side of the circle from pt when it is heading in the given direction.</param>
    /// <returns>True when the `opposite_pt` is calculated, false when the point would not collide with the circle when heading as indicated.</returns>
    public static bool DistantPointOnCircleHeading(Point2D pt, Circle c, Vector2D heading, ref Point2D oppositePt)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_circle __skparam__c;
      __sklib_vector_2d __skparam__heading;
      __sklib_point_2d __skparam__opposite_pt;
      int __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skparam__opposite_pt = __skadapter__to_sklib_point_2d(oppositePt);
      __skreturn = __sklib__distant_point_on_circle_heading__point_2d_ref__circle_ref__vector_2d_ref__point_2d_ref(__skparam__pt, __skparam__c, __skparam__heading, ref __skparam__opposite_pt);
      oppositePt = __skadapter__to_point_2d(__skparam__opposite_pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Calculates the distance from a ray cast from a point to a given circle.
    /// </summary>
    /// <param name="rayOrigin"> The origin of the ray</param>
    /// <param name="rayHeading"> The direction of the ray</param>
    /// <param name="c"> The circle being tested</param>
    /// <returns>-1 if the ray does not hit the circle, otherwise the distance from the origin to the circle bounds.</returns>
    public static float RayCircleIntersectDistance(Point2D rayOrigin, Vector2D rayHeading, Circle c)
    {
      __sklib_point_2d __skparam__ray_origin;
      __sklib_vector_2d __skparam__ray_heading;
      __sklib_circle __skparam__c;
      float __skreturn;
      __skparam__ray_origin = __skadapter__to_sklib_point_2d(rayOrigin);
      __skparam__ray_heading = __skadapter__to_sklib_vector_2d(rayHeading);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skreturn = __sklib__ray_circle_intersect_distance__point_2d_ref__vector_2d_ref__circle_ref(__skparam__ray_origin, __skparam__ray_heading, __skparam__c);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Returns the two tangent points on the circle given the indicated point.
    /// </summary>
    /// <param name="fromPt"> The source point</param>
    /// <param name="c"> The circle</param>
    /// <param name="p1"> If this returns true, then `p1` contains one of the points</param>
    /// <param name="p2"> If this returns true, then `p2` contains one of the points</param>
    /// <returns>True if `from_pt` is outside of the circle, and tangent points are calculated</returns>
    public static bool TangentPoints(Point2D fromPt, Circle c, ref Point2D p1, ref Point2D p2)
    {
      __sklib_point_2d __skparam__from_pt;
      __sklib_circle __skparam__c;
      __sklib_point_2d __skparam__p1;
      __sklib_point_2d __skparam__p2;
      int __skreturn;
      __skparam__from_pt = __skadapter__to_sklib_point_2d(fromPt);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__p1 = __skadapter__to_sklib_point_2d(p1);
      __skparam__p2 = __skadapter__to_sklib_point_2d(p2);
      __skreturn = __sklib__tangent_points__point_2d_ref__circle_ref__point_2d_ref__point_2d_ref(__skparam__from_pt, __skparam__c, ref __skparam__p1, ref __skparam__p2);
      p1 = __skadapter__to_point_2d(__skparam__p1);
      p2 = __skadapter__to_point_2d(__skparam__p2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Calculates the two points on a circles radius that lie along the given vector. This represents the points on the circle when the vector is placed at the circle's center point.
    /// </summary>
    /// <param name="c"> The circle</param>
    /// <param name="along"> The vector representing the line along which the points lie.</param>
    /// <param name="pt1"> After the call, this is set to one of the widest points</param>
    /// <param name="pt2"> After the call, this is set to one of the widest points</param>
    public static void WidestPoints(Circle c, Vector2D along, ref Point2D pt1, ref Point2D pt2)
    {
      __sklib_circle __skparam__c;
      __sklib_vector_2d __skparam__along;
      __sklib_point_2d __skparam__pt1;
      __sklib_point_2d __skparam__pt2;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__along = __skadapter__to_sklib_vector_2d(along);
      __skparam__pt1 = __skadapter__to_sklib_point_2d(pt1);
      __skparam__pt2 = __skadapter__to_sklib_point_2d(pt2);
      __sklib__widest_points__circle_ref__vector_2d_ref__point_2d_ref__point_2d_ref(__skparam__c, __skparam__along, ref __skparam__pt1, ref __skparam__pt2);
      pt1 = __skadapter__to_point_2d(__skparam__pt1);
      pt2 = __skadapter__to_point_2d(__skparam__pt2);
    }
    /// <summary>
    /// Returns the rectangle of the current clip area for the current window
    /// </summary>
    /// <returns>The current clipping rectangle for the current window</returns>
    public static Rectangle CurrentClip()
    {
      __sklib_rectangle __skreturn;
      __skreturn = __sklib__current_clip();
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns the rectangle of the current clip area for a bitmap
    /// </summary>
    /// <param name="bmp"> The bitmap to get the clipping rectangle from</param>
    /// <returns>The current clipping rectangle for the bitmap</returns>
    public static Rectangle CurrentClip(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_rectangle __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__current_clip__bitmap(__skparam__bmp);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns the rectangle of the current clip area for a window
    /// </summary>
    /// <param name="wnd"> The window to get the clipping rectangle from</param>
    /// <returns>The current clipping rectangle for the window</returns>
    public static Rectangle CurrentClip(Window wnd)
    {
      __sklib_ptr __skparam__wnd;
      __sklib_rectangle __skreturn;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skreturn = __sklib__current_clip__window(__skparam__wnd);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Remove the last clipping rectangle pushed to the window. This will then apply the previously pushed clipping rectangle.
    /// </summary>
    /// <param name="wnd"> The window to change</param>
    public static void PopClip(Window wnd)
    {
      __sklib_ptr __skparam__wnd;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __sklib__pop_clip__window(__skparam__wnd);
    }
    /// <summary>
    /// Remove the last clipping rectangle pushed to the current window. This will then apply the previously pushed clipping rectangle.
    /// </summary>
    public static void PopClip()
    {
      __sklib__pop_clip();
    }
    /// <summary>
    /// Remove the last clipping rectangle pushed to the bitmap. This will then apply the previously pushed clipping rectangle.
    /// </summary>
    /// <param name="bmp"> The bitmap to change</param>
    public static void PopClip(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __sklib__pop_clip__bitmap(__skparam__bmp);
    }
    /// <summary>
    /// Add the clipping rectangle of a window and uses the intersect between the new rectangle and previous clip.  When a clipping rectangle is provided, drawing operations will only affect the area specified in the current clipping rectangle.
    /// </summary>
    /// <param name="wnd"> The window to add clipping to</param>
    /// <param name="r"> The new clipping rectangle</param>
    public static void PushClip(Window wnd, Rectangle r)
    {
      __sklib_ptr __skparam__wnd;
      __sklib_rectangle __skparam__r;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skparam__r = __skadapter__to_sklib_rectangle(r);
      __sklib__push_clip__window__rectangle_ref(__skparam__wnd, __skparam__r);
    }
    /// <summary>
    /// Add the clipping rectangle of a bitmap and uses the intersect between the new rectangle and previous clip.  When a clipping rectangle is provided, drawing operations will only affect the area specified in the current clipping rectangle.
    /// </summary>
    /// <param name="bmp"> The bitmap to add clipping to</param>
    /// <param name="r"> The new clipping rectangle</param>
    public static void PushClip(Bitmap bmp, Rectangle r)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_rectangle __skparam__r;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__r = __skadapter__to_sklib_rectangle(r);
      __sklib__push_clip__bitmap__rectangle_ref(__skparam__bmp, __skparam__r);
    }
    /// <summary>
    /// Push a clip rectangle to the current window. The resulting clipping rectangle will be the intersection of the existing clipping rectangle with the new rectangle provided in this call. This can be undone using `pop_clip`.  When a clipping rectangle is provided, drawing operations will only affect the area specified in the current clipping rectangle.
    /// </summary>
    /// <param name="r"> The new clipping rectangle</param>
    public static void PushClip(Rectangle r)
    {
      __sklib_rectangle __skparam__r;
      __skparam__r = __skadapter__to_sklib_rectangle(r);
      __sklib__push_clip__rectangle_ref(__skparam__r);
    }
    /// <summary>
    /// Reset the clipping rectangle on a bitmap. This will clear all of the clipping rectangles pushed to the bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap to clear the clipping rectangle</param>
    public static void ResetClip(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __sklib__reset_clip__bitmap(__skparam__bmp);
    }
    /// <summary>
    /// Reset the clipping rectangle of the current window. This will clear all of the clipping rectangles pushed to the current window.
    /// </summary>
    public static void ResetClip()
    {
      __sklib__reset_clip();
    }
    /// <summary>
    /// Reset the clipping rectangle on a window. This will clear all of the clipping rectangles pushed to the window.
    /// </summary>
    /// <param name="wnd"> The window to clear the clipping rectangle</param>
    public static void ResetClip(Window wnd)
    {
      __sklib_ptr __skparam__wnd;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __sklib__reset_clip__window(__skparam__wnd);
    }
    /// <summary>
    /// Set the clip rectangle of the current window. This will clear any existing clipping rectangles pushed to the current window, and use the supplied rectangle for clipping.
    /// </summary>
    /// <param name="r"> The new clipping rectangle</param>
    public static void SetClip(Rectangle r)
    {
      __sklib_rectangle __skparam__r;
      __skparam__r = __skadapter__to_sklib_rectangle(r);
      __sklib__set_clip__rectangle_ref(__skparam__r);
    }
    /// <summary>
    /// Set the clip rectangle of the bitmap. This will clear any existing clipping rectangles pushed to the bitmap, and use the supplied rectangle for clipping.
    /// </summary>
    /// <param name="bmp"> The bitmap to change</param>
    /// <param name="r"> The new clipping rectangle</param>
    public static void SetClip(Bitmap bmp, Rectangle r)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_rectangle __skparam__r;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__r = __skadapter__to_sklib_rectangle(r);
      __sklib__set_clip__bitmap__rectangle_ref(__skparam__bmp, __skparam__r);
    }
    /// <summary>
    /// Set the clip rectangle of the window. This will clear any existing clipping rectangles pushed to the window, and use the supplied rectangle for clipping.
    /// </summary>
    /// <param name="wnd"> The window to change</param>
    /// <param name="r"> The new clipping rectangle</param>
    public static void SetClip(Window wnd, Rectangle r)
    {
      __sklib_ptr __skparam__wnd;
      __sklib_rectangle __skparam__r;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skparam__r = __skadapter__to_sklib_rectangle(r);
      __sklib__set_clip__window__rectangle_ref(__skparam__wnd, __skparam__r);
    }
    /// <summary>
    /// Tests if a bitmap drawn at `pt` would intersect with a circle.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="circ"> The circle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `circ` when drawn.</returns>
    public static bool BitmapCircleCollision(Bitmap bmp, Point2D pt, Circle circ)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skparam__pt;
      __sklib_circle __skparam__circ;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__circ = __skadapter__to_sklib_circle(circ);
      __skreturn = __sklib__bitmap_circle_collision__bitmap__point_2d_ref__circle_ref(__skparam__bmp, __skparam__pt, __skparam__circ);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap drawn at `x`, `y` would intersect with a circle.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="circ"> The circle to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `circ` when drawn.</returns>
    public static bool BitmapCircleCollision(Bitmap bmp, double x, double y, Circle circ)
    {
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __sklib_circle __skparam__circ;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__circ = __skadapter__to_sklib_circle(circ);
      __skreturn = __sklib__bitmap_circle_collision__bitmap__double__double__circle_ref(__skparam__bmp, __skparam__x, __skparam__y, __skparam__circ);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn using a passed in translation, will intersect with a circle. You can use this to detect collisions between bitmaps and circles.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="translation"> The matrix used to transfrom the bitmap when drawing</param>
    /// <param name="circ"> The circle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `circ` when drawn.</returns>
    public static bool BitmapCircleCollision(Bitmap bmp, int cell, Matrix2D translation, Circle circ)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_matrix_2d __skparam__translation;
      __sklib_circle __skparam__circ;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__translation = __skadapter__to_sklib_matrix_2d(translation);
      __skparam__circ = __skadapter__to_sklib_circle(circ);
      __skreturn = __sklib__bitmap_circle_collision__bitmap__int__matrix_2d_ref__circle_ref(__skparam__bmp, __skparam__cell, __skparam__translation, __skparam__circ);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn at `pt` would intersect with a circle.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="circ"> The circle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `circ` when drawn.</returns>
    public static bool BitmapCircleCollision(Bitmap bmp, int cell, Point2D pt, Circle circ)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_point_2d __skparam__pt;
      __sklib_circle __skparam__circ;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__circ = __skadapter__to_sklib_circle(circ);
      __skreturn = __sklib__bitmap_circle_collision__bitmap__int__point_2d_ref__circle_ref(__skparam__bmp, __skparam__cell, __skparam__pt, __skparam__circ);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn at `x`, `y` would intersect with a circle.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="circ"> The circle to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `circ` when drawn.</returns>
    public static bool BitmapCircleCollision(Bitmap bmp, int cell, double x, double y, Circle circ)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      double __skparam__x;
      double __skparam__y;
      __sklib_circle __skparam__circ;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__circ = __skadapter__to_sklib_circle(circ);
      __skreturn = __sklib__bitmap_circle_collision__bitmap__int__double__double__circle_ref(__skparam__bmp, __skparam__cell, __skparam__x, __skparam__y, __skparam__circ);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Check if two bitmaps collide.
    /// </summary>
    /// <param name="bmp1"> The first bitmap</param>
    /// <param name="x1"> The x location where the first bitmap is drawn</param>
    /// <param name="y1"> The y location where the first bitmap is drawn</param>
    /// <param name="bmp2"> The second bitmap</param>
    /// <param name="x2"> The x location where the second bitmap is drawn</param>
    /// <param name="y2"> The y location where the second bitmap is drawn</param>
    /// <returns>True if pixels in the two bitmaps would collide/overlap</returns>
    public static bool BitmapCollision(Bitmap bmp1, double x1, double y1, Bitmap bmp2, double x2, double y2)
    {
      __sklib_ptr __skparam__bmp1;
      double __skparam__x1;
      double __skparam__y1;
      __sklib_ptr __skparam__bmp2;
      double __skparam__x2;
      double __skparam__y2;
      int __skreturn;
      __skparam__bmp1 = __skadapter__to_sklib_bitmap(bmp1);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__bmp2 = __skadapter__to_sklib_bitmap(bmp2);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skreturn = __sklib__bitmap_collision__bitmap__double__double__bitmap__double__double(__skparam__bmp1, __skparam__x1, __skparam__y1, __skparam__bmp2, __skparam__x2, __skparam__y2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Check if two bitmaps collide.
    /// </summary>
    /// <param name="bmp1"> The first bitmap</param>
    /// <param name="pt1"> The point where bitmap 1 is drawn</param>
    /// <param name="bmp2"> The second bitmap</param>
    /// <param name="pt2"> The point where bitmap 2 is drawn</param>
    /// <returns>True if pixels in the two bitmaps would collide/overlap</returns>
    public static bool BitmapCollision(Bitmap bmp1, Point2D pt1, Bitmap bmp2, Point2D pt2)
    {
      __sklib_ptr __skparam__bmp1;
      __sklib_point_2d __skparam__pt1;
      __sklib_ptr __skparam__bmp2;
      __sklib_point_2d __skparam__pt2;
      int __skreturn;
      __skparam__bmp1 = __skadapter__to_sklib_bitmap(bmp1);
      __skparam__pt1 = __skadapter__to_sklib_point_2d(pt1);
      __skparam__bmp2 = __skadapter__to_sklib_bitmap(bmp2);
      __skparam__pt2 = __skadapter__to_sklib_point_2d(pt2);
      __skreturn = __sklib__bitmap_collision__bitmap__point_2d_ref__bitmap__point_2d_ref(__skparam__bmp1, __skparam__pt1, __skparam__bmp2, __skparam__pt2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Check if two bitmaps collide, based on their cell and transform matricies.
    /// </summary>
    /// <param name="bmp1"> The first bitmap</param>
    /// <param name="cell1"> The cell of the first bitmap.</param>
    /// <param name="matrix1"> The transformation for the first matrix</param>
    /// <param name="bmp2"> The second bitmap</param>
    /// <param name="cell2"> The cell of the second bitmap.</param>
    /// <param name="matrix2"> The transformation for the second matrix</param>
    /// <returns>True if pixels in the two bitmaps would collide/overlap</returns>
    public static bool BitmapCollision(Bitmap bmp1, int cell1, Matrix2D matrix1, Bitmap bmp2, int cell2, Matrix2D matrix2)
    {
      __sklib_ptr __skparam__bmp1;
      int __skparam__cell1;
      __sklib_matrix_2d __skparam__matrix1;
      __sklib_ptr __skparam__bmp2;
      int __skparam__cell2;
      __sklib_matrix_2d __skparam__matrix2;
      int __skreturn;
      __skparam__bmp1 = __skadapter__to_sklib_bitmap(bmp1);
      __skparam__cell1 = __skadapter__to_sklib_int(cell1);
      __skparam__matrix1 = __skadapter__to_sklib_matrix_2d(matrix1);
      __skparam__bmp2 = __skadapter__to_sklib_bitmap(bmp2);
      __skparam__cell2 = __skadapter__to_sklib_int(cell2);
      __skparam__matrix2 = __skadapter__to_sklib_matrix_2d(matrix2);
      __skreturn = __sklib__bitmap_collision__bitmap__int__matrix_2d_ref__bitmap__int__matrix_2d_ref(__skparam__bmp1, __skparam__cell1, __skparam__matrix1, __skparam__bmp2, __skparam__cell2, __skparam__matrix2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Check if two bitmaps collide.
    /// </summary>
    /// <param name="bmp1"> The first bitmap</param>
    /// <param name="cell1"> The cell of the first bitmap.</param>
    /// <param name="pt1"> The point where bitmap 1 is drawn</param>
    /// <param name="bmp2"> The second bitmap</param>
    /// <param name="cell2"> The cell of the second bitmap.</param>
    /// <param name="pt2"> The point where bitmap 2 is drawn</param>
    /// <returns>True if pixels in the two bitmaps would collide/overlap</returns>
    public static bool BitmapCollision(Bitmap bmp1, int cell1, Point2D pt1, Bitmap bmp2, int cell2, Point2D pt2)
    {
      __sklib_ptr __skparam__bmp1;
      int __skparam__cell1;
      __sklib_point_2d __skparam__pt1;
      __sklib_ptr __skparam__bmp2;
      int __skparam__cell2;
      __sklib_point_2d __skparam__pt2;
      int __skreturn;
      __skparam__bmp1 = __skadapter__to_sklib_bitmap(bmp1);
      __skparam__cell1 = __skadapter__to_sklib_int(cell1);
      __skparam__pt1 = __skadapter__to_sklib_point_2d(pt1);
      __skparam__bmp2 = __skadapter__to_sklib_bitmap(bmp2);
      __skparam__cell2 = __skadapter__to_sklib_int(cell2);
      __skparam__pt2 = __skadapter__to_sklib_point_2d(pt2);
      __skreturn = __sklib__bitmap_collision__bitmap__int__point_2d_ref__bitmap__int__point_2d_ref(__skparam__bmp1, __skparam__cell1, __skparam__pt1, __skparam__bmp2, __skparam__cell2, __skparam__pt2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Check if two bitmaps collide.
    /// </summary>
    /// <param name="bmp1"> The first bitmap</param>
    /// <param name="cell1"> The cell of the first bitmap.</param>
    /// <param name="x1"> The x location where the first bitmap is drawn</param>
    /// <param name="y1"> The y location where the first bitmap is drawn</param>
    /// <param name="bmp2"> The second bitmap</param>
    /// <param name="cell2"> The cell of the second bitmap.</param>
    /// <param name="x2"> The x location where the second bitmap is drawn</param>
    /// <param name="y2"> The y location where the second bitmap is drawn</param>
    /// <returns>True if pixels in the two bitmaps would collide/overlap</returns>
    public static bool BitmapCollision(Bitmap bmp1, int cell1, double x1, double y1, Bitmap bmp2, int cell2, double x2, double y2)
    {
      __sklib_ptr __skparam__bmp1;
      int __skparam__cell1;
      double __skparam__x1;
      double __skparam__y1;
      __sklib_ptr __skparam__bmp2;
      int __skparam__cell2;
      double __skparam__x2;
      double __skparam__y2;
      int __skreturn;
      __skparam__bmp1 = __skadapter__to_sklib_bitmap(bmp1);
      __skparam__cell1 = __skadapter__to_sklib_int(cell1);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__bmp2 = __skadapter__to_sklib_bitmap(bmp2);
      __skparam__cell2 = __skadapter__to_sklib_int(cell2);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skreturn = __sklib__bitmap_collision__bitmap__int__double__double__bitmap__int__double__double(__skparam__bmp1, __skparam__cell1, __skparam__x1, __skparam__y1, __skparam__bmp2, __skparam__cell2, __skparam__x2, __skparam__y2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap drawn using the passed in translation matrix would draw a pixel at the passed in point. Use to check collisions between a point and a bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap to test.</param>
    /// <param name="translation"> The translation matrix that represents the position, scale, and rotation of the bitmap when it is drawn.</param>
    /// <param name="pt"> The point in the resulting drawing that is being tested.</param>
    /// <returns>True if drawing the bitmap, using the passed in translation, will draw a pixel at the indicated point.</returns>
    public static bool BitmapPointCollision(Bitmap bmp, Matrix2D translation, Point2D pt)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_matrix_2d __skparam__translation;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__translation = __skadapter__to_sklib_matrix_2d(translation);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__bitmap_point_collision__bitmap__matrix_2d_ref__point_2d_ref(__skparam__bmp, __skparam__translation, __skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap drawn at the `bmp_pt` point would draw a pixel at point `pt`. Use to check collisions between a point and a bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap to test.</param>
    /// <param name="bmpPt"> The point where the bitmap is drawn.</param>
    /// <param name="pt"> The point in the resulting drawing that is being tested.</param>
    /// <returns>True if drawing the bitmap, at `bmp_pt`, will draw a pixel at the indicated point (`pt`).</returns>
    public static bool BitmapPointCollision(Bitmap bmp, Point2D bmpPt, Point2D pt)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skparam__bmp_pt;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__bmp_pt = __skadapter__to_sklib_point_2d(bmpPt);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__bitmap_point_collision__bitmap__point_2d_ref__point_2d_ref(__skparam__bmp, __skparam__bmp_pt, __skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap drawn at x,y would draw a pixel at the passed in point. Use to check collisions between a point and a bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap to test.</param>
    /// <param name="bmpX"> The x location where the bitmap is drawn</param>
    /// <param name="bmpY"> The y location where the bitmap is drawn</param>
    /// <param name="x"> The x location of the point to test</param>
    /// <param name="y"> The y location of the point to test</param>
    /// <returns>True if drawing the bitmap, at the indicated location, will draw a pixel at the indicated point.</returns>
    public static bool BitmapPointCollision(Bitmap bmp, double bmpX, double bmpY, double x, double y)
    {
      __sklib_ptr __skparam__bmp;
      double __skparam__bmp_x;
      double __skparam__bmp_y;
      double __skparam__x;
      double __skparam__y;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__bmp_x = __skadapter__to_sklib_double(bmpX);
      __skparam__bmp_y = __skadapter__to_sklib_double(bmpY);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__bitmap_point_collision__bitmap__double__double__double__double(__skparam__bmp, __skparam__bmp_x, __skparam__bmp_y, __skparam__x, __skparam__y);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn using the passed in translation matrix would draw a pixel at the passed in point.
    /// </summary>
    /// <param name="bmp"> The bitmap to test.</param>
    /// <param name="cell"> The cell of the bitmap to check.</param>
    /// <param name="translation"> The translation matrix that represents the position, scale, and rotation of the bitmap when it is drawn.</param>
    /// <param name="pt"> The point in the resulting drawing that is being tested.</param>
    /// <returns>True if drawing the bitmap, using the passed in translation, will draw a pixel at the indicated point.</returns>
    public static bool BitmapPointCollision(Bitmap bmp, int cell, Matrix2D translation, Point2D pt)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_matrix_2d __skparam__translation;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__translation = __skadapter__to_sklib_matrix_2d(translation);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__bitmap_point_collision__bitmap__int__matrix_2d_ref__point_2d_ref(__skparam__bmp, __skparam__cell, __skparam__translation, __skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a cell of a bitmap drawn at x,y would draw a pixel at the passed in point. Use to check collisions between a point and a bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to test</param>
    /// <param name="bmpPt"> The point where the bitmap is drawn.</param>
    /// <param name="pt"> The point in the resulting drawing that is being tested.</param>
    /// <returns>True if drawing the bitmap cell, at the indicated location, will draw a pixel at the indicated point.</returns>
    public static bool BitmapPointCollision(Bitmap bmp, int cell, Point2D bmpPt, Point2D pt)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_point_2d __skparam__bmp_pt;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__bmp_pt = __skadapter__to_sklib_point_2d(bmpPt);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__bitmap_point_collision__bitmap__int__point_2d_ref__point_2d_ref(__skparam__bmp, __skparam__cell, __skparam__bmp_pt, __skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a cell of a bitmap drawn at x,y would draw a pixel at the passed in point. Use to check collisions between a point and a bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to test</param>
    /// <param name="bmpX"> The x location where the bitmap is drawn</param>
    /// <param name="bmpY"> The y location where the bitmap is drawn</param>
    /// <param name="x"> The x location of the point to test</param>
    /// <param name="y"> The y location of the point to test</param>
    /// <returns>True if drawing the bitmap cell, at the indicated location, will draw a pixel at the indicated point.</returns>
    public static bool BitmapPointCollision(Bitmap bmp, int cell, double bmpX, double bmpY, double x, double y)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      double __skparam__bmp_x;
      double __skparam__bmp_y;
      double __skparam__x;
      double __skparam__y;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__bmp_x = __skadapter__to_sklib_double(bmpX);
      __skparam__bmp_y = __skadapter__to_sklib_double(bmpY);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__bitmap_point_collision__bitmap__int__double__double__double__double(__skparam__bmp, __skparam__cell, __skparam__bmp_x, __skparam__bmp_y, __skparam__x, __skparam__y);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap drawn at `pt` would intersect with a quad.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="q"> The quad to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `q` when drawn.</returns>
    public static bool BitmapQuadCollision(Bitmap bmp, Point2D pt, Quad q)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skparam__pt;
      __sklib_quad __skparam__q;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skreturn = __sklib__bitmap_quad_collision__bitmap__point_2d_ref__quad_ref(__skparam__bmp, __skparam__pt, __skparam__q);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap drawn at `x`, `y` would intersect with a quad.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="q"> The quad to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `q` when drawn.</returns>
    public static bool BitmapQuadCollision(Bitmap bmp, double x, double y, Quad q)
    {
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __sklib_quad __skparam__q;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skreturn = __sklib__bitmap_quad_collision__bitmap__double__double__quad_ref(__skparam__bmp, __skparam__x, __skparam__y, __skparam__q);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn using a passed in translation, will intersect with a quad. You can use this to detect collisions between bitmaps and quads.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="translation"> The matrix used to transfrom the bitmap when drawing</param>
    /// <param name="q"> The quad to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `q` when drawn.</returns>
    public static bool BitmapQuadCollision(Bitmap bmp, int cell, Matrix2D translation, Quad q)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_matrix_2d __skparam__translation;
      __sklib_quad __skparam__q;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__translation = __skadapter__to_sklib_matrix_2d(translation);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skreturn = __sklib__bitmap_quad_collision__bitmap__int__matrix_2d_ref__quad_ref(__skparam__bmp, __skparam__cell, __skparam__translation, __skparam__q);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn at `pt` would intersect with a quad.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="q"> The quad to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `q` when drawn.</returns>
    public static bool BitmapQuadCollision(Bitmap bmp, int cell, Point2D pt, Quad q)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_point_2d __skparam__pt;
      __sklib_quad __skparam__q;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skreturn = __sklib__bitmap_quad_collision__bitmap__int__point_2d_ref__quad_ref(__skparam__bmp, __skparam__cell, __skparam__pt, __skparam__q);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn at `x`, `y` would intersect with a quad.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="q"> The quad to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `q` when drawn.</returns>
    public static bool BitmapQuadCollision(Bitmap bmp, int cell, double x, double y, Quad q)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      double __skparam__x;
      double __skparam__y;
      __sklib_quad __skparam__q;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skreturn = __sklib__bitmap_quad_collision__bitmap__int__double__double__quad_ref(__skparam__bmp, __skparam__cell, __skparam__x, __skparam__y, __skparam__q);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap drawn at `pt` would intersect with a ray.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="origin"> The origin of the ray</param>
    /// <param name="heading"> The heading of the ray</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with the ray when drawn.</returns>
    public static bool BitmapRayCollision(Bitmap bmp, Point2D pt, Point2D origin, Vector2D heading)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skparam__pt;
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skreturn = __sklib__bitmap_ray_collision__bitmap__point_2d_ref__point_2d_ref__vector_2d_ref(__skparam__bmp, __skparam__pt, __skparam__origin, __skparam__heading);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap drawn at `x`, `y` would intersect with a ray.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="origin"> The origin of the ray</param>
    /// <param name="heading"> The heading of the ray</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with the ray when drawn.</returns>
    public static bool BitmapRayCollision(Bitmap bmp, double x, double y, Point2D origin, Vector2D heading)
    {
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skreturn = __sklib__bitmap_ray_collision__bitmap__double__double__point_2d_ref__vector_2d_ref(__skparam__bmp, __skparam__x, __skparam__y, __skparam__origin, __skparam__heading);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn using a passed in translation, will intersect with a ray. You can use this to detect collisions between bitmaps and rays.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="translation"> The matrix used to transfrom the bitmap when drawing</param>
    /// <param name="origin"> The origin of the ray</param>
    /// <param name="heading"> The heading of the ray</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with the ray when drawn.</returns>
    public static bool BitmapRayCollision(Bitmap bmp, int cell, Matrix2D translation, Point2D origin, Vector2D heading)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_matrix_2d __skparam__translation;
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__translation = __skadapter__to_sklib_matrix_2d(translation);
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skreturn = __sklib__bitmap_ray_collision__bitmap__int__matrix_2d_ref__point_2d_ref__vector_2d_ref(__skparam__bmp, __skparam__cell, __skparam__translation, __skparam__origin, __skparam__heading);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn at `pt` would intersect with a ray.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="origin"> The origin of the ray</param>
    /// <param name="heading"> The heading of the ray</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with the ray when drawn.</returns>
    public static bool BitmapRayCollision(Bitmap bmp, int cell, Point2D pt, Point2D origin, Vector2D heading)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_point_2d __skparam__pt;
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skreturn = __sklib__bitmap_ray_collision__bitmap__int__point_2d_ref__point_2d_ref__vector_2d_ref(__skparam__bmp, __skparam__cell, __skparam__pt, __skparam__origin, __skparam__heading);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn at `x`, `y` would intersect with a ray.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="origin"> The origin of the ray</param>
    /// <param name="heading"> The heading of the ray</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with the ray when drawn.</returns>
    public static bool BitmapRayCollision(Bitmap bmp, int cell, double x, double y, Point2D origin, Vector2D heading)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      double __skparam__x;
      double __skparam__y;
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skreturn = __sklib__bitmap_ray_collision__bitmap__int__double__double__point_2d_ref__vector_2d_ref(__skparam__bmp, __skparam__cell, __skparam__x, __skparam__y, __skparam__origin, __skparam__heading);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap drawn at `pt` would intersect with a rectangle.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="rect"> The rectangle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `rect` when drawn.</returns>
    public static bool BitmapRectangleCollision(Bitmap bmp, Point2D pt, Rectangle rect)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skparam__pt;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__bitmap_rectangle_collision__bitmap__point_2d_ref__rectangle_ref(__skparam__bmp, __skparam__pt, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap drawn at `x`, `y` would intersect with a rectangle.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="rect"> The rectangle to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `rect` when drawn.</returns>
    public static bool BitmapRectangleCollision(Bitmap bmp, double x, double y, Rectangle rect)
    {
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__bitmap_rectangle_collision__bitmap__double__double__rectangle_ref(__skparam__bmp, __skparam__x, __skparam__y, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn using a passed in translation, will intersect with a rectangle. You can use this to detect collisions between bitmaps and rectangles.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="translation"> The matrix used to transfrom the bitmap when drawing</param>
    /// <param name="rect"> The rectangle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `rect` when drawn.</returns>
    public static bool BitmapRectangleCollision(Bitmap bmp, int cell, Matrix2D translation, Rectangle rect)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_matrix_2d __skparam__translation;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__translation = __skadapter__to_sklib_matrix_2d(translation);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__bitmap_rectangle_collision__bitmap__int__matrix_2d_ref__rectangle_ref(__skparam__bmp, __skparam__cell, __skparam__translation, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn at `pt` would intersect with a rectangle.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="rect"> The rectangle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `rect` when drawn.</returns>
    public static bool BitmapRectangleCollision(Bitmap bmp, int cell, Point2D pt, Rectangle rect)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_point_2d __skparam__pt;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__bitmap_rectangle_collision__bitmap__int__point_2d_ref__rectangle_ref(__skparam__bmp, __skparam__cell, __skparam__pt, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a cell of the bitmap drawn at `x`, `y` would intersect with a rectangle.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="rect"> The rectangle to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `rect` when drawn.</returns>
    public static bool BitmapRectangleCollision(Bitmap bmp, int cell, double x, double y, Rectangle rect)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      double __skparam__x;
      double __skparam__y;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__bitmap_rectangle_collision__bitmap__int__double__double__rectangle_ref(__skparam__bmp, __skparam__cell, __skparam__x, __skparam__y, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap drawn at `pt` would intersect with a triangle.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="tri"> The triangle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `tri` when drawn.</returns>
    public static bool BitmapTriangleCollision(Bitmap bmp, Point2D pt, Triangle tri)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skparam__pt;
      __sklib_triangle __skparam__tri;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skreturn = __sklib__bitmap_triangle_collision__bitmap__point_2d_ref__triangle_ref(__skparam__bmp, __skparam__pt, __skparam__tri);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap drawn at `x`, `y` would intersect with a triangle.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="tri"> The triangle to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `tri` when drawn.</returns>
    public static bool BitmapTriangleCollision(Bitmap bmp, double x, double y, Triangle tri)
    {
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __sklib_triangle __skparam__tri;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skreturn = __sklib__bitmap_triangle_collision__bitmap__double__double__triangle_ref(__skparam__bmp, __skparam__x, __skparam__y, __skparam__tri);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn using a passed in translation, will intersect with a triangle. You can use this to detect collisions between bitmaps and triangles.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="translation"> The matrix used to transfrom the bitmap when drawing</param>
    /// <param name="tri"> The triangle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `tri` when drawn.</returns>
    public static bool BitmapTriangleCollision(Bitmap bmp, int cell, Matrix2D translation, Triangle tri)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_matrix_2d __skparam__translation;
      __sklib_triangle __skparam__tri;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__translation = __skadapter__to_sklib_matrix_2d(translation);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skreturn = __sklib__bitmap_triangle_collision__bitmap__int__matrix_2d_ref__triangle_ref(__skparam__bmp, __skparam__cell, __skparam__translation, __skparam__tri);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn at `pt` would intersect with a triangle.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="tri"> The triangle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `tri` when drawn.</returns>
    public static bool BitmapTriangleCollision(Bitmap bmp, int cell, Point2D pt, Triangle tri)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_point_2d __skparam__pt;
      __sklib_triangle __skparam__tri;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skreturn = __sklib__bitmap_triangle_collision__bitmap__int__point_2d_ref__triangle_ref(__skparam__bmp, __skparam__cell, __skparam__pt, __skparam__tri);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a bitmap cell drawn at `x`, `y` would intersect with a triangle.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="tri"> The triangle to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `tri` when drawn.</returns>
    public static bool BitmapTriangleCollision(Bitmap bmp, int cell, double x, double y, Triangle tri)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      double __skparam__x;
      double __skparam__y;
      __sklib_triangle __skparam__tri;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skreturn = __sklib__bitmap_triangle_collision__bitmap__int__double__double__triangle_ref(__skparam__bmp, __skparam__cell, __skparam__x, __skparam__y, __skparam__tri);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a collider quad and a collidee quad relative to the collider quad. If the quads are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The quad that is colliding</param>
    /// <param name="collidee"> The quad that is being collided with</param>
    /// <returns>The direction of the collision relative to the collider quad, expressed as a unit vector. If the quads are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Quad collider, Quad collidee)
    {
      __sklib_quad __skparam__collider;
      __sklib_quad __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_quad(collider);
      __skparam__collidee = __skadapter__to_sklib_quad(collidee);
      __skreturn = __sklib__calculate_collision_direction__quad_ref__quad_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a collider circle and a collidee circle relative to the collider circle. If the circles are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The circle that is colliding</param>
    /// <param name="collidee"> The circle that is being collided with</param>
    /// <returns>The direction of the collision relative to the collider circle, expressed as a unit vector. If the circles are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Circle collider, Circle collidee)
    {
      __sklib_circle __skparam__collider;
      __sklib_circle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_circle(collider);
      __skparam__collidee = __skadapter__to_sklib_circle(collidee);
      __skreturn = __sklib__calculate_collision_direction__circle_ref__circle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a circle and a quad relative to the circle. If the circle and quad are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The circle that is colliding</param>
    /// <param name="collidee"> The quad that is being collided with</param>
    /// <returns>The direction of the collision relative to the circle, expressed as a unit vector. If the circle and quad are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Circle collider, Quad collidee)
    {
      __sklib_circle __skparam__collider;
      __sklib_quad __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_circle(collider);
      __skparam__collidee = __skadapter__to_sklib_quad(collidee);
      __skreturn = __sklib__calculate_collision_direction__circle_ref__quad_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a circle and a rectangle relative to the circle. If the circle and rectangle are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The circle that is colliding</param>
    /// <param name="collidee"> The rectangle that is being collided with</param>
    /// <returns>The direction of the collision relative to the circle, expressed as a unit vector. If the circle and rectangle are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Circle collider, Rectangle collidee)
    {
      __sklib_circle __skparam__collider;
      __sklib_rectangle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_circle(collider);
      __skparam__collidee = __skadapter__to_sklib_rectangle(collidee);
      __skreturn = __sklib__calculate_collision_direction__circle_ref__rectangle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a circle and a sprite relative to the circle. If the circle and sprite are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The circle that is colliding</param>
    /// <param name="collidee"> The sprite that is being collided with</param>
    /// <returns>The direction of the collision relative to the circle, expressed as a unit vector. If the circle and sprite are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Circle collider, Sprite collidee)
    {
      __sklib_circle __skparam__collider;
      __sklib_ptr __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_circle(collider);
      __skparam__collidee = __skadapter__to_sklib_sprite(collidee);
      __skreturn = __sklib__calculate_collision_direction__circle_ref__sprite(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a circle and a triangle relative to the circle. If the circle and triangle are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The circle that is colliding</param>
    /// <param name="collidee"> The triangle that is being collided with</param>
    /// <returns>The direction of the collision relative to the circle, expressed as a unit vector. If the circle and triangle are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Circle collider, Triangle collidee)
    {
      __sklib_circle __skparam__collider;
      __sklib_triangle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_circle(collider);
      __skparam__collidee = __skadapter__to_sklib_triangle(collidee);
      __skreturn = __sklib__calculate_collision_direction__circle_ref__triangle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a quad and a circle relative to the quad. If the quad and circle are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The quad that is colliding</param>
    /// <param name="collidee"> The circle that is being collided with</param>
    /// <returns>The direction of the collision relative to the quad, expressed as a unit vector. If the quad and circle are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Quad collider, Circle collidee)
    {
      __sklib_quad __skparam__collider;
      __sklib_circle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_quad(collider);
      __skparam__collidee = __skadapter__to_sklib_circle(collidee);
      __skreturn = __sklib__calculate_collision_direction__quad_ref__circle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a quad and a rectangle relative to the quad. If the quad and rectangle are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The quad that is colliding</param>
    /// <param name="collidee"> The rectangle that is being collided with</param>
    /// <returns>The direction of the collision relative to the quad, expressed as a unit vector. If the quad and rectangle are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Quad collider, Rectangle collidee)
    {
      __sklib_quad __skparam__collider;
      __sklib_rectangle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_quad(collider);
      __skparam__collidee = __skadapter__to_sklib_rectangle(collidee);
      __skreturn = __sklib__calculate_collision_direction__quad_ref__rectangle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a quad and a sprite relative to the quad. If the quad and sprite are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The quad that is colliding</param>
    /// <param name="collidee"> The sprite that is being collided with</param>
    /// <returns>The direction of the collision relative to the quad, expressed as a unit vector. If the quad and sprite are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Quad collider, Sprite collidee)
    {
      __sklib_quad __skparam__collider;
      __sklib_ptr __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_quad(collider);
      __skparam__collidee = __skadapter__to_sklib_sprite(collidee);
      __skreturn = __sklib__calculate_collision_direction__quad_ref__sprite(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a quad and a triangle relative to the quad. If the quad and triangle are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The quad that is colliding</param>
    /// <param name="collidee"> The triangle that is being collided with</param>
    /// <returns>The direction of the collision relative to the quad, expressed as a unit vector. If the quad and triangle are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Quad collider, Triangle collidee)
    {
      __sklib_quad __skparam__collider;
      __sklib_triangle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_quad(collider);
      __skparam__collidee = __skadapter__to_sklib_triangle(collidee);
      __skreturn = __sklib__calculate_collision_direction__quad_ref__triangle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a rectangle and a circle relative to the rectangle. If the rectangle and sprite are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The rectangle that is colliding</param>
    /// <param name="collidee"> The circle that is being collided with</param>
    /// <returns>The direction of the collision relative to the rectangle, expressed as a unit vector. If the rectangle and circle are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Rectangle collider, Circle collidee)
    {
      __sklib_rectangle __skparam__collider;
      __sklib_circle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_rectangle(collider);
      __skparam__collidee = __skadapter__to_sklib_circle(collidee);
      __skreturn = __sklib__calculate_collision_direction__rectangle_ref__circle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a rectangle and a quad relative to the rectangle. If the rectangle and sprite are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The rectangle that is colliding</param>
    /// <param name="collidee"> The quad that is being collided with</param>
    /// <returns>The direction of the collision relative to the rectangle, expressed as a unit vector. If the rectangle and quad are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Rectangle collider, Quad collidee)
    {
      __sklib_rectangle __skparam__collider;
      __sklib_quad __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_rectangle(collider);
      __skparam__collidee = __skadapter__to_sklib_quad(collidee);
      __skreturn = __sklib__calculate_collision_direction__rectangle_ref__quad_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a collider rectangle and a collidee rectangle relative to the collider rectangle. If the rectangles are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The rectangle that is colliding</param>
    /// <param name="collidee"> The rectangle that is being collided with</param>
    /// <returns>The direction of the collision relative to the collider rectangle, expressed as a unit vector. If the rectangles are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Rectangle collider, Rectangle collidee)
    {
      __sklib_rectangle __skparam__collider;
      __sklib_rectangle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_rectangle(collider);
      __skparam__collidee = __skadapter__to_sklib_rectangle(collidee);
      __skreturn = __sklib__calculate_collision_direction__rectangle_ref__rectangle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a rectangle and a sprite relative to the rectangle. If the rectangle and sprite are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The rectangle that is colliding</param>
    /// <param name="collidee"> The sprite that is being collided with</param>
    /// <returns>The direction of the collision relative to the rectangle, expressed as a unit vector. If the rectangle and sprite are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Rectangle collider, Sprite collidee)
    {
      __sklib_rectangle __skparam__collider;
      __sklib_ptr __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_rectangle(collider);
      __skparam__collidee = __skadapter__to_sklib_sprite(collidee);
      __skreturn = __sklib__calculate_collision_direction__rectangle_ref__sprite(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a rectangle and a triangle relative to the rectangle. If the rectangle and sprite are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The rectangle that is colliding</param>
    /// <param name="collidee"> The triangle that is being collided with</param>
    /// <returns>The direction of the collision relative to the rectangle, expressed as a unit vector. If the rectangle and triangle are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Rectangle collider, Triangle collidee)
    {
      __sklib_rectangle __skparam__collider;
      __sklib_triangle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_rectangle(collider);
      __skparam__collidee = __skadapter__to_sklib_triangle(collidee);
      __skreturn = __sklib__calculate_collision_direction__rectangle_ref__triangle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a sprite and a circle relative to the sprite. If the sprite and circle are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The sprite that is colliding</param>
    /// <param name="collidee"> The circle that is being collided with</param>
    /// <returns>The direction of the collision relative to the sprite, expressed as a unit vector. If the sprite and circle are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Sprite collider, Circle collidee)
    {
      __sklib_ptr __skparam__collider;
      __sklib_circle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_sprite(collider);
      __skparam__collidee = __skadapter__to_sklib_circle(collidee);
      __skreturn = __sklib__calculate_collision_direction__sprite__circle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a sprite and a quad relative to the sprite. If the sprite and quad are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The sprite that is colliding</param>
    /// <param name="collidee"> The quad that is being collided with</param>
    /// <returns>The direction of the collision relative to the sprite, expressed as a unit vector. If the sprite and quad are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Sprite collider, Quad collidee)
    {
      __sklib_ptr __skparam__collider;
      __sklib_quad __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_sprite(collider);
      __skparam__collidee = __skadapter__to_sklib_quad(collidee);
      __skreturn = __sklib__calculate_collision_direction__sprite__quad_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a sprite and a rectangle relative to the sprite. If the sprite and rectangle are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The sprite that is colliding</param>
    /// <param name="collidee"> The rectangle that is being collided with</param>
    /// <returns>The direction of the collision relative to the sprite, expressed as a unit vector. If the sprite and rectangle are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Sprite collider, Rectangle collidee)
    {
      __sklib_ptr __skparam__collider;
      __sklib_rectangle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_sprite(collider);
      __skparam__collidee = __skadapter__to_sklib_rectangle(collidee);
      __skreturn = __sklib__calculate_collision_direction__sprite__rectangle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between two sprites relative to the collider sprite. If the sprites are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The sprite that is colliding</param>
    /// <param name="collidee"> The sprite that is being collided with</param>
    /// <returns>The direction of the collision relative to the collider sprite, expressed as a unit vector. If the sprites are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Sprite collider, Sprite collidee)
    {
      __sklib_ptr __skparam__collider;
      __sklib_ptr __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_sprite(collider);
      __skparam__collidee = __skadapter__to_sklib_sprite(collidee);
      __skreturn = __sklib__calculate_collision_direction__sprite__sprite(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a sprite and a triangle relative to the sprite. If the sprite and triangle are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The sprite that is colliding</param>
    /// <param name="collidee"> The triangle that is being collided with</param>
    /// <returns>The direction of the collision relative to the sprite, expressed as a unit vector. If the sprite and triangle are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Sprite collider, Triangle collidee)
    {
      __sklib_ptr __skparam__collider;
      __sklib_triangle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_sprite(collider);
      __skparam__collidee = __skadapter__to_sklib_triangle(collidee);
      __skreturn = __sklib__calculate_collision_direction__sprite__triangle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a triangle and a circle relative to the triangle. If the triangle and circle are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The triangle that is colliding</param>
    /// <param name="collidee"> The circle that is being collided with</param>
    /// <returns>The direction of the collision relative to the triangle, expressed as a unit vector. If the triangle and circle are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Triangle collider, Circle collidee)
    {
      __sklib_triangle __skparam__collider;
      __sklib_circle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_triangle(collider);
      __skparam__collidee = __skadapter__to_sklib_circle(collidee);
      __skreturn = __sklib__calculate_collision_direction__triangle_ref__circle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a triangle and a quad relative to the triangle. If the triangle and quad are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The triangle that is colliding</param>
    /// <param name="collidee"> The quad that is being collided with</param>
    /// <returns>The direction of the collision relative to the triangle, expressed as a unit vector. If the triangle and quad are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Triangle collider, Quad collidee)
    {
      __sklib_triangle __skparam__collider;
      __sklib_quad __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_triangle(collider);
      __skparam__collidee = __skadapter__to_sklib_quad(collidee);
      __skreturn = __sklib__calculate_collision_direction__triangle_ref__quad_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a triangle and a rectangle relative to the triangle. If the triangle and rectangle are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The triangle that is colliding</param>
    /// <param name="collidee"> The rectangle that is being collided with</param>
    /// <returns>The direction of the collision relative to the triangle, expressed as a unit vector. If the triangle and rectangle are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Triangle collider, Rectangle collidee)
    {
      __sklib_triangle __skparam__collider;
      __sklib_rectangle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_triangle(collider);
      __skparam__collidee = __skadapter__to_sklib_rectangle(collidee);
      __skreturn = __sklib__calculate_collision_direction__triangle_ref__rectangle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a triangle and a sprite relative to the triangle. If the triangle and sprite are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The triangle that is colliding</param>
    /// <param name="collidee"> The sprite that is being collided with</param>
    /// <returns>The direction of the collision relative to the triangle, expressed as a unit vector. If the triangle and sprite are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Triangle collider, Sprite collidee)
    {
      __sklib_triangle __skparam__collider;
      __sklib_ptr __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_triangle(collider);
      __skparam__collidee = __skadapter__to_sklib_sprite(collidee);
      __skreturn = __sklib__calculate_collision_direction__triangle_ref__sprite(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the direction of the collision between a collider triangle and a collidee triangle relative to the collider triangle. If the triangles are not colliding, this function will return a zero vector.
    /// </summary>
    /// <param name="collider"> The triangle that is colliding</param>
    /// <param name="collidee"> The triangle that is being collided with</param>
    /// <returns>The direction of the collision relative to the collider triangle, expressed as a unit vector. If the triangles are not colliding, this function will return a zero vector.</returns>
    public static Vector2D CalculateCollisionDirection(Triangle collider, Triangle collidee)
    {
      __sklib_triangle __skparam__collider;
      __sklib_triangle __skparam__collidee;
      __sklib_vector_2d __skreturn;
      __skparam__collider = __skadapter__to_sklib_triangle(collider);
      __skparam__collidee = __skadapter__to_sklib_triangle(collidee);
      __skreturn = __sklib__calculate_collision_direction__triangle_ref__triangle_ref(__skparam__collider, __skparam__collidee);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a collider quad and a collidee quad by moving the collider quad to the edge of the collidee quad. The direction of the resolution is determined by the `direction` parameter. If the quads are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The quad which will be altered if there is a collision</param>
    /// <param name="collidee"> The quad which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the collider quad, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the quads are colliding and the collision was resolved, false if the quads are not colliding</returns>
    public static bool ResolveCollision(ref Quad collider, Quad collidee, Vector2D direction)
    {
      __sklib_quad __skparam__collider;
      __sklib_quad __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_quad(collider);
      __skparam__collidee = __skadapter__to_sklib_quad(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__quad_ref__quad_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_quad(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a collider circle and a collidee circle by moving the collider circle to the edge of the collidee circle. The direction of the resolution is determined by the `direction` parameter. If the circles are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The circle which will be altered if there is a collision</param>
    /// <param name="collidee"> The circle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the collider circle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the circles are colliding and the collision was resolved, false if the circles are not colliding</returns>
    public static bool ResolveCollision(ref Circle collider, Circle collidee, Vector2D direction)
    {
      __sklib_circle __skparam__collider;
      __sklib_circle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_circle(collider);
      __skparam__collidee = __skadapter__to_sklib_circle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__circle_ref__circle_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_circle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a circle and a quad by moving the circle to the edge of the quad. The direction of the resolution is determined by the `direction` parameter. If the circle and quad are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The circle which will be altered if there is a collision</param>
    /// <param name="collidee"> The quad which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the circle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the circle and quad are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Circle collider, Quad collidee, Vector2D direction)
    {
      __sklib_circle __skparam__collider;
      __sklib_quad __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_circle(collider);
      __skparam__collidee = __skadapter__to_sklib_quad(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__circle_ref__quad_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_circle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a circle and a rectangle by moving the circle to the edge of the rectangle. The direction of the resolution is determined by the `direction` parameter. If the circle and rectangle are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The circle which will be altered if there is a collision</param>
    /// <param name="collidee"> The rectangle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the circle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the circle and rectangle are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Circle collider, Rectangle collidee, Vector2D direction)
    {
      __sklib_circle __skparam__collider;
      __sklib_rectangle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_circle(collider);
      __skparam__collidee = __skadapter__to_sklib_rectangle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__circle_ref__rectangle_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_circle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a circle and a sprite by moving the circle to the edge of the sprite. The direction of the resolution is determined by the `direction` parameter. If the circle and sprite are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The circle which will be altered if there is a collision</param>
    /// <param name="collidee"> The sprite which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the circle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the circle and sprite are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Circle collider, Sprite collidee, Vector2D direction)
    {
      __sklib_circle __skparam__collider;
      __sklib_ptr __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_circle(collider);
      __skparam__collidee = __skadapter__to_sklib_sprite(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__circle_ref__sprite__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_circle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a circle and a triangle by moving the circle to the edge of the triangle. The direction of the resolution is determined by the `direction` parameter. If the circle and triangle are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The circle which will be altered if there is a collision</param>
    /// <param name="collidee"> The triangle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the circle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the circle and triangle are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Circle collider, Triangle collidee, Vector2D direction)
    {
      __sklib_circle __skparam__collider;
      __sklib_triangle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_circle(collider);
      __skparam__collidee = __skadapter__to_sklib_triangle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__circle_ref__triangle_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_circle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a quad and a circle by moving the quad to the edge of the circle. The direction of the resolution is determined by the `direction` parameter. If the quad and circle are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The quad which will be altered if there is a collision</param>
    /// <param name="collidee"> The circle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the quad, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the quad and circle are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Quad collider, Circle collidee, Vector2D direction)
    {
      __sklib_quad __skparam__collider;
      __sklib_circle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_quad(collider);
      __skparam__collidee = __skadapter__to_sklib_circle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__quad_ref__circle_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_quad(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a quad and a rectangle by moving the quad to the edge of the rectangle. The direction of the resolution is determined by the `direction` parameter. If the quad and rectangle are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The quad which will be altered if there is a collision</param>
    /// <param name="collidee"> The rectangle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the quad, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the quad and rectangle are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Quad collider, Rectangle collidee, Vector2D direction)
    {
      __sklib_quad __skparam__collider;
      __sklib_rectangle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_quad(collider);
      __skparam__collidee = __skadapter__to_sklib_rectangle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__quad_ref__rectangle_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_quad(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a quad and a sprite by moving the quad to the edge of the sprite. The direction of the resolution is determined by the `direction` parameter. If the quad and sprite are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The quad which will be altered if there is a collision</param>
    /// <param name="collidee"> The sprite which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the quad, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the quad and sprite are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Quad collider, Sprite collidee, Vector2D direction)
    {
      __sklib_quad __skparam__collider;
      __sklib_ptr __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_quad(collider);
      __skparam__collidee = __skadapter__to_sklib_sprite(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__quad_ref__sprite__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_quad(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a quad and a triangle by moving the quad to the edge of the triangle. The direction of the resolution is determined by the `direction` parameter. If the quad and triangle are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The quad which will be altered if there is a collision</param>
    /// <param name="collidee"> The triangle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the quad, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the quad and triangle are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Quad collider, Triangle collidee, Vector2D direction)
    {
      __sklib_quad __skparam__collider;
      __sklib_triangle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_quad(collider);
      __skparam__collidee = __skadapter__to_sklib_triangle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__quad_ref__triangle_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_quad(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a rectangle and a circle by moving the rectangle to the edge of the circle. The direction of the resolution is determined by the `direction` parameter. If the rectangle and circle are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The rectangle which will be altered if there is a collision</param>
    /// <param name="collidee"> The circle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the rectangle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the rectangle and circle are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Rectangle collider, Circle collidee, Vector2D direction)
    {
      __sklib_rectangle __skparam__collider;
      __sklib_circle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_rectangle(collider);
      __skparam__collidee = __skadapter__to_sklib_circle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__rectangle_ref__circle_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_rectangle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a rectangle and a quad by moving the rectangle to the edge of the quad. The direction of the resolution is determined by the `direction` parameter. If the rectangle and quad are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The rectangle which will be altered if there is a collision</param>
    /// <param name="collidee"> The quad which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the rectangle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the rectangle and quad are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Rectangle collider, Quad collidee, Vector2D direction)
    {
      __sklib_rectangle __skparam__collider;
      __sklib_quad __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_rectangle(collider);
      __skparam__collidee = __skadapter__to_sklib_quad(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__rectangle_ref__quad_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_rectangle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between two rectangles by moving the collider rectangle to the edge of the collidee rectangle. The direction of the resolution is determined by the `direction` parameter. If the rectangles are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The rectangle which will be altered if there is a collision</param>
    /// <param name="collidee"> The rectangle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the collider rectangle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the rectangles are colliding and the collision was resolved, false if the rectangles are not colliding</returns>
    public static bool ResolveCollision(ref Rectangle collider, Rectangle collidee, Vector2D direction)
    {
      __sklib_rectangle __skparam__collider;
      __sklib_rectangle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_rectangle(collider);
      __skparam__collidee = __skadapter__to_sklib_rectangle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__rectangle_ref__rectangle_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_rectangle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a rectangle and a sprite by moving the rectangle to the edge of the sprite. The direction of the resolution is determined by the `direction` parameter. If the rectangle and sprite are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The rectangle which will be altered if there is a collision</param>
    /// <param name="collidee"> The sprite which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the rectangle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the rectangle and sprite are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Rectangle collider, Sprite collidee, Vector2D direction)
    {
      __sklib_rectangle __skparam__collider;
      __sklib_ptr __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_rectangle(collider);
      __skparam__collidee = __skadapter__to_sklib_sprite(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__rectangle_ref__sprite__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_rectangle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a rectangle and a triangle by moving the rectangle to the edge of the triangle. The direction of the resolution is determined by the `direction` parameter. If the rectangle and triangle are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The rectangle which will be altered if there is a collision</param>
    /// <param name="collidee"> The triangle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the rectangle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the rectangle and triangle are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Rectangle collider, Triangle collidee, Vector2D direction)
    {
      __sklib_rectangle __skparam__collider;
      __sklib_triangle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_rectangle(collider);
      __skparam__collidee = __skadapter__to_sklib_triangle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__rectangle_ref__triangle_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_rectangle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a sprite and a circle by moving the sprite to the edge of the circle. The direction of the resolution is determined by the `direction` parameter. If the sprite and circle are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The sprite which will be altered if there is a collision</param>
    /// <param name="collidee"> The circle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the sprite, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the sprite and circle are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(Sprite collider, Circle collidee, Vector2D direction)
    {
      __sklib_ptr __skparam__collider;
      __sklib_circle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_sprite(collider);
      __skparam__collidee = __skadapter__to_sklib_circle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__sprite__circle_ref__vector_2d_ref(__skparam__collider, __skparam__collidee, __skparam__direction);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a sprite and a quad by moving the sprite to the edge of the quad. The direction of the resolution is determined by the `direction` parameter. If the sprite and quad are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The sprite which will be altered if there is a collision</param>
    /// <param name="collidee"> The quad which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the sprite, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the sprite and quad are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(Sprite collider, Quad collidee, Vector2D direction)
    {
      __sklib_ptr __skparam__collider;
      __sklib_quad __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_sprite(collider);
      __skparam__collidee = __skadapter__to_sklib_quad(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__sprite__quad_ref__vector_2d_ref(__skparam__collider, __skparam__collidee, __skparam__direction);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a sprite and a rectangle by moving the sprite to the edge of the rectangle. The direction of the resolution is determined by the `direction` parameter. If the sprite and rectangle are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The sprite which will be altered if there is a collision</param>
    /// <param name="collidee"> The rectangle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the sprite, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the sprite and rectangle are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(Sprite collider, Rectangle collidee, Vector2D direction)
    {
      __sklib_ptr __skparam__collider;
      __sklib_rectangle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_sprite(collider);
      __skparam__collidee = __skadapter__to_sklib_rectangle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__sprite__rectangle_ref__vector_2d_ref(__skparam__collider, __skparam__collidee, __skparam__direction);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between two sprites by moving the collider sprite to the edge of the collidee sprite. The direction of the resolution is determined by the `direction` parameter. If the sprites are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The sprite which will be altered if there is a collision</param>
    /// <param name="collidee"> The sprite which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the collider sprite, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the sprites are colliding and the collision was resolved, false if the sprites are not colliding</returns>
    public static bool ResolveCollision(Sprite collider, Sprite collidee, Vector2D direction)
    {
      __sklib_ptr __skparam__collider;
      __sklib_ptr __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_sprite(collider);
      __skparam__collidee = __skadapter__to_sklib_sprite(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__sprite__sprite__vector_2d_ref(__skparam__collider, __skparam__collidee, __skparam__direction);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a sprite and a triangle by moving the sprite to the edge of the triangle. The direction of the resolution is determined by the `direction` parameter. If the sprite and triangle are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The sprite which will be altered if there is a collision</param>
    /// <param name="collidee"> The triangle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the sprite, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the sprite and triangle are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(Sprite collider, Triangle collidee, Vector2D direction)
    {
      __sklib_ptr __skparam__collider;
      __sklib_triangle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_sprite(collider);
      __skparam__collidee = __skadapter__to_sklib_triangle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__sprite__triangle_ref__vector_2d_ref(__skparam__collider, __skparam__collidee, __skparam__direction);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a triangle and a circle by moving the triangle to the edge of the circle. The direction of the resolution is determined by the `direction` parameter. If the triangle and circle are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The triangle which will be altered if there is a collision</param>
    /// <param name="collidee"> The circle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the triangle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the triangle and circle are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Triangle collider, Circle collidee, Vector2D direction)
    {
      __sklib_triangle __skparam__collider;
      __sklib_circle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_triangle(collider);
      __skparam__collidee = __skadapter__to_sklib_circle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__triangle_ref__circle_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_triangle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a triangle and a quad by moving the triangle to the edge of the quad. The direction of the resolution is determined by the `direction` parameter. If the triangle and quad are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The triangle which will be altered if there is a collision</param>
    /// <param name="collidee"> The quad which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the triangle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the triangle and quad are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Triangle collider, Quad collidee, Vector2D direction)
    {
      __sklib_triangle __skparam__collider;
      __sklib_quad __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_triangle(collider);
      __skparam__collidee = __skadapter__to_sklib_quad(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__triangle_ref__quad_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_triangle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a triangle and a rectangle by moving the triangle to the edge of the rectangle. The direction of the resolution is determined by the `direction` parameter. If the triangle and rectangle are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The triangle which will be altered if there is a collision</param>
    /// <param name="collidee"> The rectangle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the triangle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the triangle and rectangle are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Triangle collider, Rectangle collidee, Vector2D direction)
    {
      __sklib_triangle __skparam__collider;
      __sklib_rectangle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_triangle(collider);
      __skparam__collidee = __skadapter__to_sklib_rectangle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__triangle_ref__rectangle_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_triangle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a triangle and a sprite by moving the triangle to the edge of the sprite. The direction of the resolution is determined by the `direction` parameter. If the triangle and sprite are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The triangle which will be altered if there is a collision</param>
    /// <param name="collidee"> The sprite which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the triangle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the triangle and sprite are colliding and the collision was resolved, false if they are not colliding</returns>
    public static bool ResolveCollision(ref Triangle collider, Sprite collidee, Vector2D direction)
    {
      __sklib_triangle __skparam__collider;
      __sklib_ptr __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_triangle(collider);
      __skparam__collidee = __skadapter__to_sklib_sprite(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__triangle_ref__sprite__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_triangle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Resolves the collision between a collider triangle and a collidee triangle by moving the collider triangle to the edge of the collidee triangle. The direction of the resolution is determined by the `direction` parameter. If the triangles are not colliding, this function will return false.
    /// </summary>
    /// <param name="collider"> The triangle which will be altered if there is a collision</param>
    /// <param name="collidee"> The triangle which will not be altered</param>
    /// <param name="direction"> The direction of the collision relative to the collider triangle, expressed as a vector. If a zero vector is passed, the function will not resolve the collision.</param>
    /// <returns>True if the triangles are colliding and the collision was resolved, false if the triangles are not colliding</returns>
    public static bool ResolveCollision(ref Triangle collider, Triangle collidee, Vector2D direction)
    {
      __sklib_triangle __skparam__collider;
      __sklib_triangle __skparam__collidee;
      __sklib_vector_2d __skparam__direction;
      int __skreturn;
      __skparam__collider = __skadapter__to_sklib_triangle(collider);
      __skparam__collidee = __skadapter__to_sklib_triangle(collidee);
      __skparam__direction = __skadapter__to_sklib_vector_2d(direction);
      __skreturn = __sklib__resolve_collision__triangle_ref__triangle_ref__vector_2d_ref(ref __skparam__collider, __skparam__collidee, __skparam__direction);
      collider = __skadapter__to_triangle(__skparam__collider);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a sprite will collide with a bitmap drawn at the indicated location.
    /// </summary>
    /// <param name="s"> The sprite to test</param>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <returns>True if the sprite collides with the bitmap when drawn at the indicated location.</returns>
    public static bool SpriteBitmapCollision(Sprite s, Bitmap bmp, double x, double y)
    {
      __sklib_ptr __skparam__s;
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__sprite_bitmap_collision__sprite__bitmap__double__double(__skparam__s, __skparam__bmp, __skparam__x, __skparam__y);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a sprite will collide with a bitmap drawn at the indicated location.
    /// </summary>
    /// <param name="s"> The sprite to test</param>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="pt"> The point where the bitmap is drawn</param>
    /// <returns>True if the sprite collides with the bitmap cell when drawn at the indicated location.</returns>
    public static bool SpriteBitmapCollision(Sprite s, Bitmap bmp, int cell, Point2D pt)
    {
      __sklib_ptr __skparam__s;
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__sprite_bitmap_collision__sprite__bitmap__int__point_2d_ref(__skparam__s, __skparam__bmp, __skparam__cell, __skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a sprite will collide with a bitmap drawn at the indicated location.
    /// </summary>
    /// <param name="s"> The sprite to test</param>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <returns>True if the sprite collides with the bitmap cell when drawn at the indicated location.</returns>
    public static bool SpriteBitmapCollision(Sprite s, Bitmap bmp, int cell, double x, double y)
    {
      __sklib_ptr __skparam__s;
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      double __skparam__x;
      double __skparam__y;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__sprite_bitmap_collision__sprite__bitmap__int__double__double(__skparam__s, __skparam__bmp, __skparam__cell, __skparam__x, __skparam__y);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a sprite is drawn within an given area (circle).
    /// </summary>
    /// <param name="s"> The sprite to test</param>
    /// <param name="c"> The circle to check</param>
    /// <returns>True if the sprite it drawn in the circle area</returns>
    public static bool SpriteCircleCollision(Sprite s, Circle c)
    {
      __sklib_ptr __skparam__s;
      __sklib_circle __skparam__c;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skreturn = __sklib__sprite_circle_collision__sprite__circle_ref(__skparam__s, __skparam__c);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if two given sprites `s1` and `s2` are collided
    /// </summary>
    /// <param name="s1"> the first `sprite` to test</param>
    /// <param name="s2"> the second `sprite` to test</param>
    /// <returns>return `true` if both `s1` and `s2` are colliding, false otherwise.</returns>
    public static bool SpriteCollision(Sprite s1, Sprite s2)
    {
      __sklib_ptr __skparam__s1;
      __sklib_ptr __skparam__s2;
      int __skreturn;
      __skparam__s1 = __skadapter__to_sklib_sprite(s1);
      __skparam__s2 = __skadapter__to_sklib_sprite(s2);
      __skreturn = __sklib__sprite_collision__sprite__sprite(__skparam__s1, __skparam__s2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a sprite is drawn at a given point.
    /// </summary>
    /// <param name="s"> The sprite to test</param>
    /// <param name="pt"> The point to check</param>
    /// <returns>True if the sprite it drawn at the indicated point</returns>
    public static bool SpritePointCollision(Sprite s, Point2D pt)
    {
      __sklib_ptr __skparam__s;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__sprite_point_collision__sprite__point_2d_ref(__skparam__s, __skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a sprite is drawn within an given area (quad).
    /// </summary>
    /// <param name="s"> The sprite to test</param>
    /// <param name="q"> The quad to check</param>
    /// <returns>True if the sprite it drawn in the quad area</returns>
    public static bool SpriteQuadCollision(Sprite s, Quad q)
    {
      __sklib_ptr __skparam__s;
      __sklib_quad __skparam__q;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skreturn = __sklib__sprite_quad_collision__sprite__quad_ref(__skparam__s, __skparam__q);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a sprite is drawn along a given ray.
    /// </summary>
    /// <param name="s"> The sprite to test</param>
    /// <param name="origin"> The origin of the ray</param>
    /// <param name="heading"> The heading of the ray</param>
    /// <returns>True if the sprite is drawn along the ray</returns>
    public static bool SpriteRayCollision(Sprite s, Point2D origin, Vector2D heading)
    {
      __sklib_ptr __skparam__s;
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skreturn = __sklib__sprite_ray_collision__sprite__point_2d_ref__vector_2d_ref(__skparam__s, __skparam__origin, __skparam__heading);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a sprite is drawn within an given area (rectangle).
    /// </summary>
    /// <param name="s"> The sprite to test</param>
    /// <param name="rect"> The rectangle to check</param>
    /// <returns>True if the sprite it drawn in the rectangle area</returns>
    public static bool SpriteRectangleCollision(Sprite s, Rectangle rect)
    {
      __sklib_ptr __skparam__s;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__sprite_rectangle_collision__sprite__rectangle_ref(__skparam__s, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a sprite is drawn within an given area (triangle).
    /// </summary>
    /// <param name="s"> The sprite to test</param>
    /// <param name="t"> The triangle to check</param>
    /// <returns>True if the sprite it drawn in the triangle area</returns>
    public static bool SpriteTriangleCollision(Sprite s, Triangle t)
    {
      __sklib_ptr __skparam__s;
      __sklib_triangle __skparam__t;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__t = __skadapter__to_sklib_triangle(t);
      __skreturn = __sklib__sprite_triangle_collision__sprite__triangle_ref(__skparam__s, __skparam__t);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the alpha of the supplied color.
    /// </summary>
    /// <param name="c"> The color</param>
    /// <returns>The alpha component of the color</returns>
    public static int AlphaOf(Color c)
    {
      __sklib_color __skparam__c;
      int __skreturn;
      __skparam__c = __skadapter__to_sklib_color(c);
      __skreturn = __sklib__alpha_of__color(__skparam__c);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the blue of the supplied color.
    /// </summary>
    /// <param name="c"> The color</param>
    /// <returns>The blue component of the color</returns>
    public static int BlueOf(Color c)
    {
      __sklib_color __skparam__c;
      int __skreturn;
      __skparam__c = __skadapter__to_sklib_color(c);
      __skreturn = __sklib__blue_of__color(__skparam__c);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the brightness of the supplied color.
    /// </summary>
    /// <param name="c"> The color</param>
    /// <returns>The brightness component of the color</returns>
    public static double BrightnessOf(Color c)
    {
      __sklib_color __skparam__c;
      double __skreturn;
      __skparam__c = __skadapter__to_sklib_color(c);
      __skreturn = __sklib__brightness_of__color(__skparam__c);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `alice_blue`.
    /// </summary>
    /// <returns>A new `color` set to `alice_blue`.</returns>
    public static Color ColorAliceBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_alice_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `antique_white`.
    /// </summary>
    /// <returns>A new `color` set to `antique_white`.</returns>
    public static Color ColorAntiqueWhite()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_antique_white();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `aqua`.
    /// </summary>
    /// <returns>A new `color` set to `aqua`.</returns>
    public static Color ColorAqua()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_aqua();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `aquamarine`.
    /// </summary>
    /// <returns>A new `color` set to `aquamarine`.</returns>
    public static Color ColorAquamarine()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_aquamarine();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `azure`.
    /// </summary>
    /// <returns>A new `color` set to `azure`.</returns>
    public static Color ColorAzure()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_azure();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `beige`.
    /// </summary>
    /// <returns>A new `color` set to `beige`.</returns>
    public static Color ColorBeige()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_beige();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `bisque`.
    /// </summary>
    /// <returns>A new `color` set to `bisque`.</returns>
    public static Color ColorBisque()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_bisque();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `black`.
    /// </summary>
    /// <returns>A new `color` set to `black`.</returns>
    public static Color ColorBlack()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_black();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `blanched_almond`.
    /// </summary>
    /// <returns>A new `color` set to `blanched_almond`.</returns>
    public static Color ColorBlanchedAlmond()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_blanched_almond();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `blue`.
    /// </summary>
    /// <returns>A new `color` set to `blue`.</returns>
    public static Color ColorBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `blue_violet`.
    /// </summary>
    /// <returns>A new `color` set to `blue_violet`.</returns>
    public static Color ColorBlueViolet()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_blue_violet();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `bright_green`.
    /// </summary>
    /// <returns>A new `color` set to `bright_green`.</returns>
    public static Color ColorBrightGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_bright_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `brown`.
    /// </summary>
    /// <returns>A new `color` set to `brown`.</returns>
    public static Color ColorBrown()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_brown();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `burly_wood`.
    /// </summary>
    /// <returns>A new `color` set to `burly_wood`.</returns>
    public static Color ColorBurlyWood()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_burly_wood();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `cadet_blue`.
    /// </summary>
    /// <returns>A new `color` set to `cadet_blue`.</returns>
    public static Color ColorCadetBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_cadet_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `chartreuse`.
    /// </summary>
    /// <returns>A new `color` set to `chartreuse`.</returns>
    public static Color ColorChartreuse()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_chartreuse();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `chocolate`.
    /// </summary>
    /// <returns>A new `color` set to `chocolate`.</returns>
    public static Color ColorChocolate()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_chocolate();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `coral`.
    /// </summary>
    /// <returns>A new `color` set to `coral`.</returns>
    public static Color ColorCoral()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_coral();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `cornflower_blue`.
    /// </summary>
    /// <returns>A new `color` set to `cornflower_blue`.</returns>
    public static Color ColorCornflowerBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_cornflower_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `cornsilk`.
    /// </summary>
    /// <returns>A new `color` set to `cornsilk`.</returns>
    public static Color ColorCornsilk()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_cornsilk();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `crimson`.
    /// </summary>
    /// <returns>A new `color` set to `crimson`.</returns>
    public static Color ColorCrimson()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_crimson();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `cyan`.
    /// </summary>
    /// <returns>A new `color` set to `cyan`.</returns>
    public static Color ColorCyan()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_cyan();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_blue`.
    /// </summary>
    /// <returns>A new `color` set to `dark_blue`.</returns>
    public static Color ColorDarkBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_cyan`.
    /// </summary>
    /// <returns>A new `color` set to `dark_cyan`.</returns>
    public static Color ColorDarkCyan()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_cyan();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_goldenrod`.
    /// </summary>
    /// <returns>A new `color` set to `dark_goldenrod`.</returns>
    public static Color ColorDarkGoldenrod()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_goldenrod();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_gray`.
    /// </summary>
    /// <returns>A new `color` set to `dark_gray`.</returns>
    public static Color ColorDarkGray()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_gray();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_green`.
    /// </summary>
    /// <returns>A new `color` set to `dark_green`.</returns>
    public static Color ColorDarkGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_khaki`.
    /// </summary>
    /// <returns>A new `color` set to `dark_khaki`.</returns>
    public static Color ColorDarkKhaki()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_khaki();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_magenta`.
    /// </summary>
    /// <returns>A new `color` set to `dark_magenta`.</returns>
    public static Color ColorDarkMagenta()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_magenta();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_olive_green`.
    /// </summary>
    /// <returns>A new `color` set to `dark_olive_green`.</returns>
    public static Color ColorDarkOliveGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_olive_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_orange`.
    /// </summary>
    /// <returns>A new `color` set to `dark_orange`.</returns>
    public static Color ColorDarkOrange()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_orange();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_orchid`.
    /// </summary>
    /// <returns>A new `color` set to `dark_orchid`.</returns>
    public static Color ColorDarkOrchid()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_orchid();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_red`.
    /// </summary>
    /// <returns>A new `color` set to `dark_red`.</returns>
    public static Color ColorDarkRed()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_red();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_salmon`.
    /// </summary>
    /// <returns>A new `color` set to `dark_salmon`.</returns>
    public static Color ColorDarkSalmon()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_salmon();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_sea_green`.
    /// </summary>
    /// <returns>A new `color` set to `dark_sea_green`.</returns>
    public static Color ColorDarkSeaGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_sea_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_slate_blue`.
    /// </summary>
    /// <returns>A new `color` set to `dark_slate_blue`.</returns>
    public static Color ColorDarkSlateBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_slate_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_slate_gray`.
    /// </summary>
    /// <returns>A new `color` set to `dark_slate_gray`.</returns>
    public static Color ColorDarkSlateGray()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_slate_gray();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_turquoise`.
    /// </summary>
    /// <returns>A new `color` set to `dark_turquoise`.</returns>
    public static Color ColorDarkTurquoise()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_turquoise();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dark_violet`.
    /// </summary>
    /// <returns>A new `color` set to `dark_violet`.</returns>
    public static Color ColorDarkViolet()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dark_violet();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `deep_pink`.
    /// </summary>
    /// <returns>A new `color` set to `deep_pink`.</returns>
    public static Color ColorDeepPink()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_deep_pink();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `deep_sky_blue`.
    /// </summary>
    /// <returns>A new `color` set to `deep_sky_blue`.</returns>
    public static Color ColorDeepSkyBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_deep_sky_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dim_gray`.
    /// </summary>
    /// <returns>A new `color` set to `dim_gray`.</returns>
    public static Color ColorDimGray()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dim_gray();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `dodger_blue`.
    /// </summary>
    /// <returns>A new `color` set to `dodger_blue`.</returns>
    public static Color ColorDodgerBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_dodger_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `firebrick`.
    /// </summary>
    /// <returns>A new `color` set to `firebrick`.</returns>
    public static Color ColorFirebrick()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_firebrick();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `floral_white`.
    /// </summary>
    /// <returns>A new `color` set to `floral_white`.</returns>
    public static Color ColorFloralWhite()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_floral_white();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `forest_green`.
    /// </summary>
    /// <returns>A new `color` set to `forest_green`.</returns>
    public static Color ColorForestGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_forest_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `fuchsia`.
    /// </summary>
    /// <returns>A new `color` set to `fuchsia`.</returns>
    public static Color ColorFuchsia()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_fuchsia();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `gainsboro`.
    /// </summary>
    /// <returns>A new `color` set to `gainsboro`.</returns>
    public static Color ColorGainsboro()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_gainsboro();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `ghost_white`.
    /// </summary>
    /// <returns>A new `color` set to `ghost_white`.</returns>
    public static Color ColorGhostWhite()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_ghost_white();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `gold`.
    /// </summary>
    /// <returns>A new `color` set to `gold`.</returns>
    public static Color ColorGold()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_gold();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `goldenrod`.
    /// </summary>
    /// <returns>A new `color` set to `goldenrod`.</returns>
    public static Color ColorGoldenrod()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_goldenrod();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `gray`.
    /// </summary>
    /// <returns>A new `color` set to `gray`.</returns>
    public static Color ColorGray()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_gray();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `green`.
    /// </summary>
    /// <returns>A new `color` set to `green`.</returns>
    public static Color ColorGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `green_yellow`.
    /// </summary>
    /// <returns>A new `color` set to `green_yellow`.</returns>
    public static Color ColorGreenYellow()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_green_yellow();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `honeydew`.
    /// </summary>
    /// <returns>A new `color` set to `honeydew`.</returns>
    public static Color ColorHoneydew()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_honeydew();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `hot_pink`.
    /// </summary>
    /// <returns>A new `color` set to `hot_pink`.</returns>
    public static Color ColorHotPink()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_hot_pink();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `indian_red`.
    /// </summary>
    /// <returns>A new `color` set to `indian_red`.</returns>
    public static Color ColorIndianRed()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_indian_red();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `indigo`.
    /// </summary>
    /// <returns>A new `color` set to `indigo`.</returns>
    public static Color ColorIndigo()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_indigo();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `ivory`.
    /// </summary>
    /// <returns>A new `color` set to `ivory`.</returns>
    public static Color ColorIvory()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_ivory();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `khaki`.
    /// </summary>
    /// <returns>A new `color` set to `khaki`.</returns>
    public static Color ColorKhaki()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_khaki();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `lavender`.
    /// </summary>
    /// <returns>A new `color` set to `lavender`.</returns>
    public static Color ColorLavender()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_lavender();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `lavender_blush`.
    /// </summary>
    /// <returns>A new `color` set to `lavender_blush`.</returns>
    public static Color ColorLavenderBlush()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_lavender_blush();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `lawn_green`.
    /// </summary>
    /// <returns>A new `color` set to `lawn_green`.</returns>
    public static Color ColorLawnGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_lawn_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `lemon_chiffon`.
    /// </summary>
    /// <returns>A new `color` set to `lemon_chiffon`.</returns>
    public static Color ColorLemonChiffon()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_lemon_chiffon();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_blue`.
    /// </summary>
    /// <returns>A new `color` set to `light_blue`.</returns>
    public static Color ColorLightBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_coral`.
    /// </summary>
    /// <returns>A new `color` set to `light_coral`.</returns>
    public static Color ColorLightCoral()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_coral();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_cyan`.
    /// </summary>
    /// <returns>A new `color` set to `light_cyan`.</returns>
    public static Color ColorLightCyan()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_cyan();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_goldenrod_yellow`.
    /// </summary>
    /// <returns>A new `color` set to `light_goldenrod_yellow`.</returns>
    public static Color ColorLightGoldenrodYellow()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_goldenrod_yellow();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_gray`.
    /// </summary>
    /// <returns>A new `color` set to `light_gray`.</returns>
    public static Color ColorLightGray()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_gray();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_green`.
    /// </summary>
    /// <returns>A new `color` set to `light_green`.</returns>
    public static Color ColorLightGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_pink`.
    /// </summary>
    /// <returns>A new `color` set to `light_pink`.</returns>
    public static Color ColorLightPink()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_pink();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_salmon`.
    /// </summary>
    /// <returns>A new `color` set to `light_salmon`.</returns>
    public static Color ColorLightSalmon()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_salmon();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_sea_green`.
    /// </summary>
    /// <returns>A new `color` set to `light_sea_green`.</returns>
    public static Color ColorLightSeaGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_sea_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_sky_blue`.
    /// </summary>
    /// <returns>A new `color` set to `light_sky_blue`.</returns>
    public static Color ColorLightSkyBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_sky_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_slate_gray`.
    /// </summary>
    /// <returns>A new `color` set to `light_slate_gray`.</returns>
    public static Color ColorLightSlateGray()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_slate_gray();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_steel_blue`.
    /// </summary>
    /// <returns>A new `color` set to `light_steel_blue`.</returns>
    public static Color ColorLightSteelBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_steel_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `light_yellow`.
    /// </summary>
    /// <returns>A new `color` set to `light_yellow`.</returns>
    public static Color ColorLightYellow()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_light_yellow();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `lime`.
    /// </summary>
    /// <returns>A new `color` set to `lime`.</returns>
    public static Color ColorLime()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_lime();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `lime_green`.
    /// </summary>
    /// <returns>A new `color` set to `lime_green`.</returns>
    public static Color ColorLimeGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_lime_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `linen`.
    /// </summary>
    /// <returns>A new `color` set to `linen`.</returns>
    public static Color ColorLinen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_linen();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `magenta`.
    /// </summary>
    /// <returns>A new `color` set to `magenta`.</returns>
    public static Color ColorMagenta()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_magenta();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `maroon`.
    /// </summary>
    /// <returns>A new `color` set to `maroon`.</returns>
    public static Color ColorMaroon()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_maroon();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `medium_aquamarine`.
    /// </summary>
    /// <returns>A new `color` set to `medium_aquamarine`.</returns>
    public static Color ColorMediumAquamarine()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_medium_aquamarine();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `medium_blue`.
    /// </summary>
    /// <returns>A new `color` set to `medium_blue`.</returns>
    public static Color ColorMediumBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_medium_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `medium_orchid`.
    /// </summary>
    /// <returns>A new `color` set to `medium_orchid`.</returns>
    public static Color ColorMediumOrchid()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_medium_orchid();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `medium_purple`.
    /// </summary>
    /// <returns>A new `color` set to `medium_purple`.</returns>
    public static Color ColorMediumPurple()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_medium_purple();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `medium_sea_green`.
    /// </summary>
    /// <returns>A new `color` set to `medium_sea_green`.</returns>
    public static Color ColorMediumSeaGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_medium_sea_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `medium_slate_blue`.
    /// </summary>
    /// <returns>A new `color` set to `medium_slate_blue`.</returns>
    public static Color ColorMediumSlateBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_medium_slate_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `medium_spring_green`.
    /// </summary>
    /// <returns>A new `color` set to `medium_spring_green`.</returns>
    public static Color ColorMediumSpringGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_medium_spring_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `medium_turquoise`.
    /// </summary>
    /// <returns>A new `color` set to `medium_turquoise`.</returns>
    public static Color ColorMediumTurquoise()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_medium_turquoise();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `medium_violet_red`.
    /// </summary>
    /// <returns>A new `color` set to `medium_violet_red`.</returns>
    public static Color ColorMediumVioletRed()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_medium_violet_red();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `midnight_blue`.
    /// </summary>
    /// <returns>A new `color` set to `midnight_blue`.</returns>
    public static Color ColorMidnightBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_midnight_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `mint_cream`.
    /// </summary>
    /// <returns>A new `color` set to `mint_cream`.</returns>
    public static Color ColorMintCream()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_mint_cream();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `misty_rose`.
    /// </summary>
    /// <returns>A new `color` set to `misty_rose`.</returns>
    public static Color ColorMistyRose()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_misty_rose();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `moccasin`.
    /// </summary>
    /// <returns>A new `color` set to `moccasin`.</returns>
    public static Color ColorMoccasin()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_moccasin();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `navajo_white`.
    /// </summary>
    /// <returns>A new `color` set to `navajo_white`.</returns>
    public static Color ColorNavajoWhite()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_navajo_white();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `navy`.
    /// </summary>
    /// <returns>A new `color` set to `navy`.</returns>
    public static Color ColorNavy()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_navy();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `old_lace`.
    /// </summary>
    /// <returns>A new `color` set to `old_lace`.</returns>
    public static Color ColorOldLace()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_old_lace();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `olive`.
    /// </summary>
    /// <returns>A new `color` set to `olive`.</returns>
    public static Color ColorOlive()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_olive();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `olive_drab`.
    /// </summary>
    /// <returns>A new `color` set to `olive_drab`.</returns>
    public static Color ColorOliveDrab()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_olive_drab();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `orange`.
    /// </summary>
    /// <returns>A new `color` set to `orange`.</returns>
    public static Color ColorOrange()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_orange();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `orange_red`.
    /// </summary>
    /// <returns>A new `color` set to `orange_red`.</returns>
    public static Color ColorOrangeRed()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_orange_red();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `orchid`.
    /// </summary>
    /// <returns>A new `color` set to `orchid`.</returns>
    public static Color ColorOrchid()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_orchid();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `pale_goldenrod`.
    /// </summary>
    /// <returns>A new `color` set to `pale_goldenrod`.</returns>
    public static Color ColorPaleGoldenrod()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_pale_goldenrod();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `pale_green`.
    /// </summary>
    /// <returns>A new `color` set to `pale_green`.</returns>
    public static Color ColorPaleGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_pale_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `pale_turquoise`.
    /// </summary>
    /// <returns>A new `color` set to `pale_turquoise`.</returns>
    public static Color ColorPaleTurquoise()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_pale_turquoise();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `pale_violet_red`.
    /// </summary>
    /// <returns>A new `color` set to `pale_violet_red`.</returns>
    public static Color ColorPaleVioletRed()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_pale_violet_red();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `papaya_whip`.
    /// </summary>
    /// <returns>A new `color` set to `papaya_whip`.</returns>
    public static Color ColorPapayaWhip()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_papaya_whip();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `peach_puff`.
    /// </summary>
    /// <returns>A new `color` set to `peach_puff`.</returns>
    public static Color ColorPeachPuff()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_peach_puff();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `peru`.
    /// </summary>
    /// <returns>A new `color` set to `peru`.</returns>
    public static Color ColorPeru()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_peru();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `pink`.
    /// </summary>
    /// <returns>A new `color` set to `pink`.</returns>
    public static Color ColorPink()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_pink();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `plum`.
    /// </summary>
    /// <returns>A new `color` set to `plum`.</returns>
    public static Color ColorPlum()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_plum();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `powder_blue`.
    /// </summary>
    /// <returns>A new `color` set to `powder_blue`.</returns>
    public static Color ColorPowderBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_powder_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `purple`.
    /// </summary>
    /// <returns>A new `color` set to `purple`.</returns>
    public static Color ColorPurple()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_purple();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `red`.
    /// </summary>
    /// <returns>A new `color` set to `red`.</returns>
    public static Color ColorRed()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_red();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `rosy_brown`.
    /// </summary>
    /// <returns>A new `color` set to `rosy_brown`.</returns>
    public static Color ColorRosyBrown()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_rosy_brown();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `royal_blue`.
    /// </summary>
    /// <returns>A new `color` set to `royal_blue`.</returns>
    public static Color ColorRoyalBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_royal_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `saddle_brown`.
    /// </summary>
    /// <returns>A new `color` set to `saddle_brown`.</returns>
    public static Color ColorSaddleBrown()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_saddle_brown();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `salmon`.
    /// </summary>
    /// <returns>A new `color` set to `salmon`.</returns>
    public static Color ColorSalmon()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_salmon();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `sandy_brown`.
    /// </summary>
    /// <returns>A new `color` set to `sandy_brown`.</returns>
    public static Color ColorSandyBrown()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_sandy_brown();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `sea_green`.
    /// </summary>
    /// <returns>A new `color` set to `sea_green`.</returns>
    public static Color ColorSeaGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_sea_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `sea_shell`.
    /// </summary>
    /// <returns>A new `color` set to `sea_shell`.</returns>
    public static Color ColorSeaShell()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_sea_shell();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `sienna`.
    /// </summary>
    /// <returns>A new `color` set to `sienna`.</returns>
    public static Color ColorSienna()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_sienna();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `silver`.
    /// </summary>
    /// <returns>A new `color` set to `silver`.</returns>
    public static Color ColorSilver()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_silver();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `sky_blue`.
    /// </summary>
    /// <returns>A new `color` set to `sky_blue`.</returns>
    public static Color ColorSkyBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_sky_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `slate_blue`.
    /// </summary>
    /// <returns>A new `color` set to `slate_blue`.</returns>
    public static Color ColorSlateBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_slate_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `slate_gray`.
    /// </summary>
    /// <returns>A new `color` set to `slate_gray`.</returns>
    public static Color ColorSlateGray()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_slate_gray();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `snow`.
    /// </summary>
    /// <returns>A new `color` set to `snow`.</returns>
    public static Color ColorSnow()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_snow();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `spring_green`.
    /// </summary>
    /// <returns>A new `color` set to `spring_green`.</returns>
    public static Color ColorSpringGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_spring_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `steel_blue`.
    /// </summary>
    /// <returns>A new `color` set to `steel_blue`.</returns>
    public static Color ColorSteelBlue()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_steel_blue();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `swinburne_red`.
    /// </summary>
    /// <returns>A new `color` set to `swinburne_red`.</returns>
    public static Color ColorSwinburneRed()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_swinburne_red();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `tan`.
    /// </summary>
    /// <returns>A new `color` set to `tan`.</returns>
    public static Color ColorTan()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_tan();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `teal`.
    /// </summary>
    /// <returns>A new `color` set to `teal`.</returns>
    public static Color ColorTeal()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_teal();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `thistle`.
    /// </summary>
    /// <returns>A new `color` set to `thistle`.</returns>
    public static Color ColorThistle()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_thistle();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns a string representation of the color. Format will be a hex string starting with a #, followed by the red, green, blue, and alpha values of the color.
    /// </summary>
    /// <param name="c"> The color</param>
    /// <returns>A hex string representing the color</returns>
    public static string ColorToString(Color c)
    {
      __sklib_color __skparam__c;
      __sklib_string __skreturn;
      __skparam__c = __skadapter__to_sklib_color(c);
      __skreturn = __sklib__color_to_string__color(__skparam__c);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `tomato`.
    /// </summary>
    /// <returns>A new `color` set to `tomato`.</returns>
    public static Color ColorTomato()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_tomato();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `transparent`.
    /// </summary>
    /// <returns>A `transparent` color (i.e., a color with an `alpha` of 0).</returns>
    public static Color ColorTransparent()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_transparent();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `turquoise`.
    /// </summary>
    /// <returns>A new `color` set to `turquoise`.</returns>
    public static Color ColorTurquoise()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_turquoise();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `violet`.
    /// </summary>
    /// <returns>A new `color` set to `violet`.</returns>
    public static Color ColorViolet()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_violet();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `wheat`.
    /// </summary>
    /// <returns>A new `color` set to `wheat`.</returns>
    public static Color ColorWheat()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_wheat();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `white`.
    /// </summary>
    /// <returns>A new `color` set to `white`.</returns>
    public static Color ColorWhite()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_white();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `white_smoke`.
    /// </summary>
    /// <returns>A new `color` set to `white_smoke`.</returns>
    public static Color ColorWhiteSmoke()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_white_smoke();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `yellow`.
    /// </summary>
    /// <returns>A new `color` set to `yellow`.</returns>
    public static Color ColorYellow()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_yellow();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Generates a new `color` associated to the color `yellow_green`.
    /// </summary>
    /// <returns>A new `color` set to `yellow_green`.</returns>
    public static Color ColorYellowGreen()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__color_yellow_green();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns the green of the supplied color.
    /// </summary>
    /// <param name="c"> The color</param>
    /// <returns>The green component of the color</returns>
    public static int GreenOf(Color c)
    {
      __sklib_color __skparam__c;
      int __skreturn;
      __skparam__c = __skadapter__to_sklib_color(c);
      __skreturn = __sklib__green_of__color(__skparam__c);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returs a color from a combination of hue, saturation, and brightness.
    /// </summary>
    /// <param name="hue"> The hue of the color. Value must be between 0 and 1.</param>
    /// <param name="saturation"> The saturation of that hue. Value must be between 0 and 1.</param>
    /// <param name="brightness"> The brightness of the color. Value must be between 0 and 1.</param>
    /// <returns>The color from its hue, saturation and brightness.</returns>
    public static Color HSBColor(double hue, double saturation, double brightness)
    {
      double __skparam__hue;
      double __skparam__saturation;
      double __skparam__brightness;
      __sklib_color __skreturn;
      __skparam__hue = __skadapter__to_sklib_double(hue);
      __skparam__saturation = __skadapter__to_sklib_double(saturation);
      __skparam__brightness = __skadapter__to_sklib_double(brightness);
      __skreturn = __sklib__hsb_color__double__double__double(__skparam__hue, __skparam__saturation, __skparam__brightness);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns the hue of the supplied color.
    /// </summary>
    /// <param name="c"> The color</param>
    /// <returns>The hue component of the color</returns>
    public static double HueOf(Color c)
    {
      __sklib_color __skparam__c;
      double __skreturn;
      __skparam__c = __skadapter__to_sklib_color(c);
      __skreturn = __sklib__hue_of__color(__skparam__c);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Creates and returns a random color where the color and its opacity are random.
    /// </summary>
    /// <returns>A random color</returns>
    public static Color RandomColor()
    {
      __sklib_color __skreturn;
      __skreturn = __sklib__random_color();
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Creates and returns a random color where the color is random, but the opacity is set to the passed in value.
    /// </summary>
    /// <param name="alpha"> The set alpha (opacity) value (between 0 and 255)</param>
    /// <returns>A random color with the set alpha</returns>
    public static Color RandomRGBColor(int alpha)
    {
      int __skparam__alpha;
      __sklib_color __skreturn;
      __skparam__alpha = __skadapter__to_sklib_int(alpha);
      __skreturn = __sklib__random_rgb_color__int(__skparam__alpha);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns the red of the supplied color.
    /// </summary>
    /// <param name="c"> The color</param>
    /// <returns>The red component of the color</returns>
    public static int RedOf(Color c)
    {
      __sklib_color __skparam__c;
      int __skreturn;
      __skparam__c = __skadapter__to_sklib_color(c);
      __skreturn = __sklib__red_of__color(__skparam__c);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Gets a color given its RGB components. Each of the components has a value between 0 and 1.
    /// </summary>
    /// <param name="red"> The red component</param>
    /// <param name="green"> The green component</param>
    /// <param name="blue"> The blue component</param>
    /// <returns>The color from its different component</returns>
    public static Color RGBColor(double red, double green, double blue)
    {
      double __skparam__red;
      double __skparam__green;
      double __skparam__blue;
      __sklib_color __skreturn;
      __skparam__red = __skadapter__to_sklib_double(red);
      __skparam__green = __skadapter__to_sklib_double(green);
      __skparam__blue = __skadapter__to_sklib_double(blue);
      __skreturn = __sklib__rgb_color__double__double__double(__skparam__red, __skparam__green, __skparam__blue);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Gets a color given its RGB components. Each of the components has a value between 0 and 255.
    /// </summary>
    /// <param name="red"> The red component</param>
    /// <param name="green"> The green component</param>
    /// <param name="blue"> The blue component</param>
    /// <returns>The color from its different component</returns>
    public static Color RGBColor(int red, int green, int blue)
    {
      int __skparam__red;
      int __skparam__green;
      int __skparam__blue;
      __sklib_color __skreturn;
      __skparam__red = __skadapter__to_sklib_int(red);
      __skparam__green = __skadapter__to_sklib_int(green);
      __skparam__blue = __skadapter__to_sklib_int(blue);
      __skreturn = __sklib__rgb_color__int__int__int(__skparam__red, __skparam__green, __skparam__blue);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Gets a color given its color components. Each of the components has a value between 0 and 1.0.
    /// </summary>
    /// <param name="red"> The red component (between 0 and 1.0)</param>
    /// <param name="green"> The green component (between 0 and 1.0)</param>
    /// <param name="blue"> The blue component (between 0 and 1.0)</param>
    /// <param name="alpha"> The alpha (opacity) component (between 0 and 1.0)</param>
    /// <returns>The color from its different component</returns>
    public static Color RGBAColor(double red, double green, double blue, double alpha)
    {
      double __skparam__red;
      double __skparam__green;
      double __skparam__blue;
      double __skparam__alpha;
      __sklib_color __skreturn;
      __skparam__red = __skadapter__to_sklib_double(red);
      __skparam__green = __skadapter__to_sklib_double(green);
      __skparam__blue = __skadapter__to_sklib_double(blue);
      __skparam__alpha = __skadapter__to_sklib_double(alpha);
      __skreturn = __sklib__rgba_color__double__double__double__double(__skparam__red, __skparam__green, __skparam__blue, __skparam__alpha);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Gets a color given its color components. Each of the components has a value between 0 and 255.
    /// </summary>
    /// <param name="red"> The red component (between 0 and 255)</param>
    /// <param name="green"> The green component (between 0 and 255)</param>
    /// <param name="blue"> The blue component (between 0 and 255)</param>
    /// <param name="alpha"> The alpha (opacity) component (between 0 and 255)</param>
    /// <returns>The color from its different component</returns>
    public static Color RGBAColor(int red, int green, int blue, int alpha)
    {
      int __skparam__red;
      int __skparam__green;
      int __skparam__blue;
      int __skparam__alpha;
      __sklib_color __skreturn;
      __skparam__red = __skadapter__to_sklib_int(red);
      __skparam__green = __skadapter__to_sklib_int(green);
      __skparam__blue = __skadapter__to_sklib_int(blue);
      __skparam__alpha = __skadapter__to_sklib_int(alpha);
      __skreturn = __sklib__rgba_color__int__int__int__int(__skparam__red, __skparam__green, __skparam__blue, __skparam__alpha);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns the saturation of the supplied color.
    /// </summary>
    /// <param name="c"> The color</param>
    /// <returns>The saturation component of the color</returns>
    public static double SaturationOf(Color c)
    {
      __sklib_color __skparam__c;
      double __skreturn;
      __skparam__c = __skadapter__to_sklib_color(c);
      __skreturn = __sklib__saturation_of__color(__skparam__c);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Returns a color for the passed in color string. The format must be #, followed by the hex values for the red, green, blue, and alpha components of the color.
    /// </summary>
    /// <param name="str"> The hex string representing the color</param>
    /// <returns>The color represented in the string</returns>
    public static Color StringToColor(string str)
    {
      __sklib_string __skparam__str;
      __sklib_color __skreturn;
      __skparam__str = __skadapter__to_sklib_string(str);
      __skreturn = __sklib__string_to_color__string(__skparam__str);
    __skadapter__free__sklib_string(ref __skparam__str);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns a `drawing_options` with default values. This will draw to the current window, with default scale of 1, no rotation or offset, not flipped, drawing whole images, with default camera mechanisms and line width.
    /// </summary>
    /// <returns>A default drawing options.</returns>
    public static DrawingOptions OptionDefaults()
    {
      __sklib_drawing_options __skreturn;
      __skreturn = __sklib__option_defaults();
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to draw to a Bitmap. Pass dest the Bitmap you want to draw on.
    /// </summary>
    /// <param name="dest"> The bitmap to draw to.</param>
    /// <returns>Drawing options that will draw onto a bitmap.</returns>
    public static DrawingOptions OptionDrawTo(Bitmap dest)
    {
      __sklib_ptr __skparam__dest;
      __sklib_drawing_options __skreturn;
      __skparam__dest = __skadapter__to_sklib_bitmap(dest);
      __skreturn = __sklib__option_draw_to__bitmap(__skparam__dest);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to draw to a Bitmap. Pass dest the Bitmap you want to draw on. Pass opts the other options you want use.
    /// </summary>
    /// <param name="dest"> The bitmap to draw to.</param>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>Drawing options that will draw onto a bitmap.</returns>
    public static DrawingOptions OptionDrawTo(Bitmap dest, DrawingOptions opts)
    {
      __sklib_ptr __skparam__dest;
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__dest = __skadapter__to_sklib_bitmap(dest);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_draw_to__bitmap__drawing_options(__skparam__dest, __skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to draw to a specified Window. Pass dest the Window you want to draw on.
    /// </summary>
    /// <param name="dest"> The window to draw onto.</param>
    /// <returns>A drawing option that will draw to the indicated window.</returns>
    public static DrawingOptions OptionDrawTo(Window dest)
    {
      __sklib_ptr __skparam__dest;
      __sklib_drawing_options __skreturn;
      __skparam__dest = __skadapter__to_sklib_window(dest);
      __skreturn = __sklib__option_draw_to__window(__skparam__dest);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to draw to a Bitmap. Pass dest the Bitmap you want to draw on to. Pass opts the other options you want use.
    /// </summary>
    /// <param name="dest"> The window to draw onto.</param>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>A drawing option that will draw to the indicated window.</returns>
    public static DrawingOptions OptionDrawTo(Window dest, DrawingOptions opts)
    {
      __sklib_ptr __skparam__dest;
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__dest = __skadapter__to_sklib_window(dest);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_draw_to__window__drawing_options(__skparam__dest, __skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to flip an image along its X axis.
    /// </summary>
    /// <returns>Options that will flip bitmaps horizontally.</returns>
    public static DrawingOptions OptionFlipX()
    {
      __sklib_drawing_options __skreturn;
      __skreturn = __sklib__option_flip_x();
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to flip an image along its X axis.
    /// </summary>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>Options that will flip bitmaps horizontally.</returns>
    public static DrawingOptions OptionFlipX(DrawingOptions opts)
    {
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_flip_x__drawing_options(__skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to flip the drawing of an image along both X and Y axis.
    /// </summary>
    /// <returns>Options that flip bitmap drawing both vertically and horizontally.</returns>
    public static DrawingOptions OptionFlipXy()
    {
      __sklib_drawing_options __skreturn;
      __skreturn = __sklib__option_flip_xy();
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to flip the drawing of an image along both X and Y axis.
    /// </summary>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>Options that flip bitmap drawing both vertically and horizontally.</returns>
    public static DrawingOptions OptionFlipXy(DrawingOptions opts)
    {
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_flip_xy__drawing_options(__skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to flip the drawing of an image along its Y axis.
    /// </summary>
    /// <returns>Options that will flip bitmaps vertically.</returns>
    public static DrawingOptions OptionFlipY()
    {
      __sklib_drawing_options __skreturn;
      __skreturn = __sklib__option_flip_y();
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to flip the drawing of an image along its Y axis.
    /// </summary>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>Options that will flip bitmaps vertically.</returns>
    public static DrawingOptions OptionFlipY(DrawingOptions opts)
    {
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_flip_y__drawing_options(__skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to change the width of line drawings.
    /// </summary>
    /// <param name="width"> The new line width for line drawing.</param>
    /// <returns>Options to draw lines with the indicated width.</returns>
    public static DrawingOptions OptionLineWidth(int width)
    {
      int __skparam__width;
      __sklib_drawing_options __skreturn;
      __skparam__width = __skadapter__to_sklib_int(width);
      __skreturn = __sklib__option_line_width__int(__skparam__width);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to change the width of line drawings.
    /// </summary>
    /// <param name="width"> The new line width for line drawing.</param>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>Options to draw lines with the indicated width.</returns>
    public static DrawingOptions OptionLineWidth(int width, DrawingOptions opts)
    {
      int __skparam__width;
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__width = __skadapter__to_sklib_int(width);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_line_width__int__drawing_options(__skparam__width, __skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to draw only a part of a bitmap.
    /// </summary>
    /// <param name="x"> The x coordinate of the part within the bitmap.</param>
    /// <param name="y"> The y coordinate of the part within the bitmap.</param>
    /// <param name="w"> The width of the part within the bitmap.</param>
    /// <param name="h"> The height of the part within the bitmap.</param>
    /// <returns>Options to draw parts of a bitmap.</returns>
    public static DrawingOptions OptionPartBmp(double x, double y, double w, double h)
    {
      double __skparam__x;
      double __skparam__y;
      double __skparam__w;
      double __skparam__h;
      __sklib_drawing_options __skreturn;
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__w = __skadapter__to_sklib_double(w);
      __skparam__h = __skadapter__to_sklib_double(h);
      __skreturn = __sklib__option_part_bmp__double__double__double__double(__skparam__x, __skparam__y, __skparam__w, __skparam__h);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to draw only a part of a bitmap.
    /// </summary>
    /// <param name="x"> The x coordinate of the part within the bitmap.</param>
    /// <param name="y"> The y coordinate of the part within the bitmap.</param>
    /// <param name="w"> The width of the part within the bitmap.</param>
    /// <param name="h"> The height of the part within the bitmap.</param>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>Options to draw parts of a bitmap.</returns>
    public static DrawingOptions OptionPartBmp(double x, double y, double w, double h, DrawingOptions opts)
    {
      double __skparam__x;
      double __skparam__y;
      double __skparam__w;
      double __skparam__h;
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__w = __skadapter__to_sklib_double(w);
      __skparam__h = __skadapter__to_sklib_double(h);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_part_bmp__double__double__double__double__drawing_options(__skparam__x, __skparam__y, __skparam__w, __skparam__h, __skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to draw only part of a bitmap.
    /// </summary>
    /// <param name="part"> The rectangle of the part of the bitmap to draw.</param>
    /// <returns>Options to draw parts of a bitmap.</returns>
    public static DrawingOptions OptionPartBmp(Rectangle part)
    {
      __sklib_rectangle __skparam__part;
      __sklib_drawing_options __skreturn;
      __skparam__part = __skadapter__to_sklib_rectangle(part);
      __skreturn = __sklib__option_part_bmp__rectangle(__skparam__part);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to draw only part of a bitmap.
    /// </summary>
    /// <param name="part"> The rectangle of the part of the bitmap to draw.</param>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>Options to draw parts of a bitmap.</returns>
    public static DrawingOptions OptionPartBmp(Rectangle part, DrawingOptions opts)
    {
      __sklib_rectangle __skparam__part;
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__part = __skadapter__to_sklib_rectangle(part);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_part_bmp__rectangle__drawing_options(__skparam__part, __skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to rotate a bitmap around its centre point.
    /// </summary>
    /// <param name="angle"> The angle to rotate bitmaps.</param>
    /// <returns>Options that will rotate bitmaps around its center point.</returns>
    public static DrawingOptions OptionRotateBmp(double angle)
    {
      double __skparam__angle;
      __sklib_drawing_options __skreturn;
      __skparam__angle = __skadapter__to_sklib_double(angle);
      __skreturn = __sklib__option_rotate_bmp__double(__skparam__angle);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to rotate the drawing of a bitmap. This allows you to set the anchor point and rotate around that by a number of degrees. Pass opts the other options you want use.
    /// </summary>
    /// <param name="angle"> The angle to rotate bitmaps.</param>
    /// <param name="anchorX"> The x location of the anchor within the bitmap</param>
    /// <param name="anchorY"> The y location of the anchor within the bitmap</param>
    /// <returns>Options that will rotate bitmaps around an anchor point.</returns>
    public static DrawingOptions OptionRotateBmp(double angle, double anchorX, double anchorY)
    {
      double __skparam__angle;
      double __skparam__anchor_x;
      double __skparam__anchor_y;
      __sklib_drawing_options __skreturn;
      __skparam__angle = __skadapter__to_sklib_double(angle);
      __skparam__anchor_x = __skadapter__to_sklib_double(anchorX);
      __skparam__anchor_y = __skadapter__to_sklib_double(anchorY);
      __skreturn = __sklib__option_rotate_bmp__double__double__double(__skparam__angle, __skparam__anchor_x, __skparam__anchor_y);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to rotate the drawing of a bitmap. This allows you to set the anchor point and rotate around that by a number of degrees. Pass opts the other options you want use.
    /// </summary>
    /// <param name="angle"> The angle to rotate bitmaps.</param>
    /// <param name="anchorX"> The x location of the anchor within the bitmap</param>
    /// <param name="anchorY"> The y location of the anchor within the bitmap</param>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>Options that will rotate bitmaps around an anchor point.</returns>
    public static DrawingOptions OptionRotateBmp(double angle, double anchorX, double anchorY, DrawingOptions opts)
    {
      double __skparam__angle;
      double __skparam__anchor_x;
      double __skparam__anchor_y;
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__angle = __skadapter__to_sklib_double(angle);
      __skparam__anchor_x = __skadapter__to_sklib_double(anchorX);
      __skparam__anchor_y = __skadapter__to_sklib_double(anchorY);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_rotate_bmp__double__double__double__drawing_options(__skparam__angle, __skparam__anchor_x, __skparam__anchor_y, __skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to rotate a bitmap around its centre point.
    /// </summary>
    /// <param name="angle"> The angle to rotate bitmaps.</param>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>Options that will rotate bitmaps around its center point.</returns>
    public static DrawingOptions OptionRotateBmp(double angle, DrawingOptions opts)
    {
      double __skparam__angle;
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__angle = __skadapter__to_sklib_double(angle);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_rotate_bmp__double__drawing_options(__skparam__angle, __skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to scale the drawing of bitmaps. You can scale x and y separately.
    /// </summary>
    /// <param name="scaleX"> The amount to scale bitmaps aalong the x axis</param>
    /// <param name="scaleY"> The amount to scale bitmaps aalong the y axis</param>
    /// <returns>Options that will scale bitmaps along the x,y axis.</returns>
    public static DrawingOptions OptionScaleBmp(double scaleX, double scaleY)
    {
      double __skparam__scale_x;
      double __skparam__scale_y;
      __sklib_drawing_options __skreturn;
      __skparam__scale_x = __skadapter__to_sklib_double(scaleX);
      __skparam__scale_y = __skadapter__to_sklib_double(scaleY);
      __skreturn = __sklib__option_scale_bmp__double__double(__skparam__scale_x, __skparam__scale_y);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to scale the drawing of bitmaps. You can scale x and y separately. Pass opts the other options you want use.
    /// </summary>
    /// <param name="scaleX"> The amount to scale bitmaps aalong the x axis</param>
    /// <param name="scaleY"> The amount to scale bitmaps aalong the y axis</param>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>Options that will scale bitmaps along the x,y axis.</returns>
    public static DrawingOptions OptionScaleBmp(double scaleX, double scaleY, DrawingOptions opts)
    {
      double __skparam__scale_x;
      double __skparam__scale_y;
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__scale_x = __skadapter__to_sklib_double(scaleX);
      __skparam__scale_y = __skadapter__to_sklib_double(scaleY);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_scale_bmp__double__double__drawing_options(__skparam__scale_x, __skparam__scale_y, __skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to draw to the screen, ignoring the positon of the camera.
    /// </summary>
    /// <returns>Options that will draw to the surface without camera effects.</returns>
    public static DrawingOptions OptionToScreen()
    {
      __sklib_drawing_options __skreturn;
      __skreturn = __sklib__option_to_screen();
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to draw to the screen, ignoring the positon of the camera.
    /// </summary>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>Options that will draw to the surface without camera effects.</returns>
    public static DrawingOptions OptionToScreen(DrawingOptions opts)
    {
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_to_screen__drawing_options(__skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to draw in World coordinates -- these are affected by the movement of the camera.
    /// </summary>
    /// <returns>Options that will draw with camera effects.</returns>
    public static DrawingOptions OptionToWorld()
    {
      __sklib_drawing_options __skreturn;
      __skreturn = __sklib__option_to_world();
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use this option to draw in World coordinates -- these are affected by the movement of the camera.
    /// </summary>
    /// <param name="opts"> Values for the other options.</param>
    /// <returns>Options that will draw with camera effects.</returns>
    public static DrawingOptions OptionToWorld(DrawingOptions opts)
    {
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_to_world__drawing_options(__skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use details from the animation to select an appropriate cell from the bitmaps being drawn.
    /// </summary>
    /// <param name="anim"> The animation with the cell details to be used.</param>
    /// <returns>A drawing option that will draw the current cell from the animation.</returns>
    public static DrawingOptions OptionWithAnimation(Animation anim)
    {
      __sklib_ptr __skparam__anim;
      __sklib_drawing_options __skreturn;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skreturn = __sklib__option_with_animation__animation(__skparam__anim);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Use details from the animation to select an appropriate cell from the bitmaps being drawn. This extends the passed in drawing options with the animation details.
    /// </summary>
    /// <param name="anim"> The animation with the cell details to be used.</param>
    /// <param name="opts"> The existing options to extend.</param>
    /// <returns>A drawing option that will draw the current cell from the animation.</returns>
    public static DrawingOptions OptionWithAnimation(Animation anim, DrawingOptions opts)
    {
      __sklib_ptr __skparam__anim;
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__anim = __skadapter__to_sklib_animation(anim);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_with_animation__animation__drawing_options(__skparam__anim, __skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// When drawing the bitmap this will only draw the cell. To use this the bitmap needs to have been provided with its cell details (see `bitmap_set_cell_details`). This option overrides the animation or part drawing options.
    /// </summary>
    /// <param name="cell"> The cell to draw from the bitmap (-1 for entire bitmap)</param>
    /// <returns>A drawing option that will draw the selected cell.</returns>
    public static DrawingOptions OptionWithBitmapCell(int cell)
    {
      int __skparam__cell;
      __sklib_drawing_options __skreturn;
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skreturn = __sklib__option_with_bitmap_cell__int(__skparam__cell);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// When drawing the bitmap this will only draw the cell. To use this the bitmap needs to have been provided with its cell details (see `bitmap_set_cell_details`). This option overrides the animation or part drawing options. This extends the passed in drawing options with the cell details.
    /// </summary>
    /// <param name="cell"> The cell to draw from the bitmap (-1 for entire bitmap)</param>
    /// <param name="opts"> The existing options to extend.</param>
    /// <returns>A drawing option that will draw the selected cell.</returns>
    public static DrawingOptions OptionWithBitmapCell(int cell, DrawingOptions opts)
    {
      int __skparam__cell;
      __sklib_drawing_options __skparam__opts;
      __sklib_drawing_options __skreturn;
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__option_with_bitmap_cell__int__drawing_options(__skparam__cell, __skparam__opts);
      return __skadapter__to_drawing_options(__skreturn);
    }
    /// <summary>
    /// Draws an ellipse using the provided location, and size.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    public static void DrawEllipse(Color clr, Rectangle rect)
    {
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__draw_ellipse__color__rectangle(__skparam__clr, __skparam__rect);
    }
    /// <summary>
    /// Draws an ellipse using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawEllipse(Color clr, Rectangle rect, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_ellipse__color__rectangle__drawing_options(__skparam__clr, __skparam__rect, __skparam__opts);
    }
    /// <summary>
    /// Draws an ellipse using the provided location, and size.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or window to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or window to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    public static void DrawEllipse(Color clr, double x, double y, double width, double height)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __sklib__draw_ellipse__color__double__double__double__double(__skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Draws an ellipse using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or window to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or window to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawEllipse(Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_ellipse__color__double__double__double__double__drawing_options(__skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height, __skparam__opts);
    }
    /// <summary>
    /// Draws an ellipse on the given bitmap, using the provided location, and size.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    public static void DrawEllipseOnBitmap(Bitmap destination, Color clr, Rectangle rect)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__draw_ellipse_on_bitmap__bitmap__color__rectangle(__skparam__destination, __skparam__clr, __skparam__rect);
    }
    /// <summary>
    /// Draws an ellipse on the given bitmap, using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawEllipseOnBitmap(Bitmap destination, Color clr, Rectangle rect, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_ellipse_on_bitmap__bitmap__color__rectangle__drawing_options(__skparam__destination, __skparam__clr, __skparam__rect, __skparam__opts);
    }
    /// <summary>
    /// Draws an ellipse on the given bitmap, using the provided location, and size.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or bitmap to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or bitmap to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    public static void DrawEllipseOnBitmap(Bitmap destination, Color clr, double x, double y, double width, double height)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __sklib__draw_ellipse_on_bitmap__bitmap__color__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Draws an ellipse to the bitmap, using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or bitmap to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or bitmap to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawEllipseOnBitmap(Bitmap destination, Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_ellipse_on_bitmap__bitmap__color__double__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height, __skparam__opts);
    }
    /// <summary>
    /// Draws an ellipse on the given window, using the provided location, and size.
    /// </summary>
    /// <param name="destination"> the window to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    public static void DrawEllipseOnWindow(Window destination, Color clr, Rectangle rect)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__draw_ellipse_on_window__window__color__rectangle(__skparam__destination, __skparam__clr, __skparam__rect);
    }
    /// <summary>
    /// Draws an ellipse on the given window, using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="destination"> the window to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawEllipseOnWindow(Window destination, Color clr, Rectangle rect, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_ellipse_on_window__window__color__rectangle__drawing_options(__skparam__destination, __skparam__clr, __skparam__rect, __skparam__opts);
    }
    /// <summary>
    /// Draws an ellipse on the given window, using the provided location, and size.
    /// </summary>
    /// <param name="destination"> the window to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or window to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or window to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    public static void DrawEllipseOnWindow(Window destination, Color clr, double x, double y, double width, double height)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __sklib__draw_ellipse_on_window__window__color__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Draws an ellipse to the window, using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="destination"> the window to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or window to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or window to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawEllipseOnWindow(Window destination, Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_ellipse_on_window__window__color__double__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height, __skparam__opts);
    }
    /// <summary>
    /// Fill an ellipse using the provided location, and size.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    public static void FillEllipse(Color clr, Rectangle rect)
    {
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__fill_ellipse__color__rectangle(__skparam__clr, __skparam__rect);
    }
    /// <summary>
    /// Fills an ellipse using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillEllipse(Color clr, Rectangle rect, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_ellipse__color__rectangle__drawing_options(__skparam__clr, __skparam__rect, __skparam__opts);
    }
    /// <summary>
    /// Fills an ellipse using the provided location, and size.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or window to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or window to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    public static void FillEllipse(Color clr, double x, double y, double width, double height)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __sklib__fill_ellipse__color__double__double__double__double(__skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Fills an ellipse using the provided location, size, and drawing options.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or window to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or window to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillEllipse(Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_ellipse__color__double__double__double__double__drawing_options(__skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height, __skparam__opts);
    }
    /// <summary>
    /// Fill an ellipse on the given bitmap, using the provided location, and size.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    public static void FillEllipseOnBitmap(Bitmap destination, Color clr, Rectangle rect)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__fill_ellipse_on_bitmap__bitmap__color__rectangle(__skparam__destination, __skparam__clr, __skparam__rect);
    }
    /// <summary>
    /// Fills an ellipse on the given bitmap, using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillEllipseOnBitmap(Bitmap destination, Color clr, Rectangle rect, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_ellipse_on_bitmap__bitmap__color__rectangle__drawing_options(__skparam__destination, __skparam__clr, __skparam__rect, __skparam__opts);
    }
    /// <summary>
    /// Fills an ellipse on the given bitmap, using the provided location, and size.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or bitmap to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or bitmap to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    public static void FillEllipseOnBitmap(Bitmap destination, Color clr, double x, double y, double width, double height)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __sklib__fill_ellipse_on_bitmap__bitmap__color__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Fills an ellipse on the given bitmap, using the provided location, size, and drawing options.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or bitmap to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or bitmap to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillEllipseOnBitmap(Bitmap destination, Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_ellipse_on_bitmap__bitmap__color__double__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height, __skparam__opts);
    }
    /// <summary>
    /// Fill an ellipse on the given window, using the provided location, and size.
    /// </summary>
    /// <param name="destination"> the window to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    public static void FillEllipseOnWindow(Window destination, Color clr, Rectangle rect)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__fill_ellipse_on_window__window__color__rectangle(__skparam__destination, __skparam__clr, __skparam__rect);
    }
    /// <summary>
    /// Fills an ellipse on the given window, using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="destination"> the window to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillEllipseOnWindow(Window destination, Color clr, Rectangle rect, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_ellipse_on_window__window__color__rectangle__drawing_options(__skparam__destination, __skparam__clr, __skparam__rect, __skparam__opts);
    }
    /// <summary>
    /// Fills an ellipse on the given window, using the provided location, and size.
    /// </summary>
    /// <param name="destination"> the window to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or window to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or window to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    public static void FillEllipseOnWindow(Window destination, Color clr, double x, double y, double width, double height)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __sklib__fill_ellipse_on_window__window__color__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Fills an ellipse on the given window, using the provided location, size, and drawing options.
    /// </summary>
    /// <param name="destination"> the window to draw the ellipse on</param>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or window to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or window to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillEllipseOnWindow(Window destination, Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_ellipse_on_window__window__color__double__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height, __skparam__opts);
    }
    /// <summary>
    /// Returns the cosine of the supplied angle (in degrees).
    /// </summary>
    /// <param name="degrees"> The angle in degrees</param>
    /// <returns>the cosine of the supplied angle (in degrees).</returns>
    public static float Cosine(float degrees)
    {
      float __skparam__degrees;
      float __skreturn;
      __skparam__degrees = __skadapter__to_sklib_float(degrees);
      __skreturn = __sklib__cosine__float(__skparam__degrees);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Returns the sine of the supplied angle (in degrees).
    /// </summary>
    /// <param name="degrees"> The angle in degrees</param>
    /// <returns>the sine of the supplied angle (in degrees).</returns>
    public static float Sine(float degrees)
    {
      float __skparam__degrees;
      float __skreturn;
      __skparam__degrees = __skadapter__to_sklib_float(degrees);
      __skreturn = __sklib__sine__float(__skparam__degrees);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Returns the tangent of the supplied angle (in degrees).
    /// </summary>
    /// <param name="degrees"> The angle in degrees</param>
    /// <returns>the tangent of the supplied angle (in degrees).</returns>
    public static float Tangent(float degrees)
    {
      float __skparam__degrees;
      float __skreturn;
      __skparam__degrees = __skadapter__to_sklib_float(degrees);
      __skreturn = __sklib__tangent__float(__skparam__degrees);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Clears the current screen to color white.
    /// </summary>
    public static void ClearScreen()
    {
      __sklib__clear_screen();
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="clr"> The color to clear the screen's background color to.</param>
    public static void ClearScreen(Color clr)
    {
      __sklib_color __skparam__clr;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __sklib__clear_screen__color(__skparam__clr);
    }
    /// <summary>
    /// Returns the details about one of the displays attached to the computer.
    /// </summary>
    /// <param name="index"> The display number (from 0 to `number_of_displays` - 1)</param>
    /// <returns>The details of this display</returns>
    public static Display DisplayDetails(uint index)
    {
      uint __skparam__index;
      __sklib_ptr __skreturn;
      __skparam__index = __skadapter__to_sklib_unsigned_int(index);
      __skreturn = __sklib__display_details__unsigned_int(__skparam__index);
      return __skadapter__to_display(__skreturn);
    }
    /// <summary>
    /// Return the height of the display in pixels, read from the system details.
    /// </summary>
    /// <param name="disp"> The display details</param>
    /// <returns>The height of the display</returns>
    public static int DisplayHeight(Display disp)
    {
      __sklib_ptr __skparam__disp;
      int __skreturn;
      __skparam__disp = __skadapter__to_sklib_display(disp);
      __skreturn = __sklib__display_height__display(__skparam__disp);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Return the name of the display, read from the system details.
    /// </summary>
    /// <param name="disp"> The display details</param>
    /// <returns>The name of the display</returns>
    public static string DisplayName(Display disp)
    {
      __sklib_ptr __skparam__disp;
      __sklib_string __skreturn;
      __skparam__disp = __skadapter__to_sklib_display(disp);
      __skreturn = __sklib__display_name__display(__skparam__disp);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Return the width of the display in pixels, read from the system details.
    /// </summary>
    /// <param name="disp"> The display details</param>
    /// <returns>The width of the display</returns>
    public static int DisplayWidth(Display disp)
    {
      __sklib_ptr __skparam__disp;
      int __skreturn;
      __skparam__disp = __skadapter__to_sklib_display(disp);
      __skreturn = __sklib__display_width__display(__skparam__disp);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Return a relative x location for the display in pixels, read from the system details. This can be used to work out the arrangement of displays.
    /// </summary>
    /// <param name="disp"> The display details</param>
    /// <returns>The x location of the display</returns>
    public static int DisplayX(Display disp)
    {
      __sklib_ptr __skparam__disp;
      int __skreturn;
      __skparam__disp = __skadapter__to_sklib_display(disp);
      __skreturn = __sklib__display_x__display(__skparam__disp);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Return a relative y location for the display in pixels, read from the system details. This can be used to work out the arrangement of displays.
    /// </summary>
    /// <param name="disp"> The display details</param>
    /// <returns>The y location of the display</returns>
    public static int DisplayY(Display disp)
    {
      __sklib_ptr __skparam__disp;
      int __skreturn;
      __skparam__disp = __skadapter__to_sklib_display(disp);
      __skreturn = __sklib__display_y__display(__skparam__disp);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the number of physical displays attached to the computer.
    /// </summary>
    /// <returns>The number of displays attached to the computer</returns>
    public static int NumberOfDisplays()
    {
      int __skreturn;
      __skreturn = __sklib__number_of_displays();
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    public static void RefreshScreen()
    {
      __sklib__refresh_screen();
    }
    /// <summary>
    /// Refreshes all open windows with a target FPS (frames per second). This will delay a period of time that will approximately meet the targeted frames per second.
    /// </summary>
    /// <param name="targetFps"> The targeted frames per second to refresh the screen at.</param>
    public static void RefreshScreen(uint targetFps)
    {
      uint __skparam__target_fps;
      __skparam__target_fps = __skadapter__to_sklib_unsigned_int(targetFps);
      __sklib__refresh_screen__unsigned_int(__skparam__target_fps);
    }
    /// <summary>
    /// Save the bitmap to the user's desktop.
    /// </summary>
    /// <param name="bmp"> The bitmap to save</param>
    /// <param name="basename"> The base of the filename. If there is a file of this name already, then the name will be changed to generate a unique filename.</param>
    public static void SaveBitmap(Bitmap bmp, string basename)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_string __skparam__basename;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__basename = __skadapter__to_sklib_string(basename);
      __sklib__save_bitmap__bitmap__string_ref(__skparam__bmp, __skparam__basename);
    __skadapter__free__sklib_string(ref __skparam__basename);
    }
    /// <summary>
    /// Returns the height of the current window.
    /// </summary>
    /// <returns>The height of the current window.</returns>
    public static int ScreenHeight()
    {
      int __skreturn;
      __skreturn = __sklib__screen_height();
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the width of the current window.
    /// </summary>
    /// <returns>The width of the current window.</returns>
    public static int ScreenWidth()
    {
      int __skreturn;
      __skreturn = __sklib__screen_width();
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Saves a screenshot of the current window to a bitmap file. The file will be saved onto the user's desktop.
    /// </summary>
    /// <param name="basename"> The base of the filename. If there is a file of this name already, then the name will be changed to generate a unique filename.</param>
    public static void TakeScreenshot(string basename)
    {
      __sklib_string __skparam__basename;
      __skparam__basename = __skadapter__to_sklib_string(basename);
      __sklib__take_screenshot__string_ref(__skparam__basename);
    __skadapter__free__sklib_string(ref __skparam__basename);
    }
    /// <summary>
    /// Saves a screenshot of the current window to a bitmap file. The file will be saved onto the user's desktop.
    /// </summary>
    /// <param name="wind"> The window to capture in the screenshot</param>
    /// <param name="basename"> The base of the filename. If there is a file of this name already, then the name will be changed to generate a unique filename.</param>
    public static void TakeScreenshot(Window wind, string basename)
    {
      __sklib_ptr __skparam__wind;
      __sklib_string __skparam__basename;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skparam__basename = __skadapter__to_sklib_string(basename);
      __sklib__take_screenshot__window__string_ref(__skparam__wind, __skparam__basename);
    __skadapter__free__sklib_string(ref __skparam__basename);
    }
    /// <summary>
    /// Returns a circle that will encompass the entire bitamp.
    /// </summary>
    /// <param name="bmp"> The bitmap to encompass.</param>
    /// <param name="pt"> The point where the bitmap is located.</param>
    /// <returns>A circle that surrounds the bitmap.</returns>
    public static Circle BitmapBoundingCircle(Bitmap bmp, Point2D pt)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skparam__pt;
      __sklib_circle __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__bitmap_bounding_circle__bitmap__point_2d_ref(__skparam__bmp, __skparam__pt);
      return __skadapter__to_circle(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that is the same size as a bitmap (the whole bitmap).
    /// </summary>
    /// <param name="bmp"> The bitmap</param>
    /// <returns>A rectangle with the same size as the bitmap.</returns>
    public static Rectangle BitmapBoundingRectangle(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_rectangle __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_bounding_rectangle__bitmap(__skparam__bmp);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that is the same size as the bitmap and is located at the indicated position.
    /// </summary>
    /// <param name="bmp"> The bitmap</param>
    /// <param name="x"> The x location of the rectangle</param>
    /// <param name="y"> The y location of the rectangle</param>
    /// <returns>A rectangle with the same size as the bitmap, at the indicated location.</returns>
    public static Rectangle BitmapBoundingRectangle(Bitmap bmp, double x, double y)
    {
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __sklib_rectangle __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__bitmap_bounding_rectangle__bitmap__double__double(__skparam__bmp, __skparam__x, __skparam__y);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// This returns a point that represents the center of a cell from this bitmap in local space.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the center of.</param>
    /// <returns>A point in the center of a cell for this bitmap.</returns>
    public static Point2D BitmapCellCenter(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_cell_center__bitmap(__skparam__bmp);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns a circle that will encompass the bitmap cell if it were drawn at the indicated point.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the details from.</param>
    /// <param name="x"> The the x location of the bitmap.</param>
    /// <param name="y"> The the y location of the bitmap.</param>
    /// <returns>A circle that will encompass the bitmap cell.</returns>
    public static Circle BitmapCellCircle(Bitmap bmp, double x, double y)
    {
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __sklib_circle __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__bitmap_cell_circle__bitmap__double__double(__skparam__bmp, __skparam__x, __skparam__y);
      return __skadapter__to_circle(__skreturn);
    }
    /// <summary>
    /// Returns a circle that will encompass the bitmap cell if it were drawn at the indicated point.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the details from.</param>
    /// <param name="pt"> The point indicating the location of the bitmap.</param>
    /// <returns>A circle that will encompass the bitmap cell.</returns>
    public static Circle BitmapCellCircle(Bitmap bmp, Point2D pt)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skparam__pt;
      __sklib_circle __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__bitmap_cell_circle__bitmap__point_2d(__skparam__bmp, __skparam__pt);
      return __skadapter__to_circle(__skreturn);
    }
    /// <summary>
    /// Returns a circle that will encompass the bitmap cell if it were drawn at the indicated point, with the provided scale.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the details from.</param>
    /// <param name="pt"> The point indicating the location of the bitmap.</param>
    /// <param name="scale"> The scaling factor for the bitmap drawing.</param>
    /// <returns>A circle that will encompass the bitmap cell.</returns>
    public static Circle BitmapCellCircle(Bitmap bmp, Point2D pt, double scale)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skparam__pt;
      double __skparam__scale;
      __sklib_circle __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__scale = __skadapter__to_sklib_double(scale);
      __skreturn = __sklib__bitmap_cell_circle__bitmap__point_2d__double(__skparam__bmp, __skparam__pt, __skparam__scale);
      return __skadapter__to_circle(__skreturn);
    }
    /// <summary>
    /// Returns the number of cell columns in the bitmap. This is setup using `bitmap_set_cell_details`
    /// </summary>
    /// <param name="bmp"> The bitmap to check</param>
    /// <returns>The number of cell columns</returns>
    public static int BitmapCellColumns(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_cell_columns__bitmap(__skparam__bmp);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the number of cells within the bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap to check.</param>
    /// <returns>The number of individual cells within the bitmap.</returns>
    public static int BitmapCellCount(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_cell_count__bitmap(__skparam__bmp);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the height of each cell in this bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the details from.</param>
    /// <returns>The height of each cells in bmp</returns>
    public static int BitmapCellHeight(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_cell_height__bitmap(__skparam__bmp);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns a vector that represents the movement needed to get to a given cell within a bitmap.
    /// </summary>
    /// <param name="src"> The bitmap with the cell details.</param>
    /// <param name="cell"> The index of the cell</param>
    /// <returns>The offset needed to get to the cell from the top left of the bitmap.</returns>
    public static Vector2D BitmapCellOffset(Bitmap src, int cell)
    {
      __sklib_ptr __skparam__src;
      int __skparam__cell;
      __sklib_vector_2d __skreturn;
      __skparam__src = __skadapter__to_sklib_bitmap(src);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skreturn = __sklib__bitmap_cell_offset__bitmap__int(__skparam__src, __skparam__cell);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that will encompass a cell of the bitmap.
    /// </summary>
    /// <param name="src"> The bitmap to get the details from</param>
    /// <returns>A rectangle with width and height from the bitmap's cell details.</returns>
    public static Rectangle BitmapCellRectangle(Bitmap src)
    {
      __sklib_ptr __skparam__src;
      __sklib_rectangle __skreturn;
      __skparam__src = __skadapter__to_sklib_bitmap(src);
      __skreturn = __sklib__bitmap_cell_rectangle__bitmap(__skparam__src);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that will encompass the bitmap cell if it were drawn at the indicated point.
    /// </summary>
    /// <param name="src"> The bitmap to get the details from</param>
    /// <param name="pt"> The point details for the rectangle.</param>
    /// <returns>A rectangle at pt, with width and height from the bitmap's cell details.</returns>
    public static Rectangle BitmapCellRectangle(Bitmap src, Point2D pt)
    {
      __sklib_ptr __skparam__src;
      __sklib_point_2d __skparam__pt;
      __sklib_rectangle __skreturn;
      __skparam__src = __skadapter__to_sklib_bitmap(src);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__bitmap_cell_rectangle__bitmap__point_2d_ref(__skparam__src, __skparam__pt);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns the number of rows of cells in the bitmap. These details are set in `bitmap_set_cell_details`.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the details from.</param>
    /// <returns>The number of rows of cells in the bitmap.</returns>
    public static int BitmapCellRows(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_cell_rows__bitmap(__skparam__bmp);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the width of each cell in this bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the details from.</param>
    /// <returns>The width of each cells in bmp</returns>
    public static int BitmapCellWidth(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_cell_width__bitmap(__skparam__bmp);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// This returns a point that represents the center of the bitmap in local space.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the center of.</param>
    /// <returns>A point in the center of the bitmap.</returns>
    public static Point2D BitmapCenter(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_center__bitmap(__skparam__bmp);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns the filename from which the bitmap was loaded. This will be an empty string for created bitmaps.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the filename from.</param>
    /// <returns>The file name of the bitmap.</returns>
    public static string BitmapFilename(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_string __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_filename__bitmap(__skparam__bmp);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns the total height of the bitmap. If the bitmap contains cells, you ca get the height of a cell using `bitmap_cell_height`.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the details from.</param>
    /// <returns>The height of the bitmap.</returns>
    public static int BitmapHeight(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_height__bitmap(__skparam__bmp);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the total height of the bitmap. If the bitmap contains cells, you ca get the height of a cell using `bitmap_cell_height`.
    /// </summary>
    /// <param name="name"> The name of the bitmap to get the details from.</param>
    /// <returns>The height of the bitmap.</returns>
    public static int BitmapHeight(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__bitmap_height__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the name of the bitmap was loaded. This is the name you can use to access this bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the name from.</param>
    /// <returns>The name of the bitmap.</returns>
    public static string BitmapName(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_string __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_name__bitmap(__skparam__bmp);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns the `bitmap` that has been loaded with the specified name, see `load_bitmap`. This will attempt to load the bitmap if it has not been loaded.
    /// </summary>
    /// <param name="name"> The name of the bitmap to check.</param>
    /// <returns>The bitmap with the name specified, which may refer to nothing if the bitmap has not been loaded.</returns>
    public static Bitmap BitmapNamed(string name)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__bitmap_named__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bitmap(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that can be used to access the part of a bitmap related to an individual cell.
    /// </summary>
    /// <param name="src"> The bitmap</param>
    /// <param name="cell"> The cell</param>
    /// <returns>The area of the cell within the bitmap</returns>
    public static Rectangle BitmapRectangleOfCell(Bitmap src, int cell)
    {
      __sklib_ptr __skparam__src;
      int __skparam__cell;
      __sklib_rectangle __skreturn;
      __skparam__src = __skadapter__to_sklib_bitmap(src);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skreturn = __sklib__bitmap_rectangle_of_cell__bitmap__int(__skparam__src, __skparam__cell);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Initialise the bitmap cell details. This allows parts of the bitmap to be drawn as individual cells.
    /// </summary>
    /// <param name="bmp"> The bitmap</param>
    /// <param name="width"> The width of each cell</param>
    /// <param name="height"> The height of each cell</param>
    /// <param name="columns"> The number of cell columns within the bitmap</param>
    /// <param name="rows"> The number of cell rows within the bitmap</param>
    /// <param name="count"> The total number of cells, may be fewer than columns * rows</param>
    public static void BitmapSetCellDetails(Bitmap bmp, int width, int height, int columns, int rows, int count)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__width;
      int __skparam__height;
      int __skparam__columns;
      int __skparam__rows;
      int __skparam__count;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__width = __skadapter__to_sklib_int(width);
      __skparam__height = __skadapter__to_sklib_int(height);
      __skparam__columns = __skadapter__to_sklib_int(columns);
      __skparam__rows = __skadapter__to_sklib_int(rows);
      __skparam__count = __skadapter__to_sklib_int(count);
      __sklib__bitmap_set_cell_details__bitmap__int__int__int__int__int(__skparam__bmp, __skparam__width, __skparam__height, __skparam__columns, __skparam__rows, __skparam__count);
    }
    /// <summary>
    /// Lets you test if bitmap value is valid. This will return true when it is a valid bitmap.
    /// </summary>
    /// <param name="bmp"> the bitmap to test</param>
    /// <returns>true when the bitmap is valid.</returns>
    public static bool BitmapValid(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_valid__bitmap(__skparam__bmp);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the width of the bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap</param>
    /// <returns>The width of the bitmap</returns>
    public static int BitmapWidth(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_width__bitmap(__skparam__bmp);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the width of the bitmap.
    /// </summary>
    /// <param name="name"> The name of the bitmap</param>
    /// <returns>The width of the bitmap</returns>
    public static int BitmapWidth(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__bitmap_width__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Clear the bitmap to the indicated color. This will ensure the entire surface of the bitmap is set to that color.
    /// </summary>
    /// <param name="bmp"> The bitmap</param>
    /// <param name="clr"> The new color for the surface of the bitmap</param>
    public static void ClearBitmap(Bitmap bmp, Color clr)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_color __skparam__clr;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __sklib__clear_bitmap__bitmap__color(__skparam__bmp, __skparam__clr);
    }
    /// <summary>
    /// Clear the bitmap to the indicated color. This will ensure the entire surface of the bitmap is set to that color.
    /// </summary>
    /// <param name="name"> The name of the bitmap</param>
    /// <param name="clr"> The new color for the surface of the bitmap</param>
    public static void ClearBitmap(string name, Color clr)
    {
      __sklib_string __skparam__name;
      __sklib_color __skparam__clr;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __sklib__clear_bitmap__string__color(__skparam__name, __skparam__clr);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Creates a new bitmap that you can draw to. Initially the bitmap will be transparent.
    /// </summary>
    /// <param name="name"> The name of the bitmap resource to be created. If this already exists SplashKit will alter the name to make it unique.</param>
    /// <param name="width"> The width of the created bitmap</param>
    /// <param name="height"> The height of the created bitmap</param>
    /// <returns>A new transparent bitmap</returns>
    public static Bitmap CreateBitmap(string name, int width, int height)
    {
      __sklib_string __skparam__name;
      int __skparam__width;
      int __skparam__height;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__width = __skadapter__to_sklib_int(width);
      __skparam__height = __skadapter__to_sklib_int(height);
      __skreturn = __sklib__create_bitmap__string__int__int(__skparam__name, __skparam__width, __skparam__height);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bitmap(__skreturn);
    }
    /// <summary>
    /// Draws the bitmap supplied into `bmp` to the current window. at `x` and `y`.
    /// </summary>
    /// <param name="bmp"> the bitmap which will be drawn to the screen</param>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    public static void DrawBitmap(Bitmap bmp, double x, double y)
    {
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_bitmap__bitmap__double__double(__skparam__bmp, __skparam__x, __skparam__y);
    }
    /// <summary>
    /// Draws the bitmap supplied into `bmp` to the current window. with extra drawing options supplied in `opts` at `x` and `y`.
    /// </summary>
    /// <param name="bmp"> the bitmap which will be drawn to the screen</param>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    /// <param name="opts"> the `drawing_options` which provide extra information for how to draw the `bitmap`</param>
    public static void DrawBitmap(Bitmap bmp, double x, double y, DrawingOptions opts)
    {
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_bitmap__bitmap__double__double__drawing_options(__skparam__bmp, __skparam__x, __skparam__y, __skparam__opts);
    }
    /// <summary>
    /// Searches and draws a bitmap with name `name` to the current window. with extra drawing options supplied in `opts` at `x` and `y`.
    /// </summary>
    /// <param name="name"> the name of the bitmap which will be drawn to the screen</param>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    public static void DrawBitmap(string name, double x, double y)
    {
      __sklib_string __skparam__name;
      double __skparam__x;
      double __skparam__y;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_bitmap__string__double__double(__skparam__name, __skparam__x, __skparam__y);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Searches and draws a bitmap with name `name` to the current window. with extra drawing options supplied in `opts` at `x` and `y`.
    /// </summary>
    /// <param name="name"> the name of the bitmap which will be drawn to the screen</param>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    /// <param name="opts"> the `drawing_options` which provide extra information for how to draw the `bitmap`</param>
    public static void DrawBitmap(string name, double x, double y, DrawingOptions opts)
    {
      __sklib_string __skparam__name;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_bitmap__string__double__double__drawing_options(__skparam__name, __skparam__x, __skparam__y, __skparam__opts);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Draws the bitmap supplied into `bmp` to the given bitmap. at `x` and `y`.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the bitmap to</param>
    /// <param name="bmp"> the bitmap which will be drawn to the screen</param>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    public static void DrawBitmapOnBitmap(Bitmap destination, Bitmap bmp, double x, double y)
    {
      __sklib_ptr __skparam__destination;
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_bitmap_on_bitmap__bitmap__bitmap__double__double(__skparam__destination, __skparam__bmp, __skparam__x, __skparam__y);
    }
    /// <summary>
    /// Draws the bitmap supplied into `bmp` to the given bitmap. with extra drawing options supplied in `opts` at `x` and `y`.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the bitmap to</param>
    /// <param name="bmp"> the bitmap which will be drawn to the screen</param>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    /// <param name="opts"> the `drawing_options` which provide extra information for how to draw the `bitmap`</param>
    public static void DrawBitmapOnBitmap(Bitmap destination, Bitmap bmp, double x, double y, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_bitmap_on_bitmap__bitmap__bitmap__double__double__drawing_options(__skparam__destination, __skparam__bmp, __skparam__x, __skparam__y, __skparam__opts);
    }
    /// <summary>
    /// Draws the bitmap supplied into `bmp` to the given window. at `x` and `y`.
    /// </summary>
    /// <param name="destination"> the window to draw the bitmap to</param>
    /// <param name="bmp"> the bitmap which will be drawn to the screen</param>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    public static void DrawBitmapOnWindow(Window destination, Bitmap bmp, double x, double y)
    {
      __sklib_ptr __skparam__destination;
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_bitmap_on_window__window__bitmap__double__double(__skparam__destination, __skparam__bmp, __skparam__x, __skparam__y);
    }
    /// <summary>
    /// Draws the bitmap supplied into `bmp` to the given window. with extra drawing options supplied in `opts` at `x` and `y`.
    /// </summary>
    /// <param name="destination"> the window to draw the bitmap to</param>
    /// <param name="bmp"> the bitmap which will be drawn to the screen</param>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    /// <param name="opts"> the `drawing_options` which provide extra information for how to draw the `bitmap`</param>
    public static void DrawBitmapOnWindow(Window destination, Bitmap bmp, double x, double y, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_bitmap_on_window__window__bitmap__double__double__drawing_options(__skparam__destination, __skparam__bmp, __skparam__x, __skparam__y, __skparam__opts);
    }
    /// <summary>
    /// Free all of the loaded bitmap resources.
    /// </summary>
    public static void FreeAllBitmaps()
    {
      __sklib__free_all_bitmaps();
    }
    /// <summary>
    /// Frees the bitmap resource.
    /// </summary>
    /// <param name="toDelete"> The bitmap to be freed.</param>
    public static void FreeBitmap(Bitmap toDelete)
    {
      __sklib_ptr __skparam__to_delete;
      __skparam__to_delete = __skadapter__to_sklib_bitmap(toDelete);
      __sklib__free_bitmap__bitmap(__skparam__to_delete);
    }
    /// <summary>
    /// Determines if SplashKit has a bitmap loaded for the supplied name. This checks against all bitmaps loaded.
    /// </summary>
    /// <param name="name"> The name to check</param>
    /// <returns>True if SplashKit has a bitmap with that name</returns>
    public static bool HasBitmap(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_bitmap__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Loads and returns a bitmap. The supplied `filename` is used to locate the Bitmap to load. The supplied `name` indicates the name to use to refer to this Bitmap in SplashKit. The `bitmap` can then be retrieved by passing this `name` to the `bitmap_named` function.
    /// </summary>
    /// <param name="name"> The name of the bitmap resource in SplashKit</param>
    /// <param name="filename"> The filename to load</param>
    /// <returns>The loaded bitmap</returns>
    public static Bitmap LoadBitmap(string name, string filename)
    {
      __sklib_string __skparam__name;
      __sklib_string __skparam__filename;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __skreturn = __sklib__load_bitmap__string__string(__skparam__name, __skparam__filename);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__filename);
      return __skadapter__to_bitmap(__skreturn);
    }
    /// <summary>
    /// Check if the bitmap has a pixel drawn at the indicated point.
    /// </summary>
    /// <param name="bmp"> The bitmap to check.</param>
    /// <param name="pt"> The point within the bitmap to check.</param>
    /// <returns>True if the pixel at that point in the bitmap is drawn.</returns>
    public static bool PixelDrawnAtPoint(Bitmap bmp, Point2D pt)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__pixel_drawn_at_point__bitmap__point_2d_ref(__skparam__bmp, __skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Check if the bitmap has a pixel drawn at the indicated point.
    /// </summary>
    /// <param name="bmp"> The bitmap to check.</param>
    /// <param name="x"> The x coordinate within the bitmap to check</param>
    /// <param name="y"> The y coordinate within the bitmap to check</param>
    /// <returns>True if the pixel at that point in the bitmap is drawn.</returns>
    public static bool PixelDrawnAtPoint(Bitmap bmp, double x, double y)
    {
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__pixel_drawn_at_point__bitmap__double__double(__skparam__bmp, __skparam__x, __skparam__y);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Check if the bitmap has a pixel drawn at the indicated point in the cell.
    /// </summary>
    /// <param name="bmp"> The bitmap to check.</param>
    /// <param name="cell"> The bitmap cell to check.</param>
    /// <param name="pt"> The point within the bitmap to check.</param>
    /// <returns>True if the pixel at that point in the bitmap's cell is drawn.</returns>
    public static bool PixelDrawnAtPoint(Bitmap bmp, int cell, Point2D pt)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__pixel_drawn_at_point__bitmap__int__point_2d_ref(__skparam__bmp, __skparam__cell, __skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Check if the bitmap has a pixel drawn at the indicated point in the cell.
    /// </summary>
    /// <param name="bmp"> The bitmap to check.</param>
    /// <param name="cell"> The bitmap cell to check.</param>
    /// <param name="x"> The x coordinate within the bitmap to check</param>
    /// <param name="y"> The y coordinate within the bitmap to check</param>
    /// <returns>True if the pixel at that point in the bitmap's cell is drawn.</returns>
    public static bool PixelDrawnAtPoint(Bitmap bmp, int cell, double x, double y)
    {
      __sklib_ptr __skparam__bmp;
      int __skparam__cell;
      double __skparam__x;
      double __skparam__y;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__cell = __skadapter__to_sklib_int(cell);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__pixel_drawn_at_point__bitmap__int__double__double(__skparam__bmp, __skparam__cell, __skparam__x, __skparam__y);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Sets up the collision mask for a bitmap. This enables collision detection between this bitmap and other bitmaps or shapes.  This is automatically called when a bitmap is loaded, and only needs to be  called on bitmaps created using `create_bitmap`, and when a bitmap is changed by drawing onto the bitmap.
    /// </summary>
    /// <param name="bmp"> the bitmap to setup</param>
    public static void SetupCollisionMask(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __sklib__setup_collision_mask__bitmap(__skparam__bmp);
    }
    /// <summary>
    /// ProcessEvents allows SplashKit to react to user interactions. This procedure checks the current keyboard and mouse states and should be called once within your game loop to check user interaction.  Side Effects - Reads user interaction events - Updates keys down, text input, etc.
    /// </summary>
    public static void ProcessEvents()
    {
      __sklib__process_events();
    }
    /// <summary>
    /// Checks to see if the user has asked for the application to quit. This value is updated by the `process_events` routine. Also see `window_close_requested`.
    /// </summary>
    /// <returns>True if the application has been requested to close.</returns>
    public static bool QuitRequested()
    {
      int __skreturn;
      __skreturn = __sklib__quit_requested();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Cancels a quit request, ensuring the quit requested will return false.
    /// </summary>
    public static void ResetQuit()
    {
      __sklib__reset_quit();
    }
    /// <summary>
    /// Adds a column to the current layout with width `width`.  - Positive values of width just specify the width in pixels. - 0 means use the default control width - not always a good choice. - Negative values specify filling to the right _until_ `width + 1` pixels away from the edge. - e.g -1 fills entirely to the right, while -20 leaves a 19 pixel gap on the right.
    /// </summary>
    /// <param name="width"> Width of the column in pixels</param>
    public static void AddColumn(int width)
    {
      int __skparam__width;
      __skparam__width = __skadapter__to_sklib_int(width);
      __sklib__add_column__int(__skparam__width);
    }
    /// <summary>
    /// Adds a column to the current layout with width `width` percentage of the container's width.
    /// </summary>
    /// <param name="width"> Percentage of the container's width (between 0 and 1)</param>
    public static void AddColumnRelative(double width)
    {
      double __skparam__width;
      __skparam__width = __skadapter__to_sklib_double(width);
      __sklib__add_column_relative__double(__skparam__width);
    }
    /// <summary>
    /// Creates a button with a bitmap in it, and no label. Returns whether the button was clicked.
    /// </summary>
    /// <param name="bmp"> The bitmap to show inside the button</param>
    /// <returns>Whether the button was clicked</returns>
    public static bool BitmapButton(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_button__bitmap(__skparam__bmp);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a button with a bitmap in it at a specific position on screen. Returns whether the button was clicked.
    /// </summary>
    /// <param name="bmp"> The bitmap to show inside the button</param>
    /// <param name="rect"> The rectangle to display the button in</param>
    /// <returns>Whether the button was clicked</returns>
    public static bool BitmapButton(Bitmap bmp, Rectangle rect)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__bitmap_button__bitmap__rectangle_ref(__skparam__bmp, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a button with a bitmap in it at a specific position on screen. Returns whether the button was clicked.
    /// </summary>
    /// <param name="bmp"> The bitmap to show inside the button</param>
    /// <param name="rect"> The rectangle to display the button in</param>
    /// <param name="opts"> The drawing options</param>
    /// <returns>Whether the button was clicked</returns>
    public static bool BitmapButton(Bitmap bmp, Rectangle rect, DrawingOptions opts)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__bitmap_button__bitmap__rectangle_ref__drawing_options(__skparam__bmp, __skparam__rect, __skparam__opts);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a button with a bitmap in it, and no label. Returns whether the button was clicked.
    /// </summary>
    /// <param name="bmp"> The bitmap to show inside the button</param>
    /// <param name="opts"> The drawing options</param>
    /// <returns>Whether the button was clicked</returns>
    public static bool BitmapButton(Bitmap bmp, DrawingOptions opts)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_drawing_options __skparam__opts;
      int __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__bitmap_button__bitmap__drawing_options(__skparam__bmp, __skparam__opts);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a button with a bitmap in it and a label. Returns whether the button was clicked.
    /// </summary>
    /// <param name="labelText"> The label to show in front of the button</param>
    /// <param name="bmp"> The bitmap to show inside the button</param>
    /// <returns>Whether the button was clicked</returns>
    public static bool BitmapButton(string labelText, Bitmap bmp)
    {
      __sklib_string __skparam__label_text;
      __sklib_ptr __skparam__bmp;
      int __skreturn;
      __skparam__label_text = __skadapter__to_sklib_string(labelText);
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__bitmap_button__string_ref__bitmap(__skparam__label_text, __skparam__bmp);
    __skadapter__free__sklib_string(ref __skparam__label_text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a button with a bitmap in it and a label. Returns whether the button was clicked.
    /// </summary>
    /// <param name="labelText"> The label to show in front of the button</param>
    /// <param name="bmp"> The bitmap to show inside the button</param>
    /// <param name="opts"> The drawing options</param>
    /// <returns>Whether the button was clicked</returns>
    public static bool BitmapButton(string labelText, Bitmap bmp, DrawingOptions opts)
    {
      __sklib_string __skparam__label_text;
      __sklib_ptr __skparam__bmp;
      __sklib_drawing_options __skparam__opts;
      int __skreturn;
      __skparam__label_text = __skadapter__to_sklib_string(labelText);
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __skreturn = __sklib__bitmap_button__string_ref__bitmap__drawing_options(__skparam__label_text, __skparam__bmp, __skparam__opts);
    __skadapter__free__sklib_string(ref __skparam__label_text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a button at a specific position on screen. Returns whether the button was clicked.
    /// </summary>
    /// <param name="text"> The text to show inside the button</param>
    /// <param name="rect"> The rectangle to display the button in</param>
    /// <returns>Whether the button was clicked</returns>
    public static bool Button(string text, Rectangle rect)
    {
      __sklib_string __skparam__text;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__button__string_ref__rectangle_ref(__skparam__text, __skparam__rect);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a button without a label. Returns whether the button was clicked.
    /// </summary>
    /// <param name="text"> The text to show inside the button</param>
    /// <returns>Whether the button was clicked</returns>
    public static bool Button(string text)
    {
      __sklib_string __skparam__text;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skreturn = __sklib__button__string_ref(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a button with a label. Returns whether the button was clicked.  Example usage: ```c++ // Test if clicked: if (button("Button 1", "Click me!")) { // do stuff.. } ```
    /// </summary>
    /// <param name="labelText"> The label to show in front of the button</param>
    /// <param name="text"> The text to show inside the button</param>
    /// <returns>Whether the button was clicked</returns>
    public static bool Button(string labelText, string text)
    {
      __sklib_string __skparam__label_text;
      __sklib_string __skparam__text;
      int __skreturn;
      __skparam__label_text = __skadapter__to_sklib_string(labelText);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skreturn = __sklib__button__string_ref__string_ref(__skparam__label_text, __skparam__text);
    __skadapter__free__sklib_string(ref __skparam__label_text);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a checkbox at a specific position on screen. Returns the updated value of the checkbox.
    /// </summary>
    /// <param name="text"> The text to show next to the checkbox</param>
    /// <param name="value"> The current value of the checkbox</param>
    /// <param name="rect"> The rectangle to display the checkbox in</param>
    /// <returns>The updated value of the checkbox</returns>
    public static bool Checkbox(string text, bool value, Rectangle rect)
    {
      __sklib_string __skparam__text;
      int __skparam__value;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__value = __skadapter__to_sklib_bool(value);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__checkbox__string_ref__bool_ref__rectangle_ref(__skparam__text, __skparam__value, __skparam__rect);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a checkbox. Returns the updated value of the checkbox.
    /// </summary>
    /// <param name="text"> The text to show next to the checkbox</param>
    /// <param name="value"> The current value of the checkbox</param>
    /// <returns>The updated value of the checkbox</returns>
    public static bool Checkbox(string text, bool value)
    {
      __sklib_string __skparam__text;
      int __skparam__value;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__value = __skadapter__to_sklib_bool(value);
      __skreturn = __sklib__checkbox__string_ref__bool_ref(__skparam__text, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a checkbox with a label. Returns the updated value of the checkbox.  Example usage: ```c++ my_bool = checkbox("Checkbox 1", "Enabled?", my_bool); ```
    /// </summary>
    /// <param name="labelText"> The label to show in front of the checkbox</param>
    /// <param name="text"> The text to show next to the checkbox</param>
    /// <param name="value"> The current value of the checkbox</param>
    /// <returns>The updated value of the checkbox</returns>
    public static bool Checkbox(string labelText, string text, bool value)
    {
      __sklib_string __skparam__label_text;
      __sklib_string __skparam__text;
      int __skparam__value;
      int __skreturn;
      __skparam__label_text = __skadapter__to_sklib_string(labelText);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__value = __skadapter__to_sklib_bool(value);
      __skreturn = __sklib__checkbox__string_ref__string_ref__bool_ref(__skparam__label_text, __skparam__text, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__label_text);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a set of RGBA sliders to adjust a color, at a specific position on screen. Returns the updated color value of the slider.
    /// </summary>
    /// <param name="clr"> The current value of the color slider</param>
    /// <param name="rect"> The rectangle to display the slider in.</param>
    /// <returns>The updated value of the slider</returns>
    public static Color ColorSlider(Color clr, Rectangle rect)
    {
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_color __skreturn;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__color_slider__color_ref__rectangle_ref(__skparam__clr, __skparam__rect);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Creates a set of RGBA sliders to adjust a color. Returns the updated color value of the slider.
    /// </summary>
    /// <param name="clr"> The current value of the color slider</param>
    /// <returns>The updated value of the slider</returns>
    public static Color ColorSlider(Color clr)
    {
      __sklib_color __skparam__clr;
      __sklib_color __skreturn;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skreturn = __sklib__color_slider__color_ref(__skparam__clr);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Creates a set of RGBA sliders to adjust a color, with a label. Returns the updated color value of the slider.  Example usage: ```c++ my_color = color_slider("Player Color", my_color); ```
    /// </summary>
    /// <param name="labelText"> The label to show in front of the slider</param>
    /// <param name="clr"> The current value of the color slider</param>
    /// <returns>The updated value of the slider</returns>
    public static Color ColorSlider(string labelText, Color clr)
    {
      __sklib_string __skparam__label_text;
      __sklib_color __skparam__clr;
      __sklib_color __skreturn;
      __skparam__label_text = __skadapter__to_sklib_string(labelText);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skreturn = __sklib__color_slider__string_ref__color_ref(__skparam__label_text, __skparam__clr);
    __skadapter__free__sklib_string(ref __skparam__label_text);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Disables the interface temporarily. Elements created after this function will appear disabled and cannot be interacted with.
    /// </summary>
    public static void DisableInterface()
    {
      __sklib__disable_interface();
    }
    /// <summary>
    /// Draws the user interface that all the previous calls (such as `start_panel`, `button`, etc) have created.  **Make sure to call this!** Without calling it, the interface won't be visible.
    /// </summary>
    public static void DrawInterface()
    {
      __sklib__draw_interface();
    }
    /// <summary>
    /// Re-enables the interface, reverses the effects of disabling the interface.
    /// </summary>
    public static void EnableInterface()
    {
      __sklib__enable_interface();
    }
    /// <summary>
    /// Finishes the creation of an inset area.
    /// </summary>
    /// <param name="name"> The area's name - must match with `start_inset`</param>
    public static void EndInset(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__end_inset__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Finishes the creation of a panel.
    /// </summary>
    /// <param name="name"> The name shown in the panel's titlebar - must match with `start_panel`</param>
    public static void EndPanel(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__end_panel__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Finishes the creation of a popup.
    /// </summary>
    /// <param name="name"> The popup's name - must match with `start_popup`</param>
    public static void EndPopup(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__end_popup__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Finishes the creation of a tree node.
    /// </summary>
    /// <param name="labelText"> The node's name - must match with `start_treenode`</param>
    public static void EndTreenode(string labelText)
    {
      __sklib_string __skparam__label_text;
      __skparam__label_text = __skadapter__to_sklib_string(labelText);
      __sklib__end_treenode__string_ref(__skparam__label_text);
    __skadapter__free__sklib_string(ref __skparam__label_text);
    }
    /// <summary>
    /// Begins placing elements inside the current column. Must be paired with a call to `leave_column`.
    /// </summary>
    public static void EnterColumn()
    {
      __sklib__enter_column();
    }
    /// <summary>
    /// Returns the width of element labels.  Default is 60 pixels.
    /// </summary>
    /// <returns>The width of labels</returns>
    public static int GetInterfaceLabelWidth()
    {
      int __skreturn;
      __skreturn = __sklib__get_interface_label_width();
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Creates a collapsable header with a label. Returns whether the header is expanded or not.  Note: Unlike `start_panel` and other similar functions, there is no need to 'end' this one. Example usage: ```c++ if (header("Section A")) { // elements inside header go here } ```
    /// </summary>
    /// <param name="labelText"> The label to show in the header</param>
    /// <returns>Whether the header is expanded or not</returns>
    public static bool Header(string labelText)
    {
      __sklib_string __skparam__label_text;
      int __skreturn;
      __skparam__label_text = __skadapter__to_sklib_string(labelText);
      __skreturn = __sklib__header__string_ref(__skparam__label_text);
    __skadapter__free__sklib_string(ref __skparam__label_text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a set of HSBA (hue, saturation, brightness, alpha) sliders to adjust a color, at a specific position on screen. Returns the updated color value of the slider.
    /// </summary>
    /// <param name="clr"> The current value of the color slider</param>
    /// <param name="rect"> The rectangle to display the slider in.</param>
    /// <returns>The updated value of the slider</returns>
    public static Color HSBColorSlider(Color clr, Rectangle rect)
    {
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_color __skreturn;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__hsb_color_slider__color_ref__rectangle_ref(__skparam__clr, __skparam__rect);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Creates a set of HSBA (hue, saturation, brightness, alpha) sliders to adjust a color. Returns the updated color value of the slider.
    /// </summary>
    /// <param name="clr"> The current value of the color slider</param>
    /// <returns>The updated value of the slider</returns>
    public static Color HSBColorSlider(Color clr)
    {
      __sklib_color __skparam__clr;
      __sklib_color __skreturn;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skreturn = __sklib__hsb_color_slider__color_ref(__skparam__clr);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Creates a set of HSBA (hue, saturation, brightness, alpha) sliders to adjust a color, with a label. Returns the updated color value of the slider.  Example usage: ```c++ my_color = hsb_color_slider("Player Color", my_color); ```
    /// </summary>
    /// <param name="labelText"> The label to show in front of the slider</param>
    /// <param name="clr"> The current value of the color slider</param>
    /// <returns>The updated value of the slider</returns>
    public static Color HSBColorSlider(string labelText, Color clr)
    {
      __sklib_string __skparam__label_text;
      __sklib_color __skparam__clr;
      __sklib_color __skreturn;
      __skparam__label_text = __skadapter__to_sklib_string(labelText);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skreturn = __sklib__hsb_color_slider__string_ref__color_ref(__skparam__label_text, __skparam__clr);
    __skadapter__free__sklib_string(ref __skparam__label_text);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns if the interface is currently enabled or not.
    /// </summary>
    /// <returns>Whether the interface is currently enabled or not</returns>
    public static bool InterfaceEnabled()
    {
      int __skreturn;
      __skreturn = __sklib__interface_enabled();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// A utility function to show a 'Style Panel', which will allows you to experiment with different interface styles.
    /// </summary>
    /// <param name="initialRectangle"> The initial position/size the panel starts off in</param>
    public static void InterfaceStylePanel(Rectangle initialRectangle)
    {
      __sklib_rectangle __skparam__initial_rectangle;
      __skparam__initial_rectangle = __skadapter__to_sklib_rectangle(initialRectangle);
      __sklib__interface_style_panel__rectangle_ref(__skparam__initial_rectangle);
    }
    /// <summary>
    /// Creates a label with the given text.
    /// </summary>
    /// <param name="text"> The label to show</param>
    public static void LabelElement(string text)
    {
      __sklib_string __skparam__text;
      __skparam__text = __skadapter__to_sklib_string(text);
      __sklib__label_element__string_ref(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// Creates a label at a specific position on screen.
    /// </summary>
    /// <param name="text"> The label to show</param>
    /// <param name="rect"> The rectangle to display the label in</param>
    public static void LabelElement(string text, Rectangle rect)
    {
      __sklib_string __skparam__text;
      __sklib_rectangle __skparam__rect;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__label_element__string_ref__rectangle_ref(__skparam__text, __skparam__rect);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// Returns if the last created element was changed at all (such as dragged, typed in, etc)
    /// </summary>
    /// <returns>Whether the last created element was changed</returns>
    public static bool LastElementChanged()
    {
      int __skreturn;
      __skreturn = __sklib__last_element_changed();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns if the last created element was 'confirmed' (such as clicking a button, or hitting enter in a text box)
    /// </summary>
    /// <returns>Whether the last created element was confirmed</returns>
    public static bool LastElementConfirmed()
    {
      int __skreturn;
      __skreturn = __sklib__last_element_confirmed();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Stops placing elements inside the current column and moves to the next one.
    /// </summary>
    public static void LeaveColumn()
    {
      __sklib__leave_column();
    }
    /// <summary>
    /// Creates a number entry box at a specific position on screen. Returns the updated value of the number box.
    /// </summary>
    /// <param name="value"> The current value of the number box</param>
    /// <param name="step"> The amount incremented when dragging on the box</param>
    /// <param name="rect"> The rectangle to display the slider in</param>
    /// <returns>The updated value of the slider</returns>
    public static float NumberBox(float value, float step, Rectangle rect)
    {
      float __skparam__value;
      float __skparam__step;
      __sklib_rectangle __skparam__rect;
      float __skreturn;
      __skparam__value = __skadapter__to_sklib_float(value);
      __skparam__step = __skadapter__to_sklib_float(step);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__number_box__float_ref__float__rectangle_ref(__skparam__value, __skparam__step, __skparam__rect);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Creates a number entry box with a label. Returns the updated value of the number box.
    /// </summary>
    /// <param name="value"> The current value of the number box</param>
    /// <param name="step"> The amount incremented when dragging on the box</param>
    /// <returns>The updated value of the slider</returns>
    public static float NumberBox(float value, float step)
    {
      float __skparam__value;
      float __skparam__step;
      float __skreturn;
      __skparam__value = __skadapter__to_sklib_float(value);
      __skparam__step = __skadapter__to_sklib_float(step);
      __skreturn = __sklib__number_box__float_ref__float(__skparam__value, __skparam__step);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Creates a number entry box with a label. Returns the updated value of the number box.  Example usage: ```c++ my_float = number_box("Percentage", my_float, 1); ```
    /// </summary>
    /// <param name="labelText"> The label to show in front of the number box</param>
    /// <param name="value"> The current value of the number box</param>
    /// <param name="step"> The amount incremented when dragging on the box</param>
    /// <returns>The updated value of the slider</returns>
    public static float NumberBox(string labelText, float value, float step)
    {
      __sklib_string __skparam__label_text;
      float __skparam__value;
      float __skparam__step;
      float __skreturn;
      __skparam__label_text = __skadapter__to_sklib_string(labelText);
      __skparam__value = __skadapter__to_sklib_float(value);
      __skparam__step = __skadapter__to_sklib_float(step);
      __skreturn = __sklib__number_box__string_ref__float_ref__float(__skparam__label_text, __skparam__value, __skparam__step);
    __skadapter__free__sklib_string(ref __skparam__label_text);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Makes the popup named `name` open/popup at the cursor's position.
    /// </summary>
    /// <param name="name"> The popup's name. Must match with the same name used in `start_popup`</param>
    public static void OpenPopup(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__open_popup__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Creates a paragraph of text that auto-wraps.
    /// </summary>
    /// <param name="text"> The text to show</param>
    public static void Paragraph(string text)
    {
      __sklib_string __skparam__text;
      __skparam__text = __skadapter__to_sklib_string(text);
      __sklib__paragraph__string_ref(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// Creates a paragraph of text that auto-wraps at a specific position on screen.
    /// </summary>
    /// <param name="text"> The text to show</param>
    /// <param name="rect"> The rectangle to display the label in</param>
    public static void Paragraph(string text, Rectangle rect)
    {
      __sklib_string __skparam__text;
      __sklib_rectangle __skparam__rect;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__paragraph__string_ref__rectangle_ref(__skparam__text, __skparam__rect);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// Resets to the default layout of a single column with default height.
    /// </summary>
    public static void ResetLayout()
    {
      __sklib__reset_layout();
    }
    /// <summary>
    /// Sets the color of accents in the interface, and the contrast of how strongly they appear when hovering/interacting.
    /// </summary>
    /// <param name="clr"> The color of accents</param>
    /// <param name="contrast"> The strength of how much the accents show (between 0 and 1)</param>
    public static void SetInterfaceAccentColor(Color clr, float contrast)
    {
      __sklib_color __skparam__clr;
      float __skparam__contrast;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__contrast = __skadapter__to_sklib_float(contrast);
      __sklib__set_interface_accent_color__color__float(__skparam__clr, __skparam__contrast);
    }
    /// <summary>
    /// Sets the interface's border color.
    /// </summary>
    /// <param name="clr"> The color to set borders to</param>
    public static void SetInterfaceBorderColor(Color clr)
    {
      __sklib_color __skparam__clr;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __sklib__set_interface_border_color__color(__skparam__clr);
    }
    /// <summary>
    /// A convenience function to set the majority of the interface's colors in one go. Some colors will be automatically chosen based on the parameters (such as text color).
    /// </summary>
    /// <param name="mainClr"> The main color of the interface - also decides if the interface is light or dark mode</param>
    /// <param name="accentClr"> The color used to accent the interface - this will appear in highlighted areas</param>
    /// <param name="contrast"> The contrast between the frames of elements/containers and their internal elements</param>
    /// <param name="accentContrast"> How strongly the accent color is used, for instance when highlighting elements</param>
    /// <param name="borderContrast"> Simply the opacity of the borders</param>
    public static void SetInterfaceColorsAuto(Color mainClr, Color accentClr, float contrast, float accentContrast, float borderContrast)
    {
      __sklib_color __skparam__main_clr;
      __sklib_color __skparam__accent_clr;
      float __skparam__contrast;
      float __skparam__accent_contrast;
      float __skparam__border_contrast;
      __skparam__main_clr = __skadapter__to_sklib_color(mainClr);
      __skparam__accent_clr = __skadapter__to_sklib_color(accentClr);
      __skparam__contrast = __skadapter__to_sklib_float(contrast);
      __skparam__accent_contrast = __skadapter__to_sklib_float(accentContrast);
      __skparam__border_contrast = __skadapter__to_sklib_float(borderContrast);
      __sklib__set_interface_colors_auto__color__color__float__float__float(__skparam__main_clr, __skparam__accent_clr, __skparam__contrast, __skparam__accent_contrast, __skparam__border_contrast);
    }
    /// <summary>
    /// Sets the main color of elements in the interface, and the contrast between their frame and internal pieces.
    /// </summary>
    /// <param name="clr"> The color of elements</param>
    /// <param name="contrast"> The contrast between the frame of elements and their internal pieces (between 0 and 1)</param>
    public static void SetInterfaceElementColor(Color clr, float contrast)
    {
      __sklib_color __skparam__clr;
      float __skparam__contrast;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__contrast = __skadapter__to_sklib_float(contrast);
      __sklib__set_interface_element_color__color__float(__skparam__clr, __skparam__contrast);
    }
    /// <summary>
    /// Sets the style of element's shadows. Use a fully transparent color to disable them.
    /// </summary>
    /// <param name="radius"> The radius of the shadow's blur</param>
    /// <param name="clr"> The color of the shadows (commonly black, but can do coloured and semi-transparent too)</param>
    /// <param name="offset"> The offset in x/y coordinates of the shadows from their casting elements</param>
    public static void SetInterfaceElementShadows(int radius, Color clr, Point2D offset)
    {
      int __skparam__radius;
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__offset;
      __skparam__radius = __skadapter__to_sklib_int(radius);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__offset = __skadapter__to_sklib_point_2d(offset);
      __sklib__set_interface_element_shadows__int__color__point_2d(__skparam__radius, __skparam__clr, __skparam__offset);
    }
    /// <summary>
    /// Sets the interface's font.
    /// </summary>
    /// <param name="fnt"> The name of the font to be used</param>
    public static void SetInterfaceFont(string fnt)
    {
      __sklib_string __skparam__fnt;
      __skparam__fnt = __skadapter__to_sklib_string(fnt);
      __sklib__set_interface_font__string_ref(__skparam__fnt);
    __skadapter__free__sklib_string(ref __skparam__fnt);
    }
    /// <summary>
    /// Sets the interface's font.
    /// </summary>
    /// <param name="fnt"> The font to be used</param>
    public static void SetInterfaceFont(Font fnt)
    {
      __sklib_ptr __skparam__fnt;
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __sklib__set_interface_font__font(__skparam__fnt);
    }
    /// <summary>
    /// Sets the interface's font size.
    /// </summary>
    /// <param name="size"> The font size to be used</param>
    public static void SetInterfaceFontSize(int size)
    {
      int __skparam__size;
      __skparam__size = __skadapter__to_sklib_int(size);
      __sklib__set_interface_font_size__int(__skparam__size);
    }
    /// <summary>
    /// Sets the width of element labels. This is the maximum width in pixels that a label can span in front of an element.  Default is 60 pixels.
    /// </summary>
    /// <param name="width"> The width of labels</param>
    public static void SetInterfaceLabelWidth(int width)
    {
      int __skparam__width;
      __skparam__width = __skadapter__to_sklib_int(width);
      __sklib__set_interface_label_width__int(__skparam__width);
    }
    /// <summary>
    /// Sets the style of panel's shadows. Use a fully transparent color to disable them.
    /// </summary>
    /// <param name="radius"> The radius of the shadow's blur</param>
    /// <param name="clr"> The color of the shadows (commonly black, but can do coloured and semi-transparent too)</param>
    /// <param name="offset"> The offset in x/y coordinates of the shadows from their casting elements</param>
    public static void SetInterfacePanelShadows(int radius, Color clr, Point2D offset)
    {
      int __skparam__radius;
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__offset;
      __skparam__radius = __skadapter__to_sklib_int(radius);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__offset = __skadapter__to_sklib_point_2d(offset);
      __sklib__set_interface_panel_shadows__int__color__point_2d(__skparam__radius, __skparam__clr, __skparam__offset);
    }
    /// <summary>
    /// Sets color of text drawn directly onto the main window
    /// </summary>
    /// <param name="clr"> The color to set text drawn on the main window to</param>
    public static void SetInterfaceRootTextColor(Color clr)
    {
      __sklib_color __skparam__clr;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __sklib__set_interface_root_text_color__color(__skparam__clr);
    }
    /// <summary>
    /// Sets the style of all interface shadows. Use a fully transparent color to disable them.
    /// </summary>
    /// <param name="radius"> The radius of the shadow's blur</param>
    /// <param name="clr"> The color of the shadows (commonly black, but can do coloured and semi-transparent too)</param>
    /// <param name="offset"> The offset in x/y coordinates of the shadows from their casting elements</param>
    public static void SetInterfaceShadows(int radius, Color clr, Point2D offset)
    {
      int __skparam__radius;
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__offset;
      __skparam__radius = __skadapter__to_sklib_int(radius);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__offset = __skadapter__to_sklib_point_2d(offset);
      __sklib__set_interface_shadows__int__color__point_2d(__skparam__radius, __skparam__clr, __skparam__offset);
    }
    /// <summary>
    /// Sets the spacing within the interface.
    /// </summary>
    /// <param name="spacing"> The distance between elements</param>
    /// <param name="padding"> The padding within elements</param>
    public static void SetInterfaceSpacing(int spacing, int padding)
    {
      int __skparam__spacing;
      int __skparam__padding;
      __skparam__spacing = __skadapter__to_sklib_int(spacing);
      __skparam__padding = __skadapter__to_sklib_int(padding);
      __sklib__set_interface_spacing__int__int(__skparam__spacing, __skparam__padding);
    }
    /// <summary>
    /// Sets the interface style to one of the presets in the interface_style enum.
    /// </summary>
    /// <param name="style"> The preset style to use</param>
    public static void SetInterfaceStyle(InterfaceStyle style)
    {
      int __skparam__style;
      __skparam__style = __skadapter__to_sklib_interface_style(style);
      __sklib__set_interface_style__interface_style(__skparam__style);
    }
    /// <summary>
    /// Sets the interface style to one of the presets in the interface_style enum. Also accepts a color used to customize the interface.
    /// </summary>
    /// <param name="style"> The preset style to use</param>
    /// <param name="clr"> The color to style the interface after</param>
    public static void SetInterfaceStyle(InterfaceStyle style, Color clr)
    {
      int __skparam__style;
      __sklib_color __skparam__clr;
      __skparam__style = __skadapter__to_sklib_interface_style(style);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __sklib__set_interface_style__interface_style__color(__skparam__style, __skparam__clr);
    }
    /// <summary>
    /// Sets the interface's text color.
    /// </summary>
    /// <param name="clr"> The color to set text to</param>
    public static void SetInterfaceTextColor(Color clr)
    {
      __sklib_color __skparam__clr;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __sklib__set_interface_text_color__color(__skparam__clr);
    }
    /// <summary>
    /// Sets the height of each row in the interface in pixels. 0 resets to default.
    /// </summary>
    /// <param name="height"> Height of rows in pixels</param>
    public static void SetLayoutHeight(int height)
    {
      int __skparam__height;
      __skparam__height = __skadapter__to_sklib_int(height);
      __sklib__set_layout_height__int(__skparam__height);
    }
    /// <summary>
    /// Starts layouting all elements onto a single row. Reset with `reset_layout()`.
    /// </summary>
    public static void SingleLineLayout()
    {
      __sklib__single_line_layout();
    }
    /// <summary>
    /// Creates a slider at a specific position on screen. Returns the updated value of the slider.
    /// </summary>
    /// <param name="value"> The current value of the slider</param>
    /// <param name="minValue"> The minimum value of the slider</param>
    /// <param name="maxValue"> The maximum value of the slider</param>
    /// <param name="rect"> The rectangle to display the slider in</param>
    /// <returns>The updated value of the slider</returns>
    public static float Slider(float value, float minValue, float maxValue, Rectangle rect)
    {
      float __skparam__value;
      float __skparam__min_value;
      float __skparam__max_value;
      __sklib_rectangle __skparam__rect;
      float __skreturn;
      __skparam__value = __skadapter__to_sklib_float(value);
      __skparam__min_value = __skadapter__to_sklib_float(minValue);
      __skparam__max_value = __skadapter__to_sklib_float(maxValue);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__slider__float_ref__float__float__rectangle_ref(__skparam__value, __skparam__min_value, __skparam__max_value, __skparam__rect);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Creates a slider without a label. Returns the updated value of the slider.
    /// </summary>
    /// <param name="value"> The current value of the slider</param>
    /// <param name="minValue"> The minimum value of the slider</param>
    /// <param name="maxValue"> The maximum value of the slider</param>
    /// <returns>The updated value of the slider</returns>
    public static float Slider(float value, float minValue, float maxValue)
    {
      float __skparam__value;
      float __skparam__min_value;
      float __skparam__max_value;
      float __skreturn;
      __skparam__value = __skadapter__to_sklib_float(value);
      __skparam__min_value = __skadapter__to_sklib_float(minValue);
      __skparam__max_value = __skadapter__to_sklib_float(maxValue);
      __skreturn = __sklib__slider__float_ref__float__float(__skparam__value, __skparam__min_value, __skparam__max_value);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Creates a slider with a label. Returns the updated value of the slider.  Example usage: ```c++ my_float = slider("Percentage", my_float, 0, 100); ```
    /// </summary>
    /// <param name="labelText"> The label to show in front of the slider</param>
    /// <param name="value"> The current value of the slider</param>
    /// <param name="minValue"> The minimum value of the slider</param>
    /// <param name="maxValue"> The maximum value of the slider</param>
    /// <returns>The updated value of the slider</returns>
    public static float Slider(string labelText, float value, float minValue, float maxValue)
    {
      __sklib_string __skparam__label_text;
      float __skparam__value;
      float __skparam__min_value;
      float __skparam__max_value;
      float __skreturn;
      __skparam__label_text = __skadapter__to_sklib_string(labelText);
      __skparam__value = __skadapter__to_sklib_float(value);
      __skparam__min_value = __skadapter__to_sklib_float(minValue);
      __skparam__max_value = __skadapter__to_sklib_float(maxValue);
      __skreturn = __sklib__slider__string_ref__float_ref__float__float(__skparam__label_text, __skparam__value, __skparam__min_value, __skparam__max_value);
    __skadapter__free__sklib_string(ref __skparam__label_text);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Adds `count` columns to the current layout, with equal widths
    /// </summary>
    /// <param name="count"> Number of columns to add</param>
    public static void SplitIntoColumns(int count)
    {
      int __skparam__count;
      __skparam__count = __skadapter__to_sklib_int(count);
      __sklib__split_into_columns__int(__skparam__count);
    }
    /// <summary>
    /// Adds `count` columns to the current layout, with equal widths. Has extra parameter `last_width`, which lets you specify a specific width (in pixels) for the last column.
    /// </summary>
    /// <param name="count"> Number of columns to add</param>
    /// <param name="lastWidth"> The width of the last column in pixels</param>
    public static void SplitIntoColumns(int count, int lastWidth)
    {
      int __skparam__count;
      int __skparam__last_width;
      __skparam__count = __skadapter__to_sklib_int(count);
      __skparam__last_width = __skadapter__to_sklib_int(lastWidth);
      __sklib__split_into_columns__int__int(__skparam__count, __skparam__last_width);
    }
    /// <summary>
    /// Adds `count` columns to the current layout, with equal widths. Has extra parameter `last_width`, which lets you specify a specific width (relative to the width of the container, between 0 and 1) for the last column.
    /// </summary>
    /// <param name="count"> Number of columns to add</param>
    /// <param name="lastWidth"> The width of the last column as percentage of the container's width (between 0 and 1)</param>
    public static void SplitIntoColumnsRelative(int count, double lastWidth)
    {
      int __skparam__count;
      double __skparam__last_width;
      __skparam__count = __skadapter__to_sklib_int(count);
      __skparam__last_width = __skadapter__to_sklib_double(lastWidth);
      __sklib__split_into_columns_relative__int__double(__skparam__count, __skparam__last_width);
    }
    /// <summary>
    /// Clears the default layout so that a custom layout can be made.
    /// </summary>
    public static void StartCustomLayout()
    {
      __sklib__start_custom_layout();
    }
    /// <summary>
    /// Starts the creation of an inset area inside an arbitrary rectangle.  The function **must** be accompanied by a call to `end_inset` with the same name.
    /// </summary>
    /// <param name="name"> The name of the area</param>
    /// <param name="rect"> The rectangle for the inset</param>
    public static void StartInset(string name, Rectangle rect)
    {
      __sklib_string __skparam__name;
      __sklib_rectangle __skparam__rect;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__start_inset__string_ref__rectangle_ref(__skparam__name, __skparam__rect);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Starts the creation of an inset area inside a panel/popup.  Use as follows: ```c++ start_inset("Inset area", 60); // elements inside area goes here end_inset("Inset area");  ``` The function **must** be accompanied by a call to `end_inset` with the same name.
    /// </summary>
    /// <param name="name"> The name of the area</param>
    /// <param name="height"> Height of the inset area in pixels. -1 fills entire space. Use negative heights to fill _up to_ `height` away from the bottom</param>
    public static void StartInset(string name, int height)
    {
      __sklib_string __skparam__name;
      int __skparam__height;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__height = __skadapter__to_sklib_int(height);
      __sklib__start_inset__string_ref__int(__skparam__name, __skparam__height);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Starts the creation of a draggable panel with a title bar. Returns whether the panel is visible or not.  Use as follows: ```c++ if (start_panel("My panel", rectangle_from(0,0,100,100))) { // Rest of interface goes here end_panel("My panel"); } ``` After calling this, you can then call functions to add elements such as buttons and text boxes inside the panel. The function **must** be accompanied by a call to `end_panel`, that is only called if the panel is visible, and is passed the same `name`.
    /// </summary>
    /// <param name="name"> The name shown in the panel's titlebar</param>
    /// <param name="initialRectangle"> The initial position/size the panel starts off in</param>
    /// <returns>Whether the panel is visible or not</returns>
    public static bool StartPanel(string name, Rectangle initialRectangle)
    {
      __sklib_string __skparam__name;
      __sklib_rectangle __skparam__initial_rectangle;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__initial_rectangle = __skadapter__to_sklib_rectangle(initialRectangle);
      __skreturn = __sklib__start_panel__string_ref__rectangle(__skparam__name, __skparam__initial_rectangle);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Starts the creation of a popup. Returns whether the popup is visible or not.  Usage is the same as `start_panel`, other than the 'starting rectangle' will be automatically calculated. The function **must** be accompanied by a call to `end_popup` with the same name.
    /// </summary>
    /// <param name="name"> The name of the popup</param>
    /// <returns>Whether the popup is visible or not</returns>
    public static bool StartPopup(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__start_popup__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Starts the creation of a tree node (such as those in a file tree view). Returns whether the tree node is expanded or not.  Usage is the same as `start_panel`. The function **must** be accompanied by a call to `end_treenode` with the same name.
    /// </summary>
    /// <param name="labelText"> The name of the node</param>
    /// <returns>Whether the tree node is expanded or not</returns>
    public static bool StartTreenode(string labelText)
    {
      __sklib_string __skparam__label_text;
      int __skreturn;
      __skparam__label_text = __skadapter__to_sklib_string(labelText);
      __skreturn = __sklib__start_treenode__string_ref(__skparam__label_text);
    __skadapter__free__sklib_string(ref __skparam__label_text);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Creates a text entry box with a label. Returns the updated value of the text box.
    /// </summary>
    /// <param name="value"> The current value of the text box</param>
    /// <returns>The updated value of the text box</returns>
    public static string TextBox(string value)
    {
      __sklib_string __skparam__value;
      __sklib_string __skreturn;
      __skparam__value = __skadapter__to_sklib_string(value);
      __skreturn = __sklib__text_box__string_ref(__skparam__value);
    __skadapter__free__sklib_string(ref __skparam__value);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Creates a text entry box at a specific position on screen. Returns the updated value of the text box.  Example usage: ```c++ my_string = text_box("Name", my_string); ```
    /// </summary>
    /// <param name="value"> The current value of the text box</param>
    /// <param name="rect"> The rectangle to display the button in</param>
    /// <returns>The updated value of the text box</returns>
    public static string TextBox(string value, Rectangle rect)
    {
      __sklib_string __skparam__value;
      __sklib_rectangle __skparam__rect;
      __sklib_string __skreturn;
      __skparam__value = __skadapter__to_sklib_string(value);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__text_box__string_ref__rectangle_ref(__skparam__value, __skparam__rect);
    __skadapter__free__sklib_string(ref __skparam__value);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Creates a text entry box with a label. Returns the updated value of the text box.  Example usage: ```c++ my_string = text_box("Name", my_string); ```
    /// </summary>
    /// <param name="labelText"> The label to show in front of the text box</param>
    /// <param name="value"> The current value of the text box</param>
    /// <returns>The updated value of the text box</returns>
    public static string TextBox(string labelText, string value)
    {
      __sklib_string __skparam__label_text;
      __sklib_string __skparam__value;
      __sklib_string __skreturn;
      __skparam__label_text = __skadapter__to_sklib_string(labelText);
      __skparam__value = __skadapter__to_sklib_string(value);
      __skreturn = __sklib__text_box__string_ref__string_ref(__skparam__label_text, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__label_text);
    __skadapter__free__sklib_string(ref __skparam__value);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// The empty `json` object returned can be filled with data and read by the functions and procedures prefixed with `json_add_` and `json_read_`
    /// </summary>
    /// <returns>Returns an empty `json` object.</returns>
    public static Json CreateJson()
    {
      __sklib_ptr __skreturn;
      __skreturn = __sklib__create_json();
      return __skadapter__to_json(__skreturn);
    }
    /// <summary>
    /// `string json_string` must be valid JSON. The `json` object returned can be filled with data and read by the functions and procedures prefixed with `json_add_` and `json_read_`
    /// </summary>
    /// <param name="jsonString"> The JSON formatted `string` to be converted to a `json` object.</param>
    /// <returns>Returns a `json` object filled with data from the parameter `string`.</returns>
    public static Json CreateJson(string jsonString)
    {
      __sklib_string __skparam__json_string;
      __sklib_ptr __skreturn;
      __skparam__json_string = __skadapter__to_sklib_string(jsonString);
      __skreturn = __sklib__create_json__string(__skparam__json_string);
    __skadapter__free__sklib_string(ref __skparam__json_string);
      return __skadapter__to_json(__skreturn);
    }
    /// <summary>
    /// Releases all of the `json` objects which have been loaded.
    /// </summary>
    public static void FreeAllJson()
    {
      __sklib__free_all_json();
    }
    /// <summary>
    /// Frees the SplashKit resources associated with the `json` object.
    /// </summary>
    /// <param name="j"> The `json` object whose resources should be released.</param>
    public static void FreeJson(Json j)
    {
      __sklib_ptr __skparam__j;
      __skparam__j = __skadapter__to_sklib_json(j);
      __sklib__free_json__json(__skparam__j);
    }
    /// <summary>
    /// Returns the count of keys in the top-level `json` object.
    /// </summary>
    /// <param name="j"> The `json` object to count keys.</param>
    /// <returns>The count of keys in the top-level `json` object.</returns>
    public static int JsonCountKeys(Json j)
    {
      __sklib_ptr __skparam__j;
      int __skreturn;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skreturn = __sklib__json_count_keys__json(__skparam__j);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Converts a `color` to a `json` object.
    /// </summary>
    /// <param name="clr"> The `color` to convert to `json`.</param>
    /// <returns>The `color` serialized into a `json` object.</returns>
    public static Json JsonFromColor(Color clr)
    {
      __sklib_color __skparam__clr;
      __sklib_ptr __skreturn;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skreturn = __sklib__json_from_color__color(__skparam__clr);
      return __skadapter__to_json(__skreturn);
    }
    /// <summary>
    /// Reads a `json` object from a JSON string stored in `Resources/json/filename` and loads the data into the returned `json` object.
    /// </summary>
    /// <param name="filename"> The filename of the file to be written to `Resources/json/`.</param>
    /// <returns>Returns the `json` object loaded from the JSON file in `filename`.</returns>
    public static Json JsonFromFile(string filename)
    {
      __sklib_string __skparam__filename;
      __sklib_ptr __skreturn;
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __skreturn = __sklib__json_from_file__string_ref(__skparam__filename);
    __skadapter__free__sklib_string(ref __skparam__filename);
      return __skadapter__to_json(__skreturn);
    }
    /// <summary>
    /// Reads a `json` object from a `string` in the JSON format.
    /// </summary>
    /// <param name="jString"> A `string` in the JSON format.</param>
    /// <returns>Returns a `json` object loaded with data from `string j_string`.</returns>
    public static Json JsonFromString(string jString)
    {
      __sklib_string __skparam__j_string;
      __sklib_ptr __skreturn;
      __skparam__j_string = __skadapter__to_sklib_string(jString);
      __skreturn = __sklib__json_from_string__string_ref(__skparam__j_string);
    __skadapter__free__sklib_string(ref __skparam__j_string);
      return __skadapter__to_json(__skreturn);
    }
    /// <summary>
    /// Checks if the `json` object contains the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object to check for the given key.</param>
    /// <param name="key"> The `string` key to be checked.</param>
    /// <returns>Returns `true` if the `json j` object contains a key for `string` key.</returns>
    public static bool JsonHasKey(Json j, string key)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      int __skreturn;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skreturn = __sklib__json_has_key__json__string(__skparam__j, __skparam__key);
    __skadapter__free__sklib_string(ref __skparam__key);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Reads an array of `double` values from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object from which data will be returned for the given key.</param>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <param name="outResult"> The array which will be filled with the data stored for `string` key.</param>
    public static void JsonReadArray(Json j, string key, ref List<double> outResult)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      __sklib_vector_double __skparam__out_result;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__out_result = __skadapter__to_sklib_vector_double(outResult);
      __sklib__json_read_array__json__string__vector_double_ref(__skparam__j, __skparam__key, ref __skparam__out_result);
      outResult = __skadapter__to_vector_double(__skparam__out_result);
    __skadapter__free__sklib_string(ref __skparam__key);
    __skadapter__free__sklib_vector_double(ref __skparam__out_result);
    }
    /// <summary>
    /// Reads an array of `json` object values from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object from which data will be returned for the given key.</param>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <param name="outResult"> The array which will be filled with the data stored for `string` key.</param>
    public static void JsonReadArray(Json j, string key, ref List<Json> outResult)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      __sklib_vector_json __skparam__out_result;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__out_result = __skadapter__to_sklib_vector_json(outResult);
      __sklib__json_read_array__json__string__vector_json_ref(__skparam__j, __skparam__key, ref __skparam__out_result);
      outResult = __skadapter__to_vector_json(__skparam__out_result);
    __skadapter__free__sklib_string(ref __skparam__key);
    __skadapter__free__sklib_vector_json(ref __skparam__out_result);
    }
    /// <summary>
    /// Reads an array of `string` values from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object from which data will be returned for the given key.</param>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <param name="outResult"> The array which will be filled with the data stored for `string` key.</param>
    public static void JsonReadArray(Json j, string key, ref List<string> outResult)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      __sklib_vector_string __skparam__out_result;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__out_result = __skadapter__to_sklib_vector_string(outResult);
      __sklib__json_read_array__json__string__vector_string_ref(__skparam__j, __skparam__key, ref __skparam__out_result);
      outResult = __skadapter__to_vector_string(__skparam__out_result);
    __skadapter__free__sklib_string(ref __skparam__key);
    __skadapter__free__sklib_vector_string(ref __skparam__out_result);
    }
    /// <summary>
    /// Reads an array of `bool` values from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object from which data will be returned for the given key.</param>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <param name="outResult"> The array which will be filled with the data stored for `string` key.</param>
    public static void JsonReadArray(Json j, string key, ref List<bool> outResult)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      __sklib_vector_bool __skparam__out_result;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__out_result = __skadapter__to_sklib_vector_bool(outResult);
      __sklib__json_read_array__json__string__vector_bool_ref(__skparam__j, __skparam__key, ref __skparam__out_result);
      outResult = __skadapter__to_vector_bool(__skparam__out_result);
    __skadapter__free__sklib_string(ref __skparam__key);
    __skadapter__free__sklib_vector_bool(ref __skparam__out_result);
    }
    /// <summary>
    /// Reads a `bool` value from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object from which data will be returned for the given key.</param>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <returns>Returns the `bool` value stored at the `string` key.</returns>
    public static bool JsonReadBool(Json j, string key)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      int __skreturn;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skreturn = __sklib__json_read_bool__json__string(__skparam__j, __skparam__key);
    __skadapter__free__sklib_string(ref __skparam__key);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Reads a `float` value from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object from which data will be returned for the given key.</param>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <returns>Returns the `float` value stored at the `string` key.</returns>
    public static float JsonReadNumber(Json j, string key)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      float __skreturn;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skreturn = __sklib__json_read_number__json__string(__skparam__j, __skparam__key);
    __skadapter__free__sklib_string(ref __skparam__key);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Reads a `double` value from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object from which data will be returned for the given key.</param>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <returns>Returns the `double` value stored at the `string` key.</returns>
    public static double JsonReadNumberAsDouble(Json j, string key)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      double __skreturn;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skreturn = __sklib__json_read_number_as_double__json__string(__skparam__j, __skparam__key);
    __skadapter__free__sklib_string(ref __skparam__key);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Reads a `integer` value from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object from which data will be returned for the given key.</param>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <returns>Returns the `integer` value stored at the `string` key.</returns>
    public static int JsonReadNumberAsInt(Json j, string key)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      int __skreturn;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skreturn = __sklib__json_read_number_as_int__json__string(__skparam__j, __skparam__key);
    __skadapter__free__sklib_string(ref __skparam__key);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Reads a `json` object value from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object from which data will be returned for the given key.</param>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <returns>Returns the `json` object value stored at the `string` key.</returns>
    public static Json JsonReadObject(Json j, string key)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      __sklib_ptr __skreturn;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skreturn = __sklib__json_read_object__json__string(__skparam__j, __skparam__key);
    __skadapter__free__sklib_string(ref __skparam__key);
      return __skadapter__to_json(__skreturn);
    }
    /// <summary>
    /// Reads a `string` value from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object from which data will be returned for the given key.</param>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <returns>Returns the `string` value stored at the `string` key.</returns>
    public static string JsonReadString(Json j, string key)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      __sklib_string __skreturn;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skreturn = __sklib__json_read_string__json__string(__skparam__j, __skparam__key);
    __skadapter__free__sklib_string(ref __skparam__key);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Adds an array of `string` values to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object where data will be inserted for the given key.</param>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public static void JsonSetArray(Json j, string key, List<string> value)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      __sklib_vector_string __skparam__value;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__value = __skadapter__to_sklib_vector_string(value);
      __sklib__json_set_array__json__string__vector_string(__skparam__j, __skparam__key, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__key);
    __skadapter__free__sklib_vector_string(ref __skparam__value);
    }
    /// <summary>
    /// Adds an array of `double` values to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object where data will be inserted for the given key.</param>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public static void JsonSetArray(Json j, string key, List<double> value)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      __sklib_vector_double __skparam__value;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__value = __skadapter__to_sklib_vector_double(value);
      __sklib__json_set_array__json__string__vector_double(__skparam__j, __skparam__key, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__key);
    __skadapter__free__sklib_vector_double(ref __skparam__value);
    }
    /// <summary>
    /// Adds an array of `bool` values to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object where data will be inserted for the given key.</param>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public static void JsonSetArray(Json j, string key, List<bool> value)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      __sklib_vector_bool __skparam__value;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__value = __skadapter__to_sklib_vector_bool(value);
      __sklib__json_set_array__json__string__vector_bool(__skparam__j, __skparam__key, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__key);
    __skadapter__free__sklib_vector_bool(ref __skparam__value);
    }
    /// <summary>
    /// Adds an array of `json` object values to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object where data will be inserted for the given key.</param>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public static void JsonSetArray(Json j, string key, List<Json> value)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      __sklib_vector_json __skparam__value;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__value = __skadapter__to_sklib_vector_json(value);
      __sklib__json_set_array__json__string__vector_json(__skparam__j, __skparam__key, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__key);
    __skadapter__free__sklib_vector_json(ref __skparam__value);
    }
    /// <summary>
    /// Adds a `bool` value to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object where data will be inserted for the given key.</param>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public static void JsonSetBool(Json j, string key, bool value)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      int __skparam__value;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__value = __skadapter__to_sklib_bool(value);
      __sklib__json_set_bool__json__string__bool(__skparam__j, __skparam__key, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__key);
    }
    /// <summary>
    /// Adds an `int` value to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object where data will be inserted for the given key.</param>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public static void JsonSetNumber(Json j, string key, int value)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      int __skparam__value;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__value = __skadapter__to_sklib_int(value);
      __sklib__json_set_number__json__string__int(__skparam__j, __skparam__key, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__key);
    }
    /// <summary>
    /// Adds a `double` value to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object where data will be inserted for the given key.</param>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public static void JsonSetNumber(Json j, string key, double value)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      double __skparam__value;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__value = __skadapter__to_sklib_double(value);
      __sklib__json_set_number__json__string__double(__skparam__j, __skparam__key, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__key);
    }
    /// <summary>
    /// Adds a `float` value to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object where data will be inserted for the given key.</param>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public static void JsonSetNumber(Json j, string key, float value)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      float __skparam__value;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__value = __skadapter__to_sklib_float(value);
      __sklib__json_set_number__json__string__float(__skparam__j, __skparam__key, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__key);
    }
    /// <summary>
    /// Adds a `json` object to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object where data will be inserted for the given key.</param>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="obj"> The value to be inserted into the `json` object.</param>
    public static void JsonSetObject(Json j, string key, Json obj)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      __sklib_ptr __skparam__obj;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__obj = __skadapter__to_sklib_json(obj);
      __sklib__json_set_object__json__string__json(__skparam__j, __skparam__key, __skparam__obj);
    __skadapter__free__sklib_string(ref __skparam__key);
    }
    /// <summary>
    /// Adds a `string` value to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="j"> The `json` object where data will be inserted for the given key.</param>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public static void JsonSetString(Json j, string key, string value)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__key;
      __sklib_string __skparam__value;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__key = __skadapter__to_sklib_string(key);
      __skparam__value = __skadapter__to_sklib_string(value);
      __sklib__json_set_string__json__string__string(__skparam__j, __skparam__key, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__key);
    __skadapter__free__sklib_string(ref __skparam__value);
    }
    /// <summary>
    /// Converts a `json` object to a `color` object.
    /// </summary>
    /// <param name="j"> The `json` to convert to a `color`.</param>
    /// <returns>The `color` deserialized from the `json` object.</returns>
    public static Color JsonToColor(Json j)
    {
      __sklib_ptr __skparam__j;
      __sklib_color __skreturn;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skreturn = __sklib__json_to_color__json(__skparam__j);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Writes the `json` object to a JSON string stored in `Resources/json/filename`.
    /// </summary>
    /// <param name="j"> The `json` object to be written to file.</param>
    /// <param name="filename"> The filename of the file to be stored in `Resources/json/`</param>
    public static void JsonToFile(Json j, string filename)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skparam__filename;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __sklib__json_to_file__json__string_ref(__skparam__j, __skparam__filename);
    __skadapter__free__sklib_string(ref __skparam__filename);
    }
    /// <summary>
    /// Converts and returns the `json` object as a `string`.
    /// </summary>
    /// <param name="j"> The `json` object to be converted to a `string`.</param>
    /// <returns>Returns the `json` object as a `string`.</returns>
    public static string JsonToString(Json j)
    {
      __sklib_ptr __skparam__j;
      __sklib_string __skreturn;
      __skparam__j = __skadapter__to_sklib_json(j);
      __skreturn = __sklib__json_to_string__json(__skparam__j);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Checks to see if any key has been pressed since the last time `process_events` was called.
    /// </summary>
    /// <returns>True if any key was pressed.</returns>
    public static bool AnyKeyPressed()
    {
      int __skreturn;
      __skreturn = __sklib__any_key_pressed();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Remove the registered callback from receiving events related to key down actions.
    /// </summary>
    /// <param name="callback"> The function to from from key down events</param>
    public static void DeregisterCallbackOnKeyDown(KeyCallback callback)
    {
      KeyCallback __skparam__callback;
      __skparam__callback = __skadapter__to_sklib_key_callback(callback);
      __sklib__deregister_callback_on_key_down__key_callback_ptr(__skparam__callback);
    }
    /// <summary>
    /// Remove the registered callback from receiving events related to key typed actions.
    /// </summary>
    /// <param name="callback"> The function to from from key typed events</param>
    public static void DeregisterCallbackOnKeyTyped(KeyCallback callback)
    {
      KeyCallback __skparam__callback;
      __skparam__callback = __skadapter__to_sklib_key_callback(callback);
      __sklib__deregister_callback_on_key_typed__key_callback_ptr(__skparam__callback);
    }
    /// <summary>
    /// Remove the registered callback from receiving events related to key up actions.
    /// </summary>
    /// <param name="callback"> The function to from from key up events</param>
    public static void DeregisterCallbackOnKeyUp(KeyCallback callback)
    {
      KeyCallback __skparam__callback;
      __skparam__callback = __skadapter__to_sklib_key_callback(callback);
      __sklib__deregister_callback_on_key_up__key_callback_ptr(__skparam__callback);
    }
    /// <summary>
    /// Returns true when the key requested is being held down. This is updated as part of the `process_events` call. Use the key codes from `key_code` to specify the key to be checked.
    /// </summary>
    /// <param name="key"> The key to check if it is down</param>
    /// <returns>True if the key is currently held down</returns>
    public static bool KeyDown(KeyCode key)
    {
      int __skparam__key;
      int __skreturn;
      __skparam__key = __skadapter__to_sklib_key_code(key);
      __skreturn = __sklib__key_down__key_code(__skparam__key);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// The `key_name` function returns a string name for a given `key_code`. For example, `COMMA_KEY` returns the string 'Comma'. This function could be used to display more meaningful key names for configuring game controls, etc.
    /// </summary>
    /// <param name="key"> The key to get the name of</param>
    /// <returns>The name of the key</returns>
    public static string KeyName(KeyCode key)
    {
      int __skparam__key;
      __sklib_string __skreturn;
      __skparam__key = __skadapter__to_sklib_key_code(key);
      __skreturn = __sklib__key_name__key_code(__skparam__key);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns true if the specified key was released since the last time `process_events` was called. This occurs only once for the key that is released and will not return true again until the key is pressed down and released again.
    /// </summary>
    /// <param name="key"> The key to check if it was released</param>
    /// <returns>True if the key was just released</returns>
    public static bool KeyReleased(KeyCode key)
    {
      int __skparam__key;
      int __skreturn;
      __skparam__key = __skadapter__to_sklib_key_code(key);
      __skreturn = __sklib__key_released__key_code(__skparam__key);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true when the key requested is just pressed down. This is updated as part of the `process_events` call. Use the key codes from `key_code` to specify the key to be checked. this will only occur once for that key that is pressed and will not return true again until the key is released and presssed down again
    /// </summary>
    /// <param name="key"> The key to check if it was typed</param>
    /// <returns>True if the key was just pressed down</returns>
    public static bool KeyTyped(KeyCode key)
    {
      int __skparam__key;
      int __skreturn;
      __skparam__key = __skadapter__to_sklib_key_code(key);
      __skreturn = __sklib__key_typed__key_code(__skparam__key);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns false when the key requested is being held down. This is updated as part of the `process_events` call. Use the key codes from `key_code` to specify the key to be checked.
    /// </summary>
    /// <param name="key"> The key to check if it is up</param>
    /// <returns>True if the key is currently up</returns>
    public static bool KeyUp(KeyCode key)
    {
      int __skparam__key;
      int __skreturn;
      __skparam__key = __skadapter__to_sklib_key_code(key);
      __skreturn = __sklib__key_up__key_code(__skparam__key);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Register the passed in callback function to receive notification of key down calls. This will be called in response to `process_events`, for each key that the user presses down.
    /// </summary>
    /// <param name="callback"> The function to be called when a key is first pressed</param>
    public static void RegisterCallbackOnKeyDown(KeyCallback callback)
    {
      KeyCallback __skparam__callback;
      __skparam__callback = __skadapter__to_sklib_key_callback(callback);
      __sklib__register_callback_on_key_down__key_callback_ptr(__skparam__callback);
    }
    /// <summary>
    /// Register the passed in callback function to receive notification of key typed calls. This will be called in response to `process_events`, when the user initially presses a key down.
    /// </summary>
    /// <param name="callback"> The function to be called when a key is typed</param>
    public static void RegisterCallbackOnKeyTyped(KeyCallback callback)
    {
      KeyCallback __skparam__callback;
      __skparam__callback = __skadapter__to_sklib_key_callback(callback);
      __sklib__register_callback_on_key_typed__key_callback_ptr(__skparam__callback);
    }
    /// <summary>
    /// Register the passed in callback function to receive notification of key up calls. This will be called in response to `process_events`, for each key that the user releases.
    /// </summary>
    /// <param name="callback"> The function to be called when a key is released</param>
    public static void RegisterCallbackOnKeyUp(KeyCallback callback)
    {
      KeyCallback __skparam__callback;
      __skparam__callback = __skadapter__to_sklib_key_callback(callback);
      __sklib__register_callback_on_key_up__key_callback_ptr(__skparam__callback);
    }
    /// <summary>
    /// Draws a line onto the current window.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="l"> The line's details</param>
    public static void DrawLine(Color clr, Line l)
    {
      __sklib_color __skparam__clr;
      __sklib_line __skparam__l;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__l = __skadapter__to_sklib_line(l);
      __sklib__draw_line__color__line_ref(__skparam__clr, __skparam__l);
    }
    /// <summary>
    /// Draws a line.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="l"> The line's details</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawLine(Color clr, Line l, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_line __skparam__l;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__l = __skadapter__to_sklib_line(l);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_line__color__line_ref__drawing_options(__skparam__clr, __skparam__l, __skparam__opts);
    }
    /// <summary>
    /// Draw a line from one point to another on the current window.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="fromPt"> The start of the line</param>
    /// <param name="toPt"> The end of the line</param>
    public static void DrawLine(Color clr, Point2D fromPt, Point2D toPt)
    {
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__from_pt;
      __sklib_point_2d __skparam__to_pt;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__from_pt = __skadapter__to_sklib_point_2d(fromPt);
      __skparam__to_pt = __skadapter__to_sklib_point_2d(toPt);
      __sklib__draw_line__color__point_2d_ref__point_2d_ref(__skparam__clr, __skparam__from_pt, __skparam__to_pt);
    }
    /// <summary>
    /// Draw a line from one point to another on the current window.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="fromPt"> The start of the line</param>
    /// <param name="toPt"> The end of the line</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawLine(Color clr, Point2D fromPt, Point2D toPt, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__from_pt;
      __sklib_point_2d __skparam__to_pt;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__from_pt = __skadapter__to_sklib_point_2d(fromPt);
      __skparam__to_pt = __skadapter__to_sklib_point_2d(toPt);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_line__color__point_2d_ref__point_2d_ref__drawing_options_ref(__skparam__clr, __skparam__from_pt, __skparam__to_pt, __skparam__opts);
    }
    /// <summary>
    /// Draw a line from one point to another on the current window.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="x1"> The distance from the left of the window/bitmap to the first point</param>
    /// <param name="y1"> The distance from the top of the window/bitmap to the first point</param>
    /// <param name="x2"> The distance from the left of the window/bitmap to the second point</param>
    /// <param name="y2"> The distance from the top of the window/bitmap to the second point</param>
    public static void DrawLine(Color clr, double x1, double y1, double x2, double y2)
    {
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __sklib__draw_line__color__double__double__double__double(__skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2);
    }
    /// <summary>
    /// Draw a line from one point to another
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="x1"> The distance from the left of the window/bitmap to the first point</param>
    /// <param name="y1"> The distance from the top of the window/bitmap to the first point</param>
    /// <param name="x2"> The distance from the left of the window/bitmap to the second point</param>
    /// <param name="y2"> The distance from the top of the window/bitmap to the second point</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawLine(Color clr, double x1, double y1, double x2, double y2, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_line__color__double__double__double__double__drawing_options_ref(__skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__opts);
    }
    /// <summary>
    /// Draws a line onto the given bitmap.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the line</param>
    /// <param name="l"> The line's details</param>
    public static void DrawLineOnBitmap(Bitmap destination, Color clr, Line l)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_line __skparam__l;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__l = __skadapter__to_sklib_line(l);
      __sklib__draw_line_on_bitmap__bitmap__color__line_ref(__skparam__destination, __skparam__clr, __skparam__l);
    }
    /// <summary>
    /// Draws a line on the given bitmap.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the line</param>
    /// <param name="l"> The line's details</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawLineOnBitmap(Bitmap destination, Color clr, Line l, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_line __skparam__l;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__l = __skadapter__to_sklib_line(l);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_line_on_bitmap__bitmap__color__line_ref__drawing_options(__skparam__destination, __skparam__clr, __skparam__l, __skparam__opts);
    }
    /// <summary>
    /// Draw a line from one point to another on the given bitmap.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the line</param>
    /// <param name="fromPt"> The start of the line</param>
    /// <param name="toPt"> The end of the line</param>
    public static void DrawLineOnBitmap(Bitmap destination, Color clr, Point2D fromPt, Point2D toPt)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__from_pt;
      __sklib_point_2d __skparam__to_pt;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__from_pt = __skadapter__to_sklib_point_2d(fromPt);
      __skparam__to_pt = __skadapter__to_sklib_point_2d(toPt);
      __sklib__draw_line_on_bitmap__bitmap__color__point_2d_ref__point_2d_ref(__skparam__destination, __skparam__clr, __skparam__from_pt, __skparam__to_pt);
    }
    /// <summary>
    /// Draw a line from one point to another on the given bitmap.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the line</param>
    /// <param name="fromPt"> The start of the line</param>
    /// <param name="toPt"> The end of the line</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawLineOnBitmap(Bitmap destination, Color clr, Point2D fromPt, Point2D toPt, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__from_pt;
      __sklib_point_2d __skparam__to_pt;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__from_pt = __skadapter__to_sklib_point_2d(fromPt);
      __skparam__to_pt = __skadapter__to_sklib_point_2d(toPt);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_line_on_bitmap__bitmap__color__point_2d_ref__point_2d_ref__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__from_pt, __skparam__to_pt, __skparam__opts);
    }
    /// <summary>
    /// Draw a line from one point to another on the given bitmap.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the line</param>
    /// <param name="x1"> The distance from the left of the bitmap/bitmap to the first point</param>
    /// <param name="y1"> The distance from the top of the bitmap/bitmap to the first point</param>
    /// <param name="x2"> The distance from the left of the bitmap/bitmap to the second point</param>
    /// <param name="y2"> The distance from the top of the bitmap/bitmap to the second point</param>
    public static void DrawLineOnBitmap(Bitmap destination, Color clr, double x1, double y1, double x2, double y2)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __sklib__draw_line_on_bitmap__bitmap__color__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2);
    }
    /// <summary>
    /// Draw a line from one point to another
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the line</param>
    /// <param name="x1"> The distance from the left of the bitmap/bitmap to the first point</param>
    /// <param name="y1"> The distance from the top of the bitmap/bitmap to the first point</param>
    /// <param name="x2"> The distance from the left of the bitmap/bitmap to the second point</param>
    /// <param name="y2"> The distance from the top of the bitmap/bitmap to the second point</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawLineOnBitmap(Bitmap destination, Color clr, double x1, double y1, double x2, double y2, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_line_on_bitmap__bitmap__color__double__double__double__double__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__opts);
    }
    /// <summary>
    /// Draws a line onto the given window.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the line</param>
    /// <param name="l"> The line's details</param>
    public static void DrawLineOnWindow(Window destination, Color clr, Line l)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_line __skparam__l;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__l = __skadapter__to_sklib_line(l);
      __sklib__draw_line_on_window__window__color__line_ref(__skparam__destination, __skparam__clr, __skparam__l);
    }
    /// <summary>
    /// Draws a line on the given window.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the line</param>
    /// <param name="l"> The line's details</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawLineOnWindow(Window destination, Color clr, Line l, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_line __skparam__l;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__l = __skadapter__to_sklib_line(l);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_line_on_window__window__color__line_ref__drawing_options(__skparam__destination, __skparam__clr, __skparam__l, __skparam__opts);
    }
    /// <summary>
    /// Draw a line from one point to another on the given window.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the line</param>
    /// <param name="fromPt"> The start of the line</param>
    /// <param name="toPt"> The end of the line</param>
    public static void DrawLineOnWindow(Window destination, Color clr, Point2D fromPt, Point2D toPt)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__from_pt;
      __sklib_point_2d __skparam__to_pt;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__from_pt = __skadapter__to_sklib_point_2d(fromPt);
      __skparam__to_pt = __skadapter__to_sklib_point_2d(toPt);
      __sklib__draw_line_on_window__window__color__point_2d_ref__point_2d_ref(__skparam__destination, __skparam__clr, __skparam__from_pt, __skparam__to_pt);
    }
    /// <summary>
    /// Draw a line from one point to another on the given window.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the line</param>
    /// <param name="fromPt"> The start of the line</param>
    /// <param name="toPt"> The end of the line</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawLineOnWindow(Window destination, Color clr, Point2D fromPt, Point2D toPt, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__from_pt;
      __sklib_point_2d __skparam__to_pt;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__from_pt = __skadapter__to_sklib_point_2d(fromPt);
      __skparam__to_pt = __skadapter__to_sklib_point_2d(toPt);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_line_on_window__window__color__point_2d_ref__point_2d_ref__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__from_pt, __skparam__to_pt, __skparam__opts);
    }
    /// <summary>
    /// Draw a line from one point to another on the given window.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the line</param>
    /// <param name="x1"> The distance from the left of the window/bitmap to the first point</param>
    /// <param name="y1"> The distance from the top of the window/bitmap to the first point</param>
    /// <param name="x2"> The distance from the left of the window/bitmap to the second point</param>
    /// <param name="y2"> The distance from the top of the window/bitmap to the second point</param>
    public static void DrawLineOnWindow(Window destination, Color clr, double x1, double y1, double x2, double y2)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __sklib__draw_line_on_window__window__color__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2);
    }
    /// <summary>
    /// Draw a line from one point to another
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the line</param>
    /// <param name="x1"> The distance from the left of the window/bitmap to the first point</param>
    /// <param name="y1"> The distance from the top of the window/bitmap to the first point</param>
    /// <param name="x2"> The distance from the left of the window/bitmap to the second point</param>
    /// <param name="y2"> The distance from the top of the window/bitmap to the second point</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawLineOnWindow(Window destination, Color clr, double x1, double y1, double x2, double y2, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_line_on_window__window__color__double__double__double__double__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__opts);
    }
    /// <summary>
    /// Gets the closest point on the line to a given point.
    /// </summary>
    /// <param name="fromPt"> The point to test (usually somewhere near the line)</param>
    /// <param name="l"> The line</param>
    /// <returns>The point on the line that is closest to `from_pt`</returns>
    public static Point2D ClosestPointOnLine(Point2D fromPt, Line l)
    {
      __sklib_point_2d __skparam__from_pt;
      __sklib_line __skparam__l;
      __sklib_point_2d __skreturn;
      __skparam__from_pt = __skadapter__to_sklib_point_2d(fromPt);
      __skparam__l = __skadapter__to_sklib_line(l);
      __skreturn = __sklib__closest_point_on_line__point_2d__line_ref(__skparam__from_pt, __skparam__l);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Get the point closest to `from pt` that is on one of the supplied lines.
    /// </summary>
    /// <param name="fromPt"> The point to test</param>
    /// <param name="lines"> The lines to check</param>
    /// <param name="lineIdx"> After the call this will store the index of the line that had the matching point.</param>
    /// <returns>The point on one of the lines that is the closest point on these lines to the `from pt`.</returns>
    public static Point2D ClosestPointOnLines(Point2D fromPt, List<Line> lines, ref int lineIdx)
    {
      __sklib_point_2d __skparam__from_pt;
      __sklib_vector_line __skparam__lines;
      int __skparam__line_idx;
      __sklib_point_2d __skreturn;
      __skparam__from_pt = __skadapter__to_sklib_point_2d(fromPt);
      __skparam__lines = __skadapter__to_sklib_vector_line(lines);
      __skparam__line_idx = __skadapter__to_sklib_int(lineIdx);
      __skreturn = __sklib__closest_point_on_lines__point_2d__vector_line_ref__int_ref(__skparam__from_pt, __skparam__lines, ref __skparam__line_idx);
      lineIdx = __skadapter__to_int(__skparam__line_idx);
    __skadapter__free__sklib_vector_line(ref __skparam__lines);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Create a line from one point to another.
    /// </summary>
    /// <param name="start"> The start of the line</param>
    /// <param name="endPt"> The end of the line</param>
    /// <returns>A line from the start to the end point</returns>
    public static Line LineFrom(Point2D start, Point2D endPt)
    {
      __sklib_point_2d __skparam__start;
      __sklib_point_2d __skparam__end_pt;
      __sklib_line __skreturn;
      __skparam__start = __skadapter__to_sklib_point_2d(start);
      __skparam__end_pt = __skadapter__to_sklib_point_2d(endPt);
      __skreturn = __sklib__line_from__point_2d_ref__point_2d_ref(__skparam__start, __skparam__end_pt);
      return __skadapter__to_line(__skreturn);
    }
    /// <summary>
    /// Creates a line that starts at a point, and follows a given vector.
    /// </summary>
    /// <param name="start"> The start of the line</param>
    /// <param name="offset"> The offset to the end of the line</param>
    /// <returns>A line from the start to end point</returns>
    public static Line LineFrom(Point2D start, Vector2D offset)
    {
      __sklib_point_2d __skparam__start;
      __sklib_vector_2d __skparam__offset;
      __sklib_line __skreturn;
      __skparam__start = __skadapter__to_sklib_point_2d(start);
      __skparam__offset = __skadapter__to_sklib_vector_2d(offset);
      __skreturn = __sklib__line_from__point_2d_ref__vector_2d_ref(__skparam__start, __skparam__offset);
      return __skadapter__to_line(__skreturn);
    }
    /// <summary>
    /// Gets a line that goes from the origin and ends at the end of the vector.
    /// </summary>
    /// <param name="v"> The offset from the origin for the end of the line</param>
    /// <returns>A line from the origin to the end point</returns>
    public static Line LineFrom(Vector2D v)
    {
      __sklib_vector_2d __skparam__v;
      __sklib_line __skreturn;
      __skparam__v = __skadapter__to_sklib_vector_2d(v);
      __skreturn = __sklib__line_from__vector_2d_ref(__skparam__v);
      return __skadapter__to_line(__skreturn);
    }
    /// <summary>
    /// Create a line from one point to another.
    /// </summary>
    /// <param name="x1"> The x value of the start of the line</param>
    /// <param name="y1"> The y value of the start of the line</param>
    /// <param name="x2"> The x value of the end of the line</param>
    /// <param name="y2"> The y value of the end of the line</param>
    /// <returns>A line from the start to the end point</returns>
    public static Line LineFrom(double x1, double y1, double x2, double y2)
    {
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      __sklib_line __skreturn;
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skreturn = __sklib__line_from__double__double__double__double(__skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2);
      return __skadapter__to_line(__skreturn);
    }
    /// <summary>
    /// Returns the point at which two lines would intersect. This point may lie past the end of one or both lines.
    /// </summary>
    /// <param name="line1"> The first line</param>
    /// <param name="line2"> The other line</param>
    /// <param name="pt"> The resulting point where they intersect</param>
    /// <returns>[description]</returns>
    public static bool LineIntersectionPoint(Line line1, Line line2, ref Point2D pt)
    {
      __sklib_line __skparam__line1;
      __sklib_line __skparam__line2;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__line1 = __skadapter__to_sklib_line(line1);
      __skparam__line2 = __skadapter__to_sklib_line(line2);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__line_intersection_point__line_ref__line_ref__point_2d_ref(__skparam__line1, __skparam__line2, ref __skparam__pt);
      pt = __skadapter__to_point_2d(__skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true if the line intersects the circle.
    /// </summary>
    /// <param name="l"> The line</param>
    /// <param name="c"> The circle</param>
    /// <returns>True if the line `l` intersects the circle `c`</returns>
    public static bool LineIntersectsCircle(Line l, Circle c)
    {
      __sklib_line __skparam__l;
      __sklib_circle __skparam__c;
      int __skreturn;
      __skparam__l = __skadapter__to_sklib_line(l);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skreturn = __sklib__line_intersects_circle__line_ref__circle_ref(__skparam__l, __skparam__c);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true if the line intersects any of the lines.
    /// </summary>
    /// <param name="l"> The line to check</param>
    /// <param name="lines"> The lines to check against</param>
    /// <returns>True if `line` intersects any of the lines in `lines`</returns>
    public static bool LineIntersectsLines(Line l, List<Line> lines)
    {
      __sklib_line __skparam__l;
      __sklib_vector_line __skparam__lines;
      int __skreturn;
      __skparam__l = __skadapter__to_sklib_line(l);
      __skparam__lines = __skadapter__to_sklib_vector_line(lines);
      __skreturn = __sklib__line_intersects_lines__line_ref__vector_line_ref(__skparam__l, __skparam__lines);
    __skadapter__free__sklib_vector_line(ref __skparam__lines);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true if the line intersects the rectangle.
    /// </summary>
    /// <param name="l"> The line</param>
    /// <param name="rect"> The rectangle</param>
    /// <returns>True if `l` intersects `rect`</returns>
    public static bool LineIntersectsRect(Line l, Rectangle rect)
    {
      __sklib_line __skparam__l;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__l = __skadapter__to_sklib_line(l);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__line_intersects_rect__line_ref__rectangle_ref(__skparam__l, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the length of a line.
    /// </summary>
    /// <param name="l"> The line</param>
    /// <returns>The length of the line</returns>
    public static float LineLength(Line l)
    {
      __sklib_line __skparam__l;
      float __skreturn;
      __skparam__l = __skadapter__to_sklib_line(l);
      __skreturn = __sklib__line_length__line_ref(__skparam__l);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Returns the squared length of the line. You can also get the `line_length`.
    /// </summary>
    /// <param name="l"> The line</param>
    /// <returns>The squared length of the line</returns>
    public static float LineLengthSquared(Line l)
    {
      __sklib_line __skparam__l;
      float __skreturn;
      __skparam__l = __skadapter__to_sklib_line(l);
      __skreturn = __sklib__line_length_squared__line_ref(__skparam__l);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Returns the center point of the line.
    /// </summary>
    /// <param name="l"> The line</param>
    /// <returns>The point that is at the center of the line</returns>
    public static Point2D LineMidPoint(Line l)
    {
      __sklib_line __skparam__l;
      __sklib_point_2d __skreturn;
      __skparam__l = __skadapter__to_sklib_line(l);
      __skreturn = __sklib__line_mid_point__line_ref(__skparam__l);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// The line normal (a perpendicular vector).
    /// </summary>
    /// <param name="l"> The line</param>
    /// <returns>The line's normal vector</returns>
    public static Vector2D LineNormal(Line l)
    {
      __sklib_line __skparam__l;
      __sklib_vector_2d __skreturn;
      __skparam__l = __skadapter__to_sklib_line(l);
      __skreturn = __sklib__line_normal__line_ref(__skparam__l);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a text description of the line.
    /// </summary>
    /// <param name="ln"> The line</param>
    /// <returns>A text description of the line</returns>
    public static string LineToString(Line ln)
    {
      __sklib_line __skparam__ln;
      __sklib_string __skreturn;
      __skparam__ln = __skadapter__to_sklib_line(ln);
      __skreturn = __sklib__line_to_string__line_ref(__skparam__ln);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns an array of lines from a supplied rectangle.
    /// </summary>
    /// <param name="rect"> The rectangle to get the lines from</param>
    /// <returns>An array containing 4 lines</returns>
    public static List<Line> LinesFrom(Rectangle rect)
    {
      __sklib_rectangle __skparam__rect;
      __sklib_vector_line __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__lines_from__rectangle_ref(__skparam__rect);
      return __skadapter__to_vector_line(__skreturn);
    }
    /// <summary>
    /// Returns an array of lines from the details in the triangle.
    /// </summary>
    /// <param name="t"> The triangle</param>
    /// <returns>The lines from the triangle</returns>
    public static List<Line> LinesFrom(Triangle t)
    {
      __sklib_triangle __skparam__t;
      __sklib_vector_line __skreturn;
      __skparam__t = __skadapter__to_sklib_triangle(t);
      __skreturn = __sklib__lines_from__triangle_ref(__skparam__t);
      return __skadapter__to_vector_line(__skreturn);
    }
    /// <summary>
    /// Returns true if the two lines intersect.
    /// </summary>
    /// <param name="l1"> The first line</param>
    /// <param name="l2"> The other line</param>
    /// <returns>True if the two lines intersect (share a common point).</returns>
    public static bool LinesIntersect(Line l1, Line l2)
    {
      __sklib_line __skparam__l1;
      __sklib_line __skparam__l2;
      int __skreturn;
      __skparam__l1 = __skadapter__to_sklib_line(l1);
      __skparam__l2 = __skadapter__to_sklib_line(l2);
      __skreturn = __sklib__lines_intersect__line_ref__line_ref(__skparam__l1, __skparam__l2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Ensures propper memory clean-up prior to exit, if needed.  Used in sk_init_looging ().
    /// </summary>
    public static void CloseLogProcess()
    {
      __sklib__close_log_process();
    }
    /// <summary>
    /// Initialises the logging mode for logged messages to be written to the text-based console.
    /// </summary>
    /// <param name="mode"> The mode of log output i.e. whether there should be output to the console, a text file, or both.  Pass your choice of mode variable in by reference.</param>
    public static void InitCustomLogger(LogMode mode)
    {
      int __skparam__mode;
      __skparam__mode = __skadapter__to_sklib_log_mode(mode);
      __sklib__init_custom_logger__log_mode(__skparam__mode);
    }
    /// <summary>
    /// Initialises the logging mode between either writing to a file or both a file and the text-based console.
    /// </summary>
    /// <param name="appName"> The name of the application being written requiring logging</param>
    /// <param name="overridePrevLog"> Determines whether or not a new logging session should override the existing file, if any. Set this to false if you want new log messages to be appended to the bottom of the file; otherwise set it to true if you would like a new file to be created on top of the old one.</param>
    /// <param name="mode"> The mode of log output i.e. whether there should be output to the console, a text file, or both.  Pass your choice of mode variable in by reference.</param>
    public static void InitCustomLogger(string appName, bool overridePrevLog, LogMode mode)
    {
      __sklib_string __skparam__app_name;
      int __skparam__override_prev_log;
      int __skparam__mode;
      __skparam__app_name = __skadapter__to_sklib_string(appName);
      __skparam__override_prev_log = __skadapter__to_sklib_bool(overridePrevLog);
      __skparam__mode = __skadapter__to_sklib_log_mode(mode);
      __sklib__init_custom_logger__string__bool__log_mode(__skparam__app_name, __skparam__override_prev_log, __skparam__mode);
    __skadapter__free__sklib_string(ref __skparam__app_name);
    }
    /// <summary>
    /// Send a message to the message log. The message will be written if the log level for the program is set to display this.
    /// </summary>
    /// <param name="level"> The level of the message to log</param>
    /// <param name="message"> The message to be shown</param>
    public static void Log(LogLevel level, string message)
    {
      int __skparam__level;
      __sklib_string __skparam__message;
      __skparam__level = __skadapter__to_sklib_log_level(level);
      __skparam__message = __skadapter__to_sklib_string(message);
      __sklib__log__log_level__string(__skparam__level, __skparam__message);
    __skadapter__free__sklib_string(ref __skparam__message);
    }
    /// <summary>
    /// Use a matrix to transform all of the points in a quad.
    /// </summary>
    /// <param name="matrix"> The matrix with the transformations needed.</param>
    /// <param name="q"> The quad to transform.</param>
    public static void ApplyMatrix(Matrix2D matrix, ref Quad q)
    {
      __sklib_matrix_2d __skparam__matrix;
      __sklib_quad __skparam__q;
      __skparam__matrix = __skadapter__to_sklib_matrix_2d(matrix);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __sklib__apply_matrix__matrix_2d_ref__quad_ref(__skparam__matrix, ref __skparam__q);
      q = __skadapter__to_quad(__skparam__q);
    }
    /// <summary>
    /// Use a matrix to transform all of the points in a triangle.
    /// </summary>
    /// <param name="m"> The matrix to be applied to the triangle.</param>
    /// <param name="tri"> The triangle to tranform.</param>
    public static void ApplyMatrix(Matrix2D m, ref Triangle tri)
    {
      __sklib_matrix_2d __skparam__m;
      __sklib_triangle __skparam__tri;
      __skparam__m = __skadapter__to_sklib_matrix_2d(m);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __sklib__apply_matrix__matrix_2d_ref__triangle_ref(__skparam__m, ref __skparam__tri);
      tri = __skadapter__to_triangle(__skparam__tri);
    }
    /// <summary>
    /// Returns the identity matrix. When a matrix_2d or Vector is multiplied by the identity matrix the result is the original matrix or vector.
    /// </summary>
    /// <returns>An identify matrix.</returns>
    public static Matrix2D IdentityMatrix()
    {
      __sklib_matrix_2d __skreturn;
      __skreturn = __sklib__identity_matrix();
      return __skadapter__to_matrix_2d(__skreturn);
    }
    /// <summary>
    /// Calculate the inverse of a matrix.
    /// </summary>
    /// <param name="m"> The matrix to invert.</param>
    /// <returns>A matrix that is the inverse of m</returns>
    public static Matrix2D MatrixInverse(Matrix2D m)
    {
      __sklib_matrix_2d __skparam__m;
      __sklib_matrix_2d __skreturn;
      __skparam__m = __skadapter__to_sklib_matrix_2d(m);
      __skreturn = __sklib__matrix_inverse__matrix_2d_ref(__skparam__m);
      return __skadapter__to_matrix_2d(__skreturn);
    }
    /// <summary>
    /// Multiplies the `point_2d` parameter `v with the `matrix_2d` `m and returns the result as a `point_2d`. Use this to transform the vector with the matrix (to apply scaling, rotation or translation effects).
    /// </summary>
    /// <param name="m"> The matrix with the transformation to apply.</param>
    /// <param name="pt"> The point to be transformed.</param>
    /// <returns>A new point, the result of applying the transformation to pt.</returns>
    public static Point2D MatrixMultiply(Matrix2D m, Point2D pt)
    {
      __sklib_matrix_2d __skparam__m;
      __sklib_point_2d __skparam__pt;
      __sklib_point_2d __skreturn;
      __skparam__m = __skadapter__to_sklib_matrix_2d(m);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__matrix_multiply__matrix_2d_ref__point_2d_ref(__skparam__m, __skparam__pt);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Multiplies the two `matrix_2d` parameters, `m1` by `m2`, and returns the result as a new `matrix_2d`. Use this to combine the effects to two matrix transformations.
    /// </summary>
    /// <param name="m1"> The first matrix</param>
    /// <param name="m2"> The second matrix</param>
    /// <returns>The result of multiplying m1 by m2</returns>
    public static Matrix2D MatrixMultiply(Matrix2D m1, Matrix2D m2)
    {
      __sklib_matrix_2d __skparam__m1;
      __sklib_matrix_2d __skparam__m2;
      __sklib_matrix_2d __skreturn;
      __skparam__m1 = __skadapter__to_sklib_matrix_2d(m1);
      __skparam__m2 = __skadapter__to_sklib_matrix_2d(m2);
      __skreturn = __sklib__matrix_multiply__matrix_2d_ref__matrix_2d_ref(__skparam__m1, __skparam__m2);
      return __skadapter__to_matrix_2d(__skreturn);
    }
    /// <summary>
    /// Multiplies the `Vector` parameter `v` with the `matrix_2d` `m` and returns the result as a `Vector`. Use this to transform the vector with the matrix (to apply scaling, rotation or translation effects).
    /// </summary>
    /// <param name="m"> The matrix with the transformation to apply.</param>
    /// <param name="v"> The vector to be transformed.</param>
    /// <returns>A new vector, the result of applying the transformation to v.</returns>
    public static Vector2D MatrixMultiply(Matrix2D m, Vector2D v)
    {
      __sklib_matrix_2d __skparam__m;
      __sklib_vector_2d __skparam__v;
      __sklib_vector_2d __skreturn;
      __skparam__m = __skadapter__to_sklib_matrix_2d(m);
      __skparam__v = __skadapter__to_sklib_vector_2d(v);
      __skreturn = __sklib__matrix_multiply__matrix_2d_ref__vector_2d_ref(__skparam__m, __skparam__v);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// This function returns a string representation of a Matrix.
    /// </summary>
    /// <param name="matrix"> The matrix to convert to a string.</param>
    /// <returns>A string representation of the matrix.</returns>
    public static string MatrixToString(Matrix2D matrix)
    {
      __sklib_matrix_2d __skparam__matrix;
      __sklib_string __skreturn;
      __skparam__matrix = __skadapter__to_sklib_matrix_2d(matrix);
      __skreturn = __sklib__matrix_to_string__matrix_2d_ref(__skparam__matrix);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns a rotation matrix that rotates 2d points by the angle.
    /// </summary>
    /// <param name="deg"> The amount to rotate points</param>
    /// <returns>A matrix that encodes the rotation by a number of degrees.</returns>
    public static Matrix2D RotationMatrix(double deg)
    {
      double __skparam__deg;
      __sklib_matrix_2d __skreturn;
      __skparam__deg = __skadapter__to_sklib_double(deg);
      __skreturn = __sklib__rotation_matrix__double(__skparam__deg);
      return __skadapter__to_matrix_2d(__skreturn);
    }
    /// <summary>
    /// Create a scale matrix that scales x and y to different degrees.
    /// </summary>
    /// <param name="scale"> The amount to scale, with separate x and y components.</param>
    /// <returns>A matrix that will scale points based on scale parameter.</returns>
    public static Matrix2D ScaleMatrix(Point2D scale)
    {
      __sklib_point_2d __skparam__scale;
      __sklib_matrix_2d __skreturn;
      __skparam__scale = __skadapter__to_sklib_point_2d(scale);
      __skreturn = __sklib__scale_matrix__point_2d_ref(__skparam__scale);
      return __skadapter__to_matrix_2d(__skreturn);
    }
    /// <summary>
    /// Create a scale matrix that scales x and y to different degrees.
    /// </summary>
    /// <param name="scale"> The amount to scale, with separate x and y components.</param>
    /// <returns>A matrix that will scale points based on scale parameter.</returns>
    public static Matrix2D ScaleMatrix(Vector2D scale)
    {
      __sklib_vector_2d __skparam__scale;
      __sklib_matrix_2d __skreturn;
      __skparam__scale = __skadapter__to_sklib_vector_2d(scale);
      __skreturn = __sklib__scale_matrix__vector_2d_ref(__skparam__scale);
      return __skadapter__to_matrix_2d(__skreturn);
    }
    /// <summary>
    /// Returns a matrix that can be used to scale 2d points (both x and y).
    /// </summary>
    /// <param name="scale"> The amount to scale points by.</param>
    /// <returns>A matrix to scale points by.</returns>
    public static Matrix2D ScaleMatrix(double scale)
    {
      double __skparam__scale;
      __sklib_matrix_2d __skreturn;
      __skparam__scale = __skadapter__to_sklib_double(scale);
      __skreturn = __sklib__scale_matrix__double(__skparam__scale);
      return __skadapter__to_matrix_2d(__skreturn);
    }
    /// <summary>
    /// Create a matrix that can scale, rotate then translate geometry points.
    /// </summary>
    /// <param name="scale"> The amount to scale</param>
    /// <param name="deg"> The amount to rotate</param>
    /// <param name="translate"> The amount to move</param>
    /// <returns>A matrix that will scale, rotate, and translate.</returns>
    public static Matrix2D ScaleRotateTranslateMatrix(Point2D scale, double deg, Point2D translate)
    {
      __sklib_point_2d __skparam__scale;
      double __skparam__deg;
      __sklib_point_2d __skparam__translate;
      __sklib_matrix_2d __skreturn;
      __skparam__scale = __skadapter__to_sklib_point_2d(scale);
      __skparam__deg = __skadapter__to_sklib_double(deg);
      __skparam__translate = __skadapter__to_sklib_point_2d(translate);
      __skreturn = __sklib__scale_rotate_translate_matrix__point_2d_ref__double__point_2d_ref(__skparam__scale, __skparam__deg, __skparam__translate);
      return __skadapter__to_matrix_2d(__skreturn);
    }
    /// <summary>
    /// Returns a translation matric used to translate 2d points by the distance in the point_2d.
    /// </summary>
    /// <param name="pt"> The point to translate to.</param>
    /// <returns>A matrix that will move points by amount in pt</returns>
    public static Matrix2D TranslationMatrix(Point2D pt)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_matrix_2d __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__translation_matrix__point_2d_ref(__skparam__pt);
      return __skadapter__to_matrix_2d(__skreturn);
    }
    /// <summary>
    /// Returns a translation matric used to translate 2d points by the distance in the vector_2d.
    /// </summary>
    /// <param name="pt"> The point to translate to.</param>
    /// <returns>A matrix that will move points by amount in pt</returns>
    public static Matrix2D TranslationMatrix(Vector2D pt)
    {
      __sklib_vector_2d __skparam__pt;
      __sklib_matrix_2d __skreturn;
      __skparam__pt = __skadapter__to_sklib_vector_2d(pt);
      __skreturn = __sklib__translation_matrix__vector_2d_ref(__skparam__pt);
      return __skadapter__to_matrix_2d(__skreturn);
    }
    /// <summary>
    /// Returns a matrix that can be used to translate 2d points. Moving them by dx and dy.
    /// </summary>
    /// <param name="dx"> The amount to move points along the x axis.</param>
    /// <param name="dy"> The amount to move points along the y axis.</param>
    /// <returns>A matrix that will move points by dx, dy</returns>
    public static Matrix2D TranslationMatrix(double dx, double dy)
    {
      double __skparam__dx;
      double __skparam__dy;
      __sklib_matrix_2d __skreturn;
      __skparam__dx = __skadapter__to_sklib_double(dx);
      __skparam__dy = __skadapter__to_sklib_double(dy);
      __skreturn = __sklib__translation_matrix__double__double(__skparam__dx, __skparam__dy);
      return __skadapter__to_matrix_2d(__skreturn);
    }
    /// <summary>
    /// Tells the mouse cursor to hide (no longer visible) if it is currently showing. Use `ShowMouse` to make the mouse cursor visible again.
    /// </summary>
    public static void HideMouse()
    {
      __sklib__hide_mouse();
    }
    /// <summary>
    /// Returns true if the specified button was clicked since the last time `process_events` was called.
    /// </summary>
    /// <param name="button"> The mouse button to check</param>
    /// <returns>True if the mouse button was clicked</returns>
    public static bool MouseClicked(MouseButton button)
    {
      int __skparam__button;
      int __skreturn;
      __skparam__button = __skadapter__to_sklib_mouse_button(button);
      __skreturn = __sklib__mouse_clicked__mouse_button(__skparam__button);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns `true` if the specified button is currently pressed down.
    /// </summary>
    /// <param name="button"> The mouse button to check</param>
    /// <returns>True if the mouse button is down</returns>
    public static bool MouseDown(MouseButton button)
    {
      int __skparam__button;
      int __skreturn;
      __skparam__button = __skadapter__to_sklib_mouse_button(button);
      __skreturn = __sklib__mouse_down__mouse_button(__skparam__button);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the amount of accumulated mouse movement, since the last time `process_events` was called, as a `vector_2d`.
    /// </summary>
    /// <returns>The movement of the mouse since the last process events</returns>
    public static Vector2D MouseMovement()
    {
      __sklib_vector_2d __skreturn;
      __skreturn = __sklib__mouse_movement();
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the current window position of the mouse as a `Point2D`
    /// </summary>
    /// <returns>The position of the mouse in the current window.</returns>
    public static Point2D MousePosition()
    {
      __sklib_point_2d __skreturn;
      __skreturn = __sklib__mouse_position();
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns The current window position of the mouse as a `Vector`
    /// </summary>
    /// <returns>The offset from the window origin to the mouse.</returns>
    public static Vector2D MousePositionVector()
    {
      __sklib_vector_2d __skreturn;
      __skreturn = __sklib__mouse_position_vector();
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns `true` if the mouse is currently visible, `false` if not.
    /// </summary>
    /// <returns>True if the mouse is shown.</returns>
    public static bool MouseShown()
    {
      int __skreturn;
      __skreturn = __sklib__mouse_shown();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns `true` if the specified button is currently up.
    /// </summary>
    /// <param name="button"> The mouse button to check</param>
    /// <returns>True if the mouse button is up (i.e. not down)</returns>
    public static bool MouseUp(MouseButton button)
    {
      int __skparam__button;
      int __skreturn;
      __skparam__button = __skadapter__to_sklib_mouse_button(button);
      __skreturn = __sklib__mouse_up__mouse_button(__skparam__button);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the amount the mouse wheel was scrolled since the last call to `process_events`. The result is a vector containing the x and y amounts scrolled. Scroll left generates a negative x, scroll right a positive x. Scroll backward is negative y, scroll forward positive y. Note that on MacOS the directions may be inverted by OS settings.
    /// </summary>
    /// <returns>The distance and direction of the mouse scroll since the last `process_events`</returns>
    public static Vector2D MouseWheelScroll()
    {
      __sklib_vector_2d __skreturn;
      __skreturn = __sklib__mouse_wheel_scroll();
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the current x value of the mouse's position.
    /// </summary>
    /// <returns>The distance of the mouse from the left edge of the current window location</returns>
    public static float MouseX()
    {
      float __skreturn;
      __skreturn = __sklib__mouse_x();
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Returns the current y value of the mouse's position.
    /// </summary>
    /// <returns>The distance of the mouse from the top edge of the current window location</returns>
    public static float MouseY()
    {
      float __skreturn;
      __skreturn = __sklib__mouse_y();
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Moves the mouse cursor to the specified screen location.
    /// </summary>
    /// <param name="x"> The new x location of the mouse</param>
    /// <param name="y"> The new y location of the mouse</param>
    public static void MoveMouse(double x, double y)
    {
      double __skparam__x;
      double __skparam__y;
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__move_mouse__double__double(__skparam__x, __skparam__y);
    }
    /// <summary>
    /// Moves the mouse cursor to the specified screen location.
    /// </summary>
    /// <param name="point"> The new location of the mouse</param>
    public static void MoveMouse(Point2D point)
    {
      __sklib_point_2d __skparam__point;
      __skparam__point = __skadapter__to_sklib_point_2d(point);
      __sklib__move_mouse__point_2d(__skparam__point);
    }
    /// <summary>
    /// Tells the mouse cursor to be visible if it was previously hidden with by a `HideMouse` or `SetMouseVisible`(False) call.
    /// </summary>
    public static void ShowMouse()
    {
      __sklib__show_mouse();
    }
    /// <summary>
    /// Used to explicitly set the mouse cursors visible state (if it is showing in the window or not) based on the show parameter.
    /// </summary>
    /// <param name="show"> When true the mouse is shown, when false it is hidden</param>
    public static void ShowMouse(bool show)
    {
      int __skparam__show;
      __skparam__show = __skadapter__to_sklib_bool(show);
      __sklib__show_mouse__bool(__skparam__show);
    }
    /// <summary>
    /// Fades music file matching the name to full volume over a specified number of milliseconds
    /// </summary>
    /// <param name="name"> The name of the `music` file to play.</param>
    /// <param name="ms"> How many milliseconds it takes to fade the `music` to full volume</param>
    public static void FadeMusicIn(string name, int ms)
    {
      __sklib_string __skparam__name;
      int __skparam__ms;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__ms = __skadapter__to_sklib_int(ms);
      __sklib__fade_music_in__string_ref__int(__skparam__name, __skparam__ms);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Fades music file matching the name to full volume over a specified number of milliseconds and loops a specified number of times
    /// </summary>
    /// <param name="name"> The name of the `music` file to play.</param>
    /// <param name="times"> Controls the number of times the music is played.</param>
    /// <param name="ms"> How many milliseconds it takes to fade the `music` to full volume</param>
    public static void FadeMusicIn(string name, int times, int ms)
    {
      __sklib_string __skparam__name;
      int __skparam__times;
      int __skparam__ms;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__times = __skadapter__to_sklib_int(times);
      __skparam__ms = __skadapter__to_sklib_int(ms);
      __sklib__fade_music_in__string_ref__int__int(__skparam__name, __skparam__times, __skparam__ms);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Fades music up to full volume over a specified number of milliseconds.
    /// </summary>
    /// <param name="data"> The name of the `music` to play.</param>
    /// <param name="ms"> How many milliseconds it takes to fade the `music` to full volume</param>
    public static void FadeMusicIn(Music data, int ms)
    {
      __sklib_ptr __skparam__data;
      int __skparam__ms;
      __skparam__data = __skadapter__to_sklib_music(data);
      __skparam__ms = __skadapter__to_sklib_int(ms);
      __sklib__fade_music_in__music__int(__skparam__data, __skparam__ms);
    }
    /// <summary>
    /// Fades music up to full volume over a specified number of milliseconds for a specified number of times.
    /// </summary>
    /// <param name="data"> The name of the `music` to play.</param>
    /// <param name="times"> Controls the number of times the music is played.</param>
    /// <param name="ms"> How many milliseconds it takes to fade the `music` to full volume</param>
    public static void FadeMusicIn(Music data, int times, int ms)
    {
      __sklib_ptr __skparam__data;
      int __skparam__times;
      int __skparam__ms;
      __skparam__data = __skadapter__to_sklib_music(data);
      __skparam__times = __skadapter__to_sklib_int(times);
      __skparam__ms = __skadapter__to_sklib_int(ms);
      __sklib__fade_music_in__music__int__int(__skparam__data, __skparam__times, __skparam__ms);
    }
    /// <summary>
    /// Fades music outover a specified number of milliseconds
    /// </summary>
    /// <param name="ms"> How many milliseconds it takes to fade the `music` out</param>
    public static void FadeMusicOut(int ms)
    {
      int __skparam__ms;
      __skparam__ms = __skadapter__to_sklib_int(ms);
      __sklib__fade_music_out__int(__skparam__ms);
    }
    /// <summary>
    /// Releases all of the music files that have been loaded.
    /// </summary>
    public static void FreeAllMusic()
    {
      __sklib__free_all_music();
    }
    /// <summary>
    /// Releases the SplashKit resources associated with music.
    /// </summary>
    /// <param name="effect"> The music file whose resources should be released.</param>
    public static void FreeMusic(Music effect)
    {
      __sklib_ptr __skparam__effect;
      __skparam__effect = __skadapter__to_sklib_music(effect);
      __sklib__free_music__music(__skparam__effect);
    }
    /// <summary>
    /// Determines if SplashKit has a music file loaded for the supplied name. This checks against all music files loaded, those loaded without a name are assigned the filename as a default. If this returns `false`, you may want to use `load_music` to load in a specific sound effect and give it the desired name.
    /// </summary>
    /// <param name="name"> The name to check if a music file is loaded.</param>
    /// <returns>Returns `true` if there is a music file with the given `name` has has been loaded.</returns>
    public static bool HasMusic(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_music__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Loads and returns a music value. The supplied `filename` is used to locate the music file to load. The supplied `name` indicates the name to use to refer to this Music value. The `music` can then be retrieved by passing this `name` to the `music_named` function.
    /// </summary>
    /// <param name="name"> The name of the resource for SplashKit</param>
    /// <param name="filename"> The filename to load</param>
    /// <returns>A new music resource</returns>
    public static Music LoadMusic(string name, string filename)
    {
      __sklib_string __skparam__name;
      __sklib_string __skparam__filename;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __skreturn = __sklib__load_music__string_ref__string_ref(__skparam__name, __skparam__filename);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__filename);
      return __skadapter__to_music(__skreturn);
    }
    /// <summary>
    /// Returns the filename the of the music data
    /// </summary>
    /// <param name="data"> The music resource</param>
    /// <returns>Returns a string with the filename of the `music` file.</returns>
    public static string MusicFilename(Music data)
    {
      __sklib_ptr __skparam__data;
      __sklib_string __skreturn;
      __skparam__data = __skadapter__to_sklib_music(data);
      __skreturn = __sklib__music_filename__music(__skparam__data);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns the name that SplashKit uses to refer to this music data
    /// </summary>
    /// <param name="data"> The music resource</param>
    /// <returns>Returns a string with the name of the `music` that SplashKit refers to.</returns>
    public static string MusicName(Music data)
    {
      __sklib_ptr __skparam__data;
      __sklib_string __skreturn;
      __skparam__data = __skadapter__to_sklib_music(data);
      __skreturn = __sklib__music_name__music(__skparam__data);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Retrieves a `music` that has been loaded into SplashKit.
    /// </summary>
    /// <param name="name"> The name of the music file to return.</param>
    /// <returns>Returns the `music` that has been loaded with the specified `name` using `load_music`.</returns>
    public static Music MusicNamed(string name)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__music_named__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_music(__skreturn);
    }
    /// <summary>
    /// Checks whether music is currently playing.
    /// </summary>
    /// <returns>Returns true or false value representing whether music is currently playing.</returns>
    public static bool MusicPlaying()
    {
      int __skreturn;
      __skreturn = __sklib__music_playing();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Lets you test if music value is valid. This will return true when it is a valid music.
    /// </summary>
    /// <param name="m"> the music source to test</param>
    /// <returns>true when the music is valid.</returns>
    public static bool MusicValid(Music m)
    {
      __sklib_ptr __skparam__m;
      int __skreturn;
      __skparam__m = __skadapter__to_sklib_music(m);
      __skreturn = __sklib__music_valid__music(__skparam__m);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the volume of the currently playing `music`.
    /// </summary>
    /// <returns>Returns the percentage of the currently playing `music`.</returns>
    public static double MusicVolume()
    {
      double __skreturn;
      __skreturn = __sklib__music_volume();
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Pauses currently playing music - see resume_music to continue playing.
    /// </summary>
    public static void PauseMusic()
    {
      __sklib__pause_music();
    }
    /// <summary>
    /// Plays the music file that matches the name once at full volume.
    /// </summary>
    /// <param name="name"> The name of the `music` to play.</param>
    public static void PlayMusic(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__play_music__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Plays the music file that matches the name a specified number of times at full volume.
    /// </summary>
    /// <param name="name"> The name of the `music` to play.</param>
    /// <param name="times"> Controls the number of times the music is played.</param>
    public static void PlayMusic(string name, int times)
    {
      __sklib_string __skparam__name;
      int __skparam__times;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__times = __skadapter__to_sklib_int(times);
      __sklib__play_music__string_ref__int(__skparam__name, __skparam__times);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Plays a music file once at full volume.
    /// </summary>
    /// <param name="data"> The name of the `music` to play.</param>
    public static void PlayMusic(Music data)
    {
      __sklib_ptr __skparam__data;
      __skparam__data = __skadapter__to_sklib_music(data);
      __sklib__play_music__music(__skparam__data);
    }
    /// <summary>
    /// Plays a music file a specified number of times at full volume.
    /// </summary>
    /// <param name="data"> The name of the `music` to play.</param>
    /// <param name="times"> Controls the number of times the music is played.</param>
    public static void PlayMusic(Music data, int times)
    {
      __sklib_ptr __skparam__data;
      int __skparam__times;
      __skparam__data = __skadapter__to_sklib_music(data);
      __skparam__times = __skadapter__to_sklib_int(times);
      __sklib__play_music__music__int(__skparam__data, __skparam__times);
    }
    /// <summary>
    /// Plays a music file for a specified number of times and playback volume.
    /// </summary>
    /// <param name="data"> The name of the `music` to play.</param>
    /// <param name="times"> Controls the number of times the music is played.</param>
    /// <param name="volume"> Indicates the percentage of the original volume to play the `music` at. This must be between `0` and `1`.</param>
    public static void PlayMusic(Music data, int times, double volume)
    {
      __sklib_ptr __skparam__data;
      int __skparam__times;
      double __skparam__volume;
      __skparam__data = __skadapter__to_sklib_music(data);
      __skparam__times = __skadapter__to_sklib_int(times);
      __skparam__volume = __skadapter__to_sklib_double(volume);
      __sklib__play_music__music__int__double(__skparam__data, __skparam__times, __skparam__volume);
    }
    /// <summary>
    /// Resumes currently paused music - see pause_music to pause playing music.
    /// </summary>
    public static void ResumeMusic()
    {
      __sklib__resume_music();
    }
    /// <summary>
    /// Sets the volume of the currently playing `music`. Must be between 0 and 1, e.g. 0.1 is 10%.
    /// </summary>
    /// <param name="volume"> Indicates the percentage of the original volume to play the `music` at. This must be between `0` and `1`.</param>
    public static void SetMusicVolume(double volume)
    {
      double __skparam__volume;
      __skparam__volume = __skadapter__to_sklib_double(volume);
      __sklib__set_music_volume__double(__skparam__volume);
    }
    /// <summary>
    /// Stops currently playing music.
    /// </summary>
    public static void StopMusic()
    {
      __sklib__stop_music();
    }
    /// <summary>
    /// Accept new connections for all servers.
    /// </summary>
    /// <returns>True if there were accepted connections</returns>
    public static bool AcceptAllNewConnections()
    {
      int __skreturn;
      __skreturn = __sklib__accept_all_new_connections();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Accept new connections for a server
    /// </summary>
    /// <param name="server"> The server to check</param>
    /// <returns>True if a connection was accepted</returns>
    public static bool AcceptNewConnection(ServerSocket server)
    {
      __sklib_ptr __skparam__server;
      int __skreturn;
      __skparam__server = __skadapter__to_sklib_server_socket(server);
      __skreturn = __sklib__accept_new_connection__server_socket(__skparam__server);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Broadcast a message to all connections of a server.
    /// </summary>
    /// <param name="aMsg"> The message to send</param>
    /// <param name="svr"> The server to send the message to.</param>
    public static void BroadcastMessage(string aMsg, ServerSocket svr)
    {
      __sklib_string __skparam__a_msg;
      __sklib_ptr __skparam__svr;
      __skparam__a_msg = __skadapter__to_sklib_string(aMsg);
      __skparam__svr = __skadapter__to_sklib_server_socket(svr);
      __sklib__broadcast_message__string_ref__server_socket(__skparam__a_msg, __skparam__svr);
    __skadapter__free__sklib_string(ref __skparam__a_msg);
    }
    /// <summary>
    /// Broadcase a message to all of the connections.
    /// </summary>
    /// <param name="aMsg"> The message to send</param>
    public static void BroadcastMessage(string aMsg)
    {
      __sklib_string __skparam__a_msg;
      __skparam__a_msg = __skadapter__to_sklib_string(aMsg);
      __sklib__broadcast_message__string_ref(__skparam__a_msg);
    __skadapter__free__sklib_string(ref __skparam__a_msg);
    }
    /// <summary>
    /// Broadcast a message to all connections of a server.
    /// </summary>
    /// <param name="aMsg"> The message to send</param>
    /// <param name="name"> The name of the server to send the message to.</param>
    public static void BroadcastMessage(string aMsg, string name)
    {
      __sklib_string __skparam__a_msg;
      __sklib_string __skparam__name;
      __skparam__a_msg = __skadapter__to_sklib_string(aMsg);
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__broadcast_message__string_ref__string_ref(__skparam__a_msg, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__a_msg);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Check network activity, looking for new connections and messages.
    /// </summary>
    public static void CheckNetworkActivity()
    {
      __sklib__check_network_activity();
    }
    /// <summary>
    /// Clear all of the messages from a server or connection with the supplied name.
    /// </summary>
    /// <param name="name"> The name of the connection or the server to clear.</param>
    public static void ClearMessages(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__clear_messages__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Clear all of the messages from a connection.
    /// </summary>
    /// <param name="aConnection"> The connection</param>
    public static void ClearMessages(Connection aConnection)
    {
      __sklib_ptr __skparam__a_connection;
      __skparam__a_connection = __skadapter__to_sklib_connection(aConnection);
      __sklib__clear_messages__connection(__skparam__a_connection);
    }
    /// <summary>
    /// Clear all of the messages from a server.
    /// </summary>
    /// <param name="svr"> The server to clear the messages from</param>
    public static void ClearMessages(ServerSocket svr)
    {
      __sklib_ptr __skparam__svr;
      __skparam__svr = __skadapter__to_sklib_server_socket(svr);
      __sklib__clear_messages__server_socket(__skparam__svr);
    }
    /// <summary>
    /// Close all of the connections you have opened. This does not close connections to servers.
    /// </summary>
    public static void CloseAllConnections()
    {
      __sklib__close_all_connections();
    }
    /// <summary>
    /// Close all of the servers that are currently open.
    /// </summary>
    public static void CloseAllServers()
    {
      __sklib__close_all_servers();
    }
    /// <summary>
    /// Close the connection
    /// </summary>
    /// <param name="aConnection"> The connection to close</param>
    /// <returns>True if this succeeds.</returns>
    public static bool CloseConnection(Connection aConnection)
    {
      __sklib_ptr __skparam__a_connection;
      int __skreturn;
      __skparam__a_connection = __skadapter__to_sklib_connection(aConnection);
      __skreturn = __sklib__close_connection__connection(__skparam__a_connection);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Close the connection
    /// </summary>
    /// <param name="name"> The name of the connection to close</param>
    /// <returns>True if this succeeds.</returns>
    public static bool CloseConnection(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__close_connection__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Closes the message.
    /// </summary>
    /// <param name="msg"> The message to close</param>
    public static void CloseMessage(Message msg)
    {
      __sklib_ptr __skparam__msg;
      __skparam__msg = __skadapter__to_sklib_message(msg);
      __sklib__close_message__message(__skparam__msg);
    }
    /// <summary>
    /// Closes the server with the indicated name.
    /// </summary>
    /// <param name="name"> The name of the server to close</param>
    /// <returns>True if the server was closed successfully</returns>
    public static bool CloseServer(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__close_server__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Closes the server, all connections with clients will be shut and the port will be closed.
    /// </summary>
    /// <param name="svr"> The server to close</param>
    /// <returns>True if the close was successful</returns>
    public static bool CloseServer(ServerSocket svr)
    {
      __sklib_ptr __skparam__svr;
      int __skreturn;
      __skparam__svr = __skadapter__to_sklib_server_socket(svr);
      __skreturn = __sklib__close_server__server_socket(__skparam__svr);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the number of clients connected to a server.
    /// </summary>
    /// <param name="name"> The name of the server to check</param>
    /// <returns>The number of connected clients</returns>
    public static uint ConnectionCount(string name)
    {
      __sklib_string __skparam__name;
      uint __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__connection_count__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_unsigned_int(__skreturn);
    }
    /// <summary>
    /// Returns the number of clients connected to a server.
    /// </summary>
    /// <param name="server"> The server to check</param>
    /// <returns>The number of connected clients</returns>
    public static uint ConnectionCount(ServerSocket server)
    {
      __sklib_ptr __skparam__server;
      uint __skreturn;
      __skparam__server = __skadapter__to_sklib_server_socket(server);
      __skreturn = __sklib__connection_count__server_socket(__skparam__server);
      return __skadapter__to_unsigned_int(__skreturn);
    }
    /// <summary>
    /// Gets the ip address of the passed in connection.
    /// </summary>
    /// <param name="aConnection"> The connection</param>
    /// <returns>The ip addres of the connection</returns>
    public static uint ConnectionIP(Connection aConnection)
    {
      __sklib_ptr __skparam__a_connection;
      uint __skreturn;
      __skparam__a_connection = __skadapter__to_sklib_connection(aConnection);
      __skreturn = __sklib__connection_ip__connection(__skparam__a_connection);
      return __skadapter__to_unsigned_int(__skreturn);
    }
    /// <summary>
    /// Gets the ip address of the connection with the supplied name.
    /// </summary>
    /// <param name="name"> The name of the connection</param>
    /// <returns>The connection's ip address</returns>
    public static uint ConnectionIP(string name)
    {
      __sklib_string __skparam__name;
      uint __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__connection_ip__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_unsigned_int(__skreturn);
    }
    /// <summary>
    /// Fetch the connection with the indicated name.
    /// </summary>
    /// <param name="name"> The name of the connection to fetch</param>
    /// <returns>The connection with that name</returns>
    public static Connection ConnectionNamed(string name)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__connection_named__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_connection(__skreturn);
    }
    /// <summary>
    /// Gets the port of the connection.
    /// </summary>
    /// <param name="aConnection"> The connection</param>
    /// <returns>The port of the connection.</returns>
    public static ushort ConnectionPort(Connection aConnection)
    {
      __sklib_ptr __skparam__a_connection;
      ushort __skreturn;
      __skparam__a_connection = __skadapter__to_sklib_connection(aConnection);
      __skreturn = __sklib__connection_port__connection(__skparam__a_connection);
      return __skadapter__to_unsigned_short(__skreturn);
    }
    /// <summary>
    /// Gets the part of the connection.
    /// </summary>
    /// <param name="name"> The name of the connection</param>
    /// <returns>The port of the connection</returns>
    public static ushort ConnectionPort(string name)
    {
      __sklib_string __skparam__name;
      ushort __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__connection_port__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_unsigned_short(__skreturn);
    }
    /// <summary>
    /// Creates a new TCP server that can accept connections from other programs.
    /// </summary>
    /// <param name="name"> The name used to access the Server in splashkit</param>
    /// <param name="port"> The port that clients will use to connect to the server</param>
    /// <returns>A new server with the indicated details</returns>
    public static ServerSocket CreateServer(string name, ushort port)
    {
      __sklib_string __skparam__name;
      ushort __skparam__port;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__port = __skadapter__to_sklib_unsigned_short(port);
      __skreturn = __sklib__create_server__string_ref__unsigned_short(__skparam__name, __skparam__port);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_server_socket(__skreturn);
    }
    /// <summary>
    /// Creates a new server that can accept connections from other programs.
    /// </summary>
    /// <param name="name"> The name used to access the Server in splashkit</param>
    /// <param name="port"> The port that clients will use to connect to the server</param>
    /// <param name="protocol"> The protocol used by the server</param>
    /// <returns>A new server with the indicated details</returns>
    public static ServerSocket CreateServer(string name, ushort port, ConnectionType protocol)
    {
      __sklib_string __skparam__name;
      ushort __skparam__port;
      int __skparam__protocol;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__port = __skadapter__to_sklib_unsigned_short(port);
      __skparam__protocol = __skadapter__to_sklib_connection_type(protocol);
      __skreturn = __sklib__create_server__string_ref__unsigned_short__connection_type(__skparam__name, __skparam__port, __skparam__protocol);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_server_socket(__skreturn);
    }
    /// <summary>
    /// Converts the supplied decimal integer into it's hexadecimal representation. e.g. 0x7F000001 from 2130706433
    /// </summary>
    /// <param name="aDec"> decimal to be converted to a hexadecimal number string</param>
    /// <returns>hexadecimal representation of the supplied decimal integer</returns>
    public static string DecToHex(uint aDec)
    {
      uint __skparam__a_dec;
      __sklib_string __skreturn;
      __skparam__a_dec = __skadapter__to_sklib_unsigned_int(aDec);
      __skreturn = __sklib__dec_to_hex__unsigned_int(__skparam__a_dec);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Decodes the supplied unsigned 32-bit integer into its ipv4 address form e.g. 2130706433 into 127.0.0.1
    /// </summary>
    /// <param name="ip"> integer to be decoded</param>
    /// <returns>ipv4 address string in X.X.X.X format</returns>
    public static string DecToIpv4(uint ip)
    {
      uint __skparam__ip;
      __sklib_string __skreturn;
      __skparam__ip = __skadapter__to_sklib_unsigned_int(ip);
      __skreturn = __sklib__dec_to_ipv4__unsigned_int(__skparam__ip);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Get the oldest new connections made to the server, and reduces the new connection count by 1.
    /// </summary>
    /// <param name="server"> The server to check</param>
    /// <returns>The oldest new connection</returns>
    public static Connection FetchNewConnection(ServerSocket server)
    {
      __sklib_ptr __skparam__server;
      __sklib_ptr __skreturn;
      __skparam__server = __skadapter__to_sklib_server_socket(server);
      __skreturn = __sklib__fetch_new_connection__server_socket(__skparam__server);
      return __skadapter__to_connection(__skreturn);
    }
    /// <summary>
    /// Does the connection with the supplied name exist?
    /// </summary>
    /// <param name="name"> The name of the connection to check.</param>
    /// <returns>True if there is a connection with the supplied name</returns>
    public static bool HasConnection(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_connection__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if there are any messages waiting to be read.
    /// </summary>
    /// <returns>True if there are any messages waiting to be read</returns>
    public static bool HasMessages()
    {
      int __skreturn;
      __skreturn = __sklib__has_messages();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if a connection has messages waiting to be read.
    /// </summary>
    /// <param name="con"> The connection</param>
    /// <returns>True if there are any messages on the connection.</returns>
    public static bool HasMessages(Connection con)
    {
      __sklib_ptr __skparam__con;
      int __skreturn;
      __skparam__con = __skadapter__to_sklib_connection(con);
      __skreturn = __sklib__has_messages__connection(__skparam__con);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if a server or connection has any messages.
    /// </summary>
    /// <param name="name"> The name of the server or connection to check.</param>
    /// <returns>[description]</returns>
    public static bool HasMessages(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_messages__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if a server has any messages waiting to be read.
    /// </summary>
    /// <param name="svr"> The server to check</param>
    /// <returns>True if there are messages on the server.</returns>
    public static bool HasMessages(ServerSocket svr)
    {
      __sklib_ptr __skparam__svr;
      int __skreturn;
      __skparam__svr = __skadapter__to_sklib_server_socket(svr);
      __skreturn = __sklib__has_messages__server_socket(__skparam__svr);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if any of the servers have new connections.
    /// </summary>
    /// <returns>True if there is one or more servers with new connections.</returns>
    public static bool HasNewConnections()
    {
      int __skreturn;
      __skreturn = __sklib__has_new_connections();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if there is a server with the indicated name.
    /// </summary>
    /// <param name="name"> The name of the server to check</param>
    /// <returns>True if there is a server with that name</returns>
    public static bool HasServer(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_server__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// The supplied hexadecimal string is translated into ipv4 standard address string. Function handles hex strings starting with or without 0x. e.g. 127.0.0.1 from 0x7F000001
    /// </summary>
    /// <param name="aHex"> hexadecimal ipv4 string to convert</param>
    /// <returns>standard ipv4 address using format X.X.X.X</returns>
    public static string HexStrToIpv4(string aHex)
    {
      __sklib_string __skparam__a_hex;
      __sklib_string __skreturn;
      __skparam__a_hex = __skadapter__to_sklib_string(aHex);
      __skreturn = __sklib__hex_str_to_ipv4__string_ref(__skparam__a_hex);
    __skadapter__free__sklib_string(ref __skparam__a_hex);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// The supplied hexadecimal string is converted into it's decimal representation e.g. 7F into 127
    /// </summary>
    /// <param name="aHex"> hexadecimal string to convert</param>
    /// <returns>decimal representation of supplied hex string</returns>
    public static string HexToDecString(string aHex)
    {
      __sklib_string __skparam__a_hex;
      __sklib_string __skreturn;
      __skparam__a_hex = __skadapter__to_sklib_string(aHex);
      __skreturn = __sklib__hex_to_dec_string__string_ref(__skparam__a_hex);
    __skadapter__free__sklib_string(ref __skparam__a_hex);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Encodes the supplied ipv4 address string (in format X.X.X.X) into a single integer e.g. 127.0.0.1 into 2130706433
    /// </summary>
    /// <param name="aIP"> ipv4 address to encode</param>
    /// <returns>encoded ipv4 string</returns>
    public static uint Ipv4ToDec(string aIP)
    {
      __sklib_string __skparam__a_ip;
      uint __skreturn;
      __skparam__a_ip = __skadapter__to_sklib_string(aIP);
      __skreturn = __sklib__ipv4_to_dec__string_ref(__skparam__a_ip);
    __skadapter__free__sklib_string(ref __skparam__a_ip);
      return __skadapter__to_unsigned_int(__skreturn);
    }
    /// <summary>
    /// Converts an ipv4 address into it's hexadecimal representation e.g. 0x7F000001 from 127.0.0.1
    /// </summary>
    /// <param name="aIP"> ip address to convert</param>
    /// <returns>hexadecimal representation of ipc4 string</returns>
    public static string Ipv4ToHex(string aIP)
    {
      __sklib_string __skparam__a_ip;
      __sklib_string __skreturn;
      __skparam__a_ip = __skadapter__to_sklib_string(aIP);
      __skreturn = __sklib__ipv4_to_hex__string_ref(__skparam__a_ip);
    __skadapter__free__sklib_string(ref __skparam__a_ip);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Checks if the connection currently is open.
    /// </summary>
    /// <param name="con"> The connection</param>
    /// <returns>True if the connection is open.</returns>
    public static bool IsConnectionOpen(Connection con)
    {
      __sklib_ptr __skparam__con;
      int __skreturn;
      __skparam__con = __skadapter__to_sklib_connection(con);
      __skreturn = __sklib__is_connection_open__connection(__skparam__con);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if the connection with the supplied name currently is open.
    /// </summary>
    /// <param name="name"> The name of the connection</param>
    /// <returns>True if the connection is open.</returns>
    public static bool IsConnectionOpen(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__is_connection_open__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="ip"> The string containing the IP address to validate</param>
    /// <returns>bool Returns true if the string is a valid IPv4 address, false otherwise</returns>
    public static bool IsValidIpv4(string ip)
    {
      __sklib_string __skparam__ip;
      int __skreturn;
      __skparam__ip = __skadapter__to_sklib_string(ip);
      __skreturn = __sklib__is_valid_ipv4__string_ref(__skparam__ip);
    __skadapter__free__sklib_string(ref __skparam__ip);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Gets the last client that connected to a server.
    /// </summary>
    /// <param name="name"> The name of the server to check</param>
    /// <returns>The last connection made to that server</returns>
    public static Connection LastConnection(string name)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__last_connection__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_connection(__skreturn);
    }
    /// <summary>
    /// Gets the last client that connected to a server.
    /// </summary>
    /// <param name="server"> The server to check</param>
    /// <returns>The last connection made to that server</returns>
    public static Connection LastConnection(ServerSocket server)
    {
      __sklib_ptr __skparam__server;
      __sklib_ptr __skreturn;
      __skparam__server = __skadapter__to_sklib_server_socket(server);
      __skreturn = __sklib__last_connection__server_socket(__skparam__server);
      return __skadapter__to_connection(__skreturn);
    }
    /// <summary>
    /// Returns the connection that sent a message.
    /// </summary>
    /// <param name="msg"> The message</param>
    /// <returns>The connection that sent the message</returns>
    public static Connection MessageConnection(Message msg)
    {
      __sklib_ptr __skparam__msg;
      __sklib_ptr __skreturn;
      __skparam__msg = __skadapter__to_sklib_message(msg);
      __skreturn = __sklib__message_connection__message(__skparam__msg);
      return __skadapter__to_connection(__skreturn);
    }
    /// <summary>
    /// Returns the number of messages on a server.
    /// </summary>
    /// <param name="svr"> The server to check</param>
    /// <returns>The number of messages on the server</returns>
    public static uint MessageCount(ServerSocket svr)
    {
      __sklib_ptr __skparam__svr;
      uint __skreturn;
      __skparam__svr = __skadapter__to_sklib_server_socket(svr);
      __skreturn = __sklib__message_count__server_socket(__skparam__svr);
      return __skadapter__to_unsigned_int(__skreturn);
    }
    /// <summary>
    /// Returns the number of messages on a connection.
    /// </summary>
    /// <param name="aConnection"> The connection</param>
    /// <returns>The number of messages to be read from the connection</returns>
    public static uint MessageCount(Connection aConnection)
    {
      __sklib_ptr __skparam__a_connection;
      uint __skreturn;
      __skparam__a_connection = __skadapter__to_sklib_connection(aConnection);
      __skreturn = __sklib__message_count__connection(__skparam__a_connection);
      return __skadapter__to_unsigned_int(__skreturn);
    }
    /// <summary>
    /// Returns the number of messages on a server or connection.
    /// </summary>
    /// <param name="name"> The name of the server or connection</param>
    /// <returns>The number of messages on the server or connection</returns>
    public static uint MessageCount(string name)
    {
      __sklib_string __skparam__name;
      uint __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__message_count__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_unsigned_int(__skreturn);
    }
    /// <summary>
    /// Gets the body of a message as a string.
    /// </summary>
    /// <param name="msg"> The message to check</param>
    /// <returns>The string body of the message</returns>
    public static string MessageData(Message msg)
    {
      __sklib_ptr __skparam__msg;
      __sklib_string __skreturn;
      __skparam__msg = __skadapter__to_sklib_message(msg);
      __skreturn = __sklib__message_data__message(__skparam__msg);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Gets the body of a message as a list of bytes.
    /// </summary>
    /// <param name="msg"> The message to check</param>
    /// <returns>The body of the message as bytes</returns>
    public static List<byte> MessageDataBytes(Message msg)
    {
      __sklib_ptr __skparam__msg;
      __sklib_vector_int8_t __skreturn;
      __skparam__msg = __skadapter__to_sklib_message(msg);
      __skreturn = __sklib__message_data_bytes__message(__skparam__msg);
      return __skadapter__to_vector_int8_t(__skreturn);
    }
    /// <summary>
    /// Returns the host who made the message.
    /// </summary>
    /// <param name="msg"> The message to check</param>
    /// <returns>The host who sent the message</returns>
    public static string MessageHost(Message msg)
    {
      __sklib_ptr __skparam__msg;
      __sklib_string __skreturn;
      __skparam__msg = __skadapter__to_sklib_message(msg);
      __skreturn = __sklib__message_host__message(__skparam__msg);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns the port used to send a message.
    /// </summary>
    /// <param name="msg"> The message to check</param>
    /// <returns>The port of the message</returns>
    public static ushort MessagePort(Message msg)
    {
      __sklib_ptr __skparam__msg;
      ushort __skreturn;
      __skparam__msg = __skadapter__to_sklib_message(msg);
      __skreturn = __sklib__message_port__message(__skparam__msg);
      return __skadapter__to_unsigned_short(__skreturn);
    }
    /// <summary>
    /// Returns the protocol used to send a message.
    /// </summary>
    /// <param name="msg"> The message to check</param>
    /// <returns>The protocol used to sent the message</returns>
    public static ConnectionType MessageProtocol(Message msg)
    {
      __sklib_ptr __skparam__msg;
      int __skreturn;
      __skparam__msg = __skadapter__to_sklib_message(msg);
      __skreturn = __sklib__message_protocol__message(__skparam__msg);
      return __skadapter__to_connection_type(__skreturn);
    }
    /// <summary>
    /// Returns the ipv4 string of the localhost loopback for the current computer.
    /// </summary>
    /// <returns>ipv4 address string in X.X.X.X format</returns>
    public static string MyIP()
    {
      __sklib_string __skreturn;
      __skreturn = __sklib__my_ip();
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns the name SplashKit would use for a connection made to a server from a host to a port.
    /// </summary>
    /// <param name="host"> The host name</param>
    /// <param name="port"> The port</param>
    /// <returns>The name SplashKit would use for this connection</returns>
    public static string NameForConnection(string host, uint port)
    {
      __sklib_string __skparam__host;
      uint __skparam__port;
      __sklib_string __skreturn;
      __skparam__host = __skadapter__to_sklib_string(host);
      __skparam__port = __skadapter__to_sklib_unsigned_int(port);
      __skreturn = __sklib__name_for_connection__string__unsigned_int(__skparam__host, __skparam__port);
    __skadapter__free__sklib_string(ref __skparam__host);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Get the number of new connections made to the server. The count will increase as the server accepts new connections. The count decreases each time you fetch a new connection, or can be set to 0 if you reset the new connection count.
    /// </summary>
    /// <param name="server"> The server to check</param>
    /// <returns>The number of new connections</returns>
    public static int NewConnectionCount(ServerSocket server)
    {
      __sklib_ptr __skparam__server;
      int __skreturn;
      __skparam__server = __skadapter__to_sklib_server_socket(server);
      __skreturn = __sklib__new_connection_count__server_socket(__skparam__server);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Opens a TCP connection to a server using the supplied details.
    /// </summary>
    /// <param name="name"> The name for the connection</param>
    /// <param name="host"> The address of the server</param>
    /// <param name="port"> The server's port</param>
    /// <returns>A new connection to the indicated server</returns>
    public static Connection OpenConnection(string name, string host, ushort port)
    {
      __sklib_string __skparam__name;
      __sklib_string __skparam__host;
      ushort __skparam__port;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__host = __skadapter__to_sklib_string(host);
      __skparam__port = __skadapter__to_sklib_unsigned_short(port);
      __skreturn = __sklib__open_connection__string_ref__string_ref__unsigned_short(__skparam__name, __skparam__host, __skparam__port);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__host);
      return __skadapter__to_connection(__skreturn);
    }
    /// <summary>
    /// Opens a connection to a server using the supplied details.
    /// </summary>
    /// <param name="name"> The name for the connection</param>
    /// <param name="host"> The address of the server</param>
    /// <param name="port"> The server's port</param>
    /// <param name="protocol"> The protocol used to connect to the server</param>
    /// <returns>A new connection to the indicated server</returns>
    public static Connection OpenConnection(string name, string host, ushort port, ConnectionType protocol)
    {
      __sklib_string __skparam__name;
      __sklib_string __skparam__host;
      ushort __skparam__port;
      int __skparam__protocol;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__host = __skadapter__to_sklib_string(host);
      __skparam__port = __skadapter__to_sklib_unsigned_short(port);
      __skparam__protocol = __skadapter__to_sklib_connection_type(protocol);
      __skreturn = __sklib__open_connection__string_ref__string_ref__unsigned_short__connection_type(__skparam__name, __skparam__host, __skparam__port, __skparam__protocol);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__host);
      return __skadapter__to_connection(__skreturn);
    }
    /// <summary>
    /// Read a message from the network (from a server or connection).
    /// </summary>
    /// <returns>The first message from the network.</returns>
    public static Message ReadMessage()
    {
      __sklib_ptr __skreturn;
      __skreturn = __sklib__read_message();
      return __skadapter__to_message(__skreturn);
    }
    /// <summary>
    /// Reads the first message from the connection.
    /// </summary>
    /// <param name="aConnection"> A connection</param>
    /// <returns>The first message read from the connection</returns>
    public static Message ReadMessage(Connection aConnection)
    {
      __sklib_ptr __skparam__a_connection;
      __sklib_ptr __skreturn;
      __skparam__a_connection = __skadapter__to_sklib_connection(aConnection);
      __skreturn = __sklib__read_message__connection(__skparam__a_connection);
      return __skadapter__to_message(__skreturn);
    }
    /// <summary>
    /// Reads the first message from a connection or server.
    /// </summary>
    /// <param name="name"> The name of a connection or server</param>
    /// <returns>The first message read from the connection or server</returns>
    public static Message ReadMessage(string name)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__read_message__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_message(__skreturn);
    }
    /// <summary>
    /// Reads the first message from the server.
    /// </summary>
    /// <param name="svr"> A server</param>
    /// <returns>The first message read from the server</returns>
    public static Message ReadMessage(ServerSocket svr)
    {
      __sklib_ptr __skparam__svr;
      __sklib_ptr __skreturn;
      __skparam__svr = __skadapter__to_sklib_server_socket(svr);
      __skreturn = __sklib__read_message__server_socket(__skparam__svr);
      return __skadapter__to_message(__skreturn);
    }
    /// <summary>
    /// Read message data from a connection or server.
    /// </summary>
    /// <param name="name"> The name of the connection or server</param>
    /// <returns>The data from the first message from the server or connection</returns>
    public static string ReadMessageData(string name)
    {
      __sklib_string __skparam__name;
      __sklib_string __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__read_message_data__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Read message data from a connection.
    /// </summary>
    /// <param name="aConnection"> The connection</param>
    /// <returns>The data from the first message on the connection</returns>
    public static string ReadMessageData(Connection aConnection)
    {
      __sklib_ptr __skparam__a_connection;
      __sklib_string __skreturn;
      __skparam__a_connection = __skadapter__to_sklib_connection(aConnection);
      __skreturn = __sklib__read_message_data__connection(__skparam__a_connection);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Read message data from a server.
    /// </summary>
    /// <param name="svr"> The server</param>
    /// <returns>The data from the first message on the server</returns>
    public static string ReadMessageData(ServerSocket svr)
    {
      __sklib_ptr __skparam__svr;
      __sklib_string __skreturn;
      __skparam__svr = __skadapter__to_sklib_server_socket(svr);
      __skreturn = __sklib__read_message_data__server_socket(__skparam__svr);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Attempt to reconnect the connection.
    /// </summary>
    /// <param name="aConnection"> The connection to reconnect</param>
    public static void Reconnect(Connection aConnection)
    {
      __sklib_ptr __skparam__a_connection;
      __skparam__a_connection = __skadapter__to_sklib_connection(aConnection);
      __sklib__reconnect__connection(__skparam__a_connection);
    }
    /// <summary>
    /// Attempt to reconnect the connection.
    /// </summary>
    /// <param name="name"> The name of the connection to reconnect.</param>
    public static void Reconnect(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__reconnect__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Close and release the resources used by all of the connections.
    /// </summary>
    public static void ReleaseAllConnections()
    {
      __sklib__release_all_connections();
    }
    /// <summary>
    /// Allows you to reset the new connection count to 0. (The connections are kept)
    /// </summary>
    /// <param name="server"> The server to check</param>
    public static void ResetNewConnectionCount(ServerSocket server)
    {
      __sklib_ptr __skparam__server;
      __skparam__server = __skadapter__to_sklib_server_socket(server);
      __sklib__reset_new_connection_count__server_socket(__skparam__server);
    }
    /// <summary>
    /// Get a connection from the server.
    /// </summary>
    /// <param name="name"> The name of the server</param>
    /// <param name="idx"> The index of the connection</param>
    /// <returns>The connection at the supplied index</returns>
    public static Connection RetrieveConnection(string name, int idx)
    {
      __sklib_string __skparam__name;
      int __skparam__idx;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skreturn = __sklib__retrieve_connection__string_ref__int(__skparam__name, __skparam__idx);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_connection(__skreturn);
    }
    /// <summary>
    /// Get a connection from the server.
    /// </summary>
    /// <param name="server"> The server</param>
    /// <param name="idx"> The index of the connection</param>
    /// <returns>The connection at the supplied index</returns>
    public static Connection RetrieveConnection(ServerSocket server, int idx)
    {
      __sklib_ptr __skparam__server;
      int __skparam__idx;
      __sklib_ptr __skreturn;
      __skparam__server = __skadapter__to_sklib_server_socket(server);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skreturn = __sklib__retrieve_connection__server_socket__int(__skparam__server, __skparam__idx);
      return __skadapter__to_connection(__skreturn);
    }
    /// <summary>
    /// Send a message to the connection.
    /// </summary>
    /// <param name="aMsg"> The message to send</param>
    /// <param name="aConnection"> The connection to send the message to</param>
    /// <returns>True if the message sends.</returns>
    public static bool SendMessageTo(string aMsg, Connection aConnection)
    {
      __sklib_string __skparam__a_msg;
      __sklib_ptr __skparam__a_connection;
      int __skreturn;
      __skparam__a_msg = __skadapter__to_sklib_string(aMsg);
      __skparam__a_connection = __skadapter__to_sklib_connection(aConnection);
      __skreturn = __sklib__send_message_to__string_ref__connection(__skparam__a_msg, __skparam__a_connection);
    __skadapter__free__sklib_string(ref __skparam__a_msg);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Send a message to the connection with the given name.
    /// </summary>
    /// <param name="aMsg"> The message to send</param>
    /// <param name="name"> The name of the connection to send the message to</param>
    /// <returns>True if the message sends</returns>
    public static bool SendMessageTo(string aMsg, string name)
    {
      __sklib_string __skparam__a_msg;
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__a_msg = __skadapter__to_sklib_string(aMsg);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__send_message_to__string_ref__string_ref(__skparam__a_msg, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__a_msg);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks of there are new connections waiting for a server.
    /// </summary>
    /// <param name="name"> The name of the server to check</param>
    /// <returns>True if the server has new connections</returns>
    public static bool ServerHasNewConnection(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__server_has_new_connection__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks of there are new connections waiting for a server.
    /// </summary>
    /// <param name="server"> The server to check</param>
    /// <returns>True if the server has new connections</returns>
    public static bool ServerHasNewConnection(ServerSocket server)
    {
      __sklib_ptr __skparam__server;
      int __skreturn;
      __skparam__server = __skadapter__to_sklib_server_socket(server);
      __skreturn = __sklib__server_has_new_connection__server_socket(__skparam__server);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Gets the server with the indicated name.
    /// </summary>
    /// <param name="name"> The name of the server to get</param>
    /// <returns>The server</returns>
    public static ServerSocket ServerNamed(string name)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__server_named__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_server_socket(__skreturn);
    }
    /// <summary>
    /// Change the size of the UDP packets.
    /// </summary>
    /// <param name="udpPacketSize"> The new packet size.</param>
    public static void SetUDPPacketSize(uint udpPacketSize)
    {
      uint __skparam__udp_packet_size;
      __skparam__udp_packet_size = __skadapter__to_sklib_unsigned_int(udpPacketSize);
      __sklib__set_udp_packet_size__unsigned_int(__skparam__udp_packet_size);
    }
    /// <summary>
    /// Returns the size SplashKit is using for UDP packets.
    /// </summary>
    /// <returns>The size of UDP packets.</returns>
    public static uint UDPPacketSize()
    {
      uint __skreturn;
      __skreturn = __sklib__udp_packet_size();
      return __skadapter__to_unsigned_int(__skreturn);
    }
    /// <summary>
    /// Draws an individual pixel to the current window.
    /// </summary>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="pt"> The location of the pixel to draw</param>
    public static void DrawPixel(Color clr, Point2D pt)
    {
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__pt;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __sklib__draw_pixel__color__point_2d_ref(__skparam__clr, __skparam__pt);
    }
    /// <summary>
    /// Draws an individual pixel with the supplied options.
    /// </summary>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="pt"> The location of the pixel to draw</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawPixel(Color clr, Point2D pt, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__pt;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_pixel__color__point_2d_ref__drawing_options(__skparam__clr, __skparam__pt, __skparam__opts);
    }
    /// <summary>
    /// Draws an individual pixel to the current window.
    /// </summary>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="x"> The distance from the left edge of the window to the pixel</param>
    /// <param name="y"> The distance from the top edge of the window to the pixel</param>
    public static void DrawPixel(Color clr, double x, double y)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_pixel__color__double__double(__skparam__clr, __skparam__x, __skparam__y);
    }
    /// <summary>
    /// Draws an individual pixel with the supplied options.
    /// </summary>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="x"> The distance from the left edge of the window/bitmap to the pixel</param>
    /// <param name="y"> The distance from the top edge of the window/bitmap to the pixel</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawPixel(Color clr, double x, double y, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_pixel__color__double__double__drawing_options(__skparam__clr, __skparam__x, __skparam__y, __skparam__opts);
    }
    /// <summary>
    /// Draws an individual pixel to the given bitmap.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the pixel on</param>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="pt"> The location of the pixel to draw</param>
    public static void DrawPixelOnBitmap(Bitmap destination, Color clr, Point2D pt)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__pt;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __sklib__draw_pixel_on_bitmap__bitmap__color__point_2d_ref(__skparam__destination, __skparam__clr, __skparam__pt);
    }
    /// <summary>
    /// Draws an individual pixel to the given bitmap with the given drawing options.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the pixel on</param>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="pt"> The location of the pixel to draw</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawPixelOnBitmap(Bitmap destination, Color clr, Point2D pt, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__pt;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_pixel_on_bitmap__bitmap__color__point_2d_ref__drawing_options(__skparam__destination, __skparam__clr, __skparam__pt, __skparam__opts);
    }
    /// <summary>
    /// Draws an individual pixel to the given bitmap.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the pixel on</param>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="x"> The distance from the left edge of the bitmap to the pixel</param>
    /// <param name="y"> The distance from the top edge of the bitmap to the pixel</param>
    public static void DrawPixelOnBitmap(Bitmap destination, Color clr, double x, double y)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_pixel_on_bitmap__bitmap__color__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y);
    }
    /// <summary>
    /// Draws an individual pixel to the given bitmap with the given drawing options.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the pixel on</param>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="x"> The distance from the left edge of the bitmap to the pixel</param>
    /// <param name="y"> The distance from the top edge of the bitmap to the pixel</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawPixelOnBitmap(Bitmap destination, Color clr, double x, double y, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_pixel_on_bitmap__bitmap__color__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__opts);
    }
    /// <summary>
    /// Draws an individual pixel to the given window.
    /// </summary>
    /// <param name="destination"> The window to draw the pixel on</param>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="pt"> The location of the pixel to draw</param>
    public static void DrawPixelOnWindow(Window destination, Color clr, Point2D pt)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__pt;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __sklib__draw_pixel_on_window__window__color__point_2d_ref(__skparam__destination, __skparam__clr, __skparam__pt);
    }
    /// <summary>
    /// Draws an individual pixel to the given window with the given drawing options.
    /// </summary>
    /// <param name="destination"> The window to draw the pixel on</param>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="pt"> The location of the pixel to draw</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawPixelOnWindow(Window destination, Color clr, Point2D pt, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_point_2d __skparam__pt;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_pixel_on_window__window__color__point_2d_ref__drawing_options(__skparam__destination, __skparam__clr, __skparam__pt, __skparam__opts);
    }
    /// <summary>
    /// Draws an individual pixel to the given window.
    /// </summary>
    /// <param name="destination"> the window to draw the pixel on</param>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="x"> The distance from the left edge of the window to the pixel</param>
    /// <param name="y"> The distance from the top edge of the window to the pixel</param>
    public static void DrawPixelOnWindow(Window destination, Color clr, double x, double y)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_pixel_on_window__window__color__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y);
    }
    /// <summary>
    /// Draws an individual pixel to the given window with the given drawing options.
    /// </summary>
    /// <param name="destination"> The window to draw the pixel on</param>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="x"> The distance from the left edge of the window to the pixel</param>
    /// <param name="y"> The distance from the top edge of the window to the pixel</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawPixelOnWindow(Window destination, Color clr, double x, double y, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_pixel_on_window__window__color__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__opts);
    }
    /// <summary>
    /// Returns the color of the pixel at the location on the supplied bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the color from</param>
    /// <param name="pt"> The position of the pixel</param>
    /// <returns>The color of the pixel at the supplied location</returns>
    public static Color GetPixel(Bitmap bmp, Point2D pt)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skparam__pt;
      __sklib_color __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__get_pixel__bitmap__point_2d_ref(__skparam__bmp, __skparam__pt);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns the color of the pixel at the x,y location on the supplied bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap to get the color from</param>
    /// <param name="x"> The distance from the left edge of the bitmap to the pixel to read</param>
    /// <param name="y"> The distance from the top of the bitmap to the pixel to read</param>
    /// <returns>The color of the pixel at the supplied location</returns>
    public static Color GetPixel(Bitmap bmp, double x, double y)
    {
      __sklib_ptr __skparam__bmp;
      double __skparam__x;
      double __skparam__y;
      __sklib_color __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__get_pixel__bitmap__double__double(__skparam__bmp, __skparam__x, __skparam__y);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns the color of the pixel at the x,y location on the current window.
    /// </summary>
    /// <param name="pt"> The position of the pixel</param>
    /// <returns>The color of the pixel at the supplied location</returns>
    public static Color GetPixel(Point2D pt)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_color __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__get_pixel__point_2d_ref(__skparam__pt);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns the color of the pixel at the x,y location on the current window.
    /// </summary>
    /// <param name="x"> The distance from the left edge of the window to the pixel to read</param>
    /// <param name="y"> The distance from the top of the window to the pixel to read</param>
    /// <returns>The color of the pixel at the supplied location</returns>
    public static Color GetPixel(double x, double y)
    {
      double __skparam__x;
      double __skparam__y;
      __sklib_color __skreturn;
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__get_pixel__double__double(__skparam__x, __skparam__y);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns the color of the pixel at the location on the supplied window.
    /// </summary>
    /// <param name="wnd"> The window to get the color from</param>
    /// <param name="pt"> The position of the pixel</param>
    /// <returns>The color of the pixel at the supplied location</returns>
    public static Color GetPixel(Window wnd, Point2D pt)
    {
      __sklib_ptr __skparam__wnd;
      __sklib_point_2d __skparam__pt;
      __sklib_color __skreturn;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__get_pixel__window__point_2d_ref(__skparam__wnd, __skparam__pt);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns the color of the pixel at the x,y location on the supplied window.
    /// </summary>
    /// <param name="wnd"> The window to get the color from</param>
    /// <param name="x"> The distance from the left edge of the window to the pixel to read</param>
    /// <param name="y"> The distance from the top of the window to the pixel to read</param>
    /// <returns>The color of the pixel at the supplied location</returns>
    public static Color GetPixel(Window wnd, double x, double y)
    {
      __sklib_ptr __skparam__wnd;
      double __skparam__x;
      double __skparam__y;
      __sklib_color __skreturn;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__get_pixel__window__double__double(__skparam__wnd, __skparam__x, __skparam__y);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns the color of the pixel at the x,y location on the given window.
    /// </summary>
    /// <param name="destination"> The window to draw the pixel on</param>
    /// <param name="pt"> The position of the pixel</param>
    /// <returns>The color of the pixel at the supplied location</returns>
    public static Color GetPixelFromWindow(Window destination, Point2D pt)
    {
      __sklib_ptr __skparam__destination;
      __sklib_point_2d __skparam__pt;
      __sklib_color __skreturn;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__get_pixel_from_window__window__point_2d_ref(__skparam__destination, __skparam__pt);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns the color of the pixel at the x,y location on the given window.
    /// </summary>
    /// <param name="destination"> The window to draw the pixel on</param>
    /// <param name="x"> The distance from the left edge of the window to the pixel to read</param>
    /// <param name="y"> The distance from the top of the window to the pixel to read</param>
    /// <returns>The color of the pixel at the supplied location</returns>
    public static Color GetPixelFromWindow(Window destination, double x, double y)
    {
      __sklib_ptr __skparam__destination;
      double __skparam__x;
      double __skparam__y;
      __sklib_color __skreturn;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__get_pixel_from_window__window__double__double(__skparam__destination, __skparam__x, __skparam__y);
      return __skadapter__to_color(__skreturn);
    }
    /// <summary>
    /// Returns a point at the given location.
    /// </summary>
    /// <param name="x"> The x value of the coordinate</param>
    /// <param name="y"> The y value of the coordinate</param>
    /// <returns>A point at the given location</returns>
    public static Point2D PointAt(double x, double y)
    {
      double __skparam__x;
      double __skparam__y;
      __sklib_point_2d __skreturn;
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__point_at__double__double(__skparam__x, __skparam__y);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns a point representing the origin.
    /// </summary>
    /// <returns>A point with x and y set to 0</returns>
    public static Point2D PointAtOrigin()
    {
      __sklib_point_2d __skreturn;
      __skreturn = __sklib__point_at_origin();
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns true if the point `pt` is in the circle `c`.
    /// </summary>
    /// <param name="pt"> The point to test</param>
    /// <param name="c"> The circle to check</param>
    /// <returns>True if the point is within the area of the circle</returns>
    public static bool PointInCircle(Point2D pt, Circle c)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_circle __skparam__c;
      int __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skreturn = __sklib__point_in_circle__point_2d_ref__circle_ref(__skparam__pt, __skparam__c);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Return true if the point is in the circle.
    /// </summary>
    /// <param name="ptx"> the x value of the point</param>
    /// <param name="pty"> the y value of the point</param>
    /// <param name="cx"> the x value of the centre of the circle</param>
    /// <param name="cy"> the y value of the centre of the circle</param>
    /// <param name="radius"> the radius of the circle</param>
    /// <returns>True when the point is in the circle, otherwise it returns false.</returns>
    public static bool PointInCircle(double ptx, double pty, double cx, double cy, double radius)
    {
      double __skparam__ptx;
      double __skparam__pty;
      double __skparam__cx;
      double __skparam__cy;
      double __skparam__radius;
      int __skreturn;
      __skparam__ptx = __skadapter__to_sklib_double(ptx);
      __skparam__pty = __skadapter__to_sklib_double(pty);
      __skparam__cx = __skadapter__to_sklib_double(cx);
      __skparam__cy = __skadapter__to_sklib_double(cy);
      __skparam__radius = __skadapter__to_sklib_double(radius);
      __skreturn = __sklib__point_in_circle__double__double__double__double__double(__skparam__ptx, __skparam__pty, __skparam__cx, __skparam__cy, __skparam__radius);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Tests if a point is in a quad.
    /// </summary>
    /// <param name="pt"> The point to test.</param>
    /// <param name="q"> The quad to check if the point is within.</param>
    /// <returns>True if pt lies within the area of q.</returns>
    public static bool PointInQuad(Point2D pt, Quad q)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_quad __skparam__q;
      int __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skreturn = __sklib__point_in_quad__point_2d_ref__quad_ref(__skparam__pt, __skparam__q);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true if point `pt` is in the Rectangle `rect`.
    /// </summary>
    /// <param name="pt"> The point to test</param>
    /// <param name="rect"> The rectangle to check</param>
    /// <returns>True if the point is within the rectangle</returns>
    public static bool PointInRectangle(Point2D pt, Rectangle rect)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__point_in_rectangle__point_2d_ref__rectangle_ref(__skparam__pt, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true if the point is within the bounds of a Rectangle.
    /// </summary>
    /// <param name="ptx"> the x value of the point</param>
    /// <param name="pty"> the y value of the point</param>
    /// <param name="rectX"> x value of the rectangle</param>
    /// <param name="rectY"> y value of the rectangle</param>
    /// <param name="rectWidth"> width of the rectangle</param>
    /// <param name="rectHeight"> height of the rectangle</param>
    /// <returns>true when the point is in the rectangle, otherwise it returns false.</returns>
    public static bool PointInRectangle(double ptx, double pty, double rectX, double rectY, double rectWidth, double rectHeight)
    {
      double __skparam__ptx;
      double __skparam__pty;
      double __skparam__rect_x;
      double __skparam__rect_y;
      double __skparam__rect_width;
      double __skparam__rect_height;
      int __skreturn;
      __skparam__ptx = __skadapter__to_sklib_double(ptx);
      __skparam__pty = __skadapter__to_sklib_double(pty);
      __skparam__rect_x = __skadapter__to_sklib_double(rectX);
      __skparam__rect_y = __skadapter__to_sklib_double(rectY);
      __skparam__rect_width = __skadapter__to_sklib_double(rectWidth);
      __skparam__rect_height = __skadapter__to_sklib_double(rectHeight);
      __skreturn = __sklib__point_in_rectangle__double__double__double__double__double__double(__skparam__ptx, __skparam__pty, __skparam__rect_x, __skparam__rect_y, __skparam__rect_width, __skparam__rect_height);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true if the point `pt` is in the Triangle `tri`.
    /// </summary>
    /// <param name="pt"> The point to test</param>
    /// <param name="tri"> The triangle to check</param>
    /// <returns>True if the point is within the triangle</returns>
    public static bool PointInTriangle(Point2D pt, Triangle tri)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_triangle __skparam__tri;
      int __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skreturn = __sklib__point_in_triangle__point_2d_ref__triangle_ref(__skparam__pt, __skparam__tri);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the distance from a point to a line.
    /// </summary>
    /// <param name="pt"> The point</param>
    /// <param name="l"> The line</param>
    /// <returns>The distance from `pt` to `l`</returns>
    public static float PointLineDistance(Point2D pt, Line l)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_line __skparam__l;
      float __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__l = __skadapter__to_sklib_line(l);
      __skreturn = __sklib__point_line_distance__point_2d_ref__line_ref(__skparam__pt, __skparam__l);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Calculate the `point_2d` that is offset from the `start_point` by the `offset`
    /// </summary>
    /// <param name="startPoint"> The starting point</param>
    /// <param name="offset"> The distance and direction to move</param>
    /// <returns>A new point as a result of moving by the offset from the starting point</returns>
    public static Point2D PointOffsetBy(Point2D startPoint, Vector2D offset)
    {
      __sklib_point_2d __skparam__start_point;
      __sklib_vector_2d __skparam__offset;
      __sklib_point_2d __skreturn;
      __skparam__start_point = __skadapter__to_sklib_point_2d(startPoint);
      __skparam__offset = __skadapter__to_sklib_vector_2d(offset);
      __skreturn = __sklib__point_offset_by__point_2d_ref__vector_2d_ref(__skparam__start_point, __skparam__offset);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns the point offset from the origin by the provided vector.
    /// </summary>
    /// <param name="offset"> The distance and direction to move</param>
    /// <returns>A new point as a result of moving by the offset from the starting point</returns>
    public static Point2D PointOffsetFromOrigin(Vector2D offset)
    {
      __sklib_vector_2d __skparam__offset;
      __sklib_point_2d __skreturn;
      __skparam__offset = __skadapter__to_sklib_vector_2d(offset);
      __skreturn = __sklib__point_offset_from_origin__vector_2d_ref(__skparam__offset);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns true if point `pt` is on the line `l`.
    /// </summary>
    /// <param name="pt"> The point to test</param>
    /// <param name="l"> The line to check</param>
    /// <returns>True if the point is on the line</returns>
    public static bool PointOnLine(Point2D pt, Line l)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_line __skparam__l;
      int __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__l = __skadapter__to_sklib_line(l);
      __skreturn = __sklib__point_on_line__point_2d_ref__line_ref(__skparam__pt, __skparam__l);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true when the point `pt` is on the line `l`. The proximity value is used to set the sensitivity -- higher values effectively make the line thicker.
    /// </summary>
    /// <param name="pt"> The point to test</param>
    /// <param name="l"> The line to check</param>
    /// <param name="proximity"> The sensitivity to allow close approximities</param>
    /// <returns>True if the point is on the line</returns>
    public static bool PointOnLine(Point2D pt, Line l, float proximity)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_line __skparam__l;
      float __skparam__proximity;
      int __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__l = __skadapter__to_sklib_line(l);
      __skparam__proximity = __skadapter__to_sklib_float(proximity);
      __skreturn = __sklib__point_on_line__point_2d_ref__line_ref__float(__skparam__pt, __skparam__l, __skparam__proximity);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the angle between two points in degrees.
    /// </summary>
    /// <param name="pt1"> The first point</param>
    /// <param name="pt2"> The other point</param>
    /// <returns>The angle (in degrees) of the line between the points</returns>
    public static float PointPointAngle(Point2D pt1, Point2D pt2)
    {
      __sklib_point_2d __skparam__pt1;
      __sklib_point_2d __skparam__pt2;
      float __skreturn;
      __skparam__pt1 = __skadapter__to_sklib_point_2d(pt1);
      __skparam__pt2 = __skadapter__to_sklib_point_2d(pt2);
      __skreturn = __sklib__point_point_angle__point_2d_ref__point_2d_ref(__skparam__pt1, __skparam__pt2);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Returns the distance between two points.
    /// </summary>
    /// <param name="pt1"> The first point</param>
    /// <param name="pt2"> The other point</param>
    /// <returns>The distance between the two points</returns>
    public static double PointPointDistance(Point2D pt1, Point2D pt2)
    {
      __sklib_point_2d __skparam__pt1;
      __sklib_point_2d __skparam__pt2;
      double __skreturn;
      __skparam__pt1 = __skadapter__to_sklib_point_2d(pt1);
      __skparam__pt2 = __skadapter__to_sklib_point_2d(pt2);
      __skreturn = __sklib__point_point_distance__point_2d_ref__point_2d_ref(__skparam__pt1, __skparam__pt2);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Get a text description of the `point_2d`.
    /// </summary>
    /// <param name="pt"> The point details</param>
    /// <returns>A string representation of the point</returns>
    public static string PointToString(Point2D pt)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_string __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__point_to_string__point_2d_ref(__skparam__pt);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns a random point within the bounds of the bitmap.
    /// </summary>
    /// <param name="bmp"> The bitmap</param>
    /// <returns>A point within the bounds of the bitmap</returns>
    public static Point2D RandomBitmapPoint(Bitmap bmp)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_point_2d __skreturn;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skreturn = __sklib__random_bitmap_point__bitmap(__skparam__bmp);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns a random point on the current window.
    /// </summary>
    /// <returns>A point within the bounds of the current window</returns>
    public static Point2D RandomScreenPoint()
    {
      __sklib_point_2d __skreturn;
      __skreturn = __sklib__random_screen_point();
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns a random point on the provided window.
    /// </summary>
    /// <param name="wind"> The window</param>
    /// <returns>A point within the bounds of the window</returns>
    public static Point2D RandomWindowPoint(Window wind)
    {
      __sklib_ptr __skparam__wind;
      __sklib_point_2d __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skreturn = __sklib__random_window_point__window(__skparam__wind);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Returns True of `pt1` is at the same point as `pt2`. This checks at an integer level, indicating the two points refer to the same pixel.
    /// </summary>
    /// <param name="pt1"> The first point</param>
    /// <param name="pt2"> The other point</param>
    /// <returns>True if the two points are at the same location</returns>
    public static bool SamePoint(Point2D pt1, Point2D pt2)
    {
      __sklib_point_2d __skparam__pt1;
      __sklib_point_2d __skparam__pt2;
      int __skreturn;
      __skparam__pt1 = __skadapter__to_sklib_point_2d(pt1);
      __skparam__pt2 = __skadapter__to_sklib_point_2d(pt2);
      __skreturn = __sklib__same_point__point_2d_ref__point_2d_ref(__skparam__pt1, __skparam__pt2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns a quad from the passed in line and width. The quad will be a rectangle with the line as the diagonal, and the width as the width of the rectangle.
    /// </summary>
    /// <param name="lineOrigin"> The origin of the line</param>
    /// <param name="lineEnd"> The end of the line</param>
    /// <param name="width"> The width of the quad</param>
    /// <returns>A quad that represents the line with the given width</returns>
    public static Quad QuadFrom(Point2D lineOrigin, Point2D lineEnd, double width)
    {
      __sklib_point_2d __skparam__line_origin;
      __sklib_point_2d __skparam__line_end;
      double __skparam__width;
      __sklib_quad __skreturn;
      __skparam__line_origin = __skadapter__to_sklib_point_2d(lineOrigin);
      __skparam__line_end = __skadapter__to_sklib_point_2d(lineEnd);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skreturn = __sklib__quad_from__point_2d_ref__point_2d_ref__double(__skparam__line_origin, __skparam__line_end, __skparam__width);
      return __skadapter__to_quad(__skreturn);
    }
    /// <summary>
    /// Returns a quad from the passed in points.
    /// </summary>
    /// <param name="p1"> The top left of the quad.</param>
    /// <param name="p2"> The top right of the quad</param>
    /// <param name="p3"> The bottom left of the quad</param>
    /// <param name="p4"> The bottom right of the quad</param>
    /// <returns>A quad from the passed in points</returns>
    public static Quad QuadFrom(Point2D p1, Point2D p2, Point2D p3, Point2D p4)
    {
      __sklib_point_2d __skparam__p1;
      __sklib_point_2d __skparam__p2;
      __sklib_point_2d __skparam__p3;
      __sklib_point_2d __skparam__p4;
      __sklib_quad __skreturn;
      __skparam__p1 = __skadapter__to_sklib_point_2d(p1);
      __skparam__p2 = __skadapter__to_sklib_point_2d(p2);
      __skparam__p3 = __skadapter__to_sklib_point_2d(p3);
      __skparam__p4 = __skadapter__to_sklib_point_2d(p4);
      __skreturn = __sklib__quad_from__point_2d_ref__point_2d_ref__point_2d_ref__point_2d_ref(__skparam__p1, __skparam__p2, __skparam__p3, __skparam__p4);
      return __skadapter__to_quad(__skreturn);
    }
    /// <summary>
    /// Returns a quad from the x-y points of a given recatangle
    /// </summary>
    /// <param name="rect"> The rectangle to convert to a quad</param>
    /// <returns>A quad at the same location as the rectangle</returns>
    public static Quad QuadFrom(Rectangle rect)
    {
      __sklib_rectangle __skparam__rect;
      __sklib_quad __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__quad_from__rectangle_ref(__skparam__rect);
      return __skadapter__to_quad(__skreturn);
    }
    /// <summary>
    /// Returns a quad from the rectangle, then applies the transformation to the quads points.
    /// </summary>
    /// <param name="rect"> The rectangle to transform to a quad.</param>
    /// <param name="transform"> A transform to apply to the resulting quad.</param>
    /// <returns>A quad that represents the rectangle after the transformation.</returns>
    public static Quad QuadFrom(Rectangle rect, Matrix2D transform)
    {
      __sklib_rectangle __skparam__rect;
      __sklib_matrix_2d __skparam__transform;
      __sklib_quad __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__transform = __skadapter__to_sklib_matrix_2d(transform);
      __skreturn = __sklib__quad_from__rectangle_ref__matrix_2d_ref(__skparam__rect, __skparam__transform);
      return __skadapter__to_quad(__skreturn);
    }
    /// <summary>
    /// Returns a quad for the passed in x & y points.
    /// </summary>
    /// <param name="xTopLeft"> X coordinate of the top left of the quad</param>
    /// <param name="yTopLeft"> Y coordinate of the top left of the quad</param>
    /// <param name="xTopRight"> X coordinate of the top right of the quad</param>
    /// <param name="yTopRight"> Y coordinate of the top right of the quad</param>
    /// <param name="xBottomLeft"> X coordinate of the bottom left of the quad</param>
    /// <param name="yBottomLeft"> Y coordinate of the bottom left of the quad</param>
    /// <param name="xBottomRight"> X coordinate of the bottom right of the quad</param>
    /// <param name="yBottomRight"> Y coordinate of the bottom right of the quad</param>
    /// <returns>A quad with the indicated points</returns>
    public static Quad QuadFrom(double xTopLeft, double yTopLeft, double xTopRight, double yTopRight, double xBottomLeft, double yBottomLeft, double xBottomRight, double yBottomRight)
    {
      double __skparam__x_top_left;
      double __skparam__y_top_left;
      double __skparam__x_top_right;
      double __skparam__y_top_right;
      double __skparam__x_bottom_left;
      double __skparam__y_bottom_left;
      double __skparam__x_bottom_right;
      double __skparam__y_bottom_right;
      __sklib_quad __skreturn;
      __skparam__x_top_left = __skadapter__to_sklib_double(xTopLeft);
      __skparam__y_top_left = __skadapter__to_sklib_double(yTopLeft);
      __skparam__x_top_right = __skadapter__to_sklib_double(xTopRight);
      __skparam__y_top_right = __skadapter__to_sklib_double(yTopRight);
      __skparam__x_bottom_left = __skadapter__to_sklib_double(xBottomLeft);
      __skparam__y_bottom_left = __skadapter__to_sklib_double(yBottomLeft);
      __skparam__x_bottom_right = __skadapter__to_sklib_double(xBottomRight);
      __skparam__y_bottom_right = __skadapter__to_sklib_double(yBottomRight);
      __skreturn = __sklib__quad_from__double__double__double__double__double__double__double__double(__skparam__x_top_left, __skparam__y_top_left, __skparam__x_top_right, __skparam__y_top_right, __skparam__x_bottom_left, __skparam__y_bottom_left, __skparam__x_bottom_right, __skparam__y_bottom_right);
      return __skadapter__to_quad(__skreturn);
    }
    /// <summary>
    /// Detects if a ray intersects a quad.
    /// </summary>
    /// <param name="origin"> The starting point of the ray</param>
    /// <param name="heading"> The direction of the ray as a vector</param>
    /// <param name="q"> The quad to check for intersection</param>
    /// <returns>True if the ray intersects the quad, false otherwise</returns>
    public static bool QuadRayIntersection(Point2D origin, Vector2D heading, Quad q)
    {
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      __sklib_quad __skparam__q;
      int __skreturn;
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skreturn = __sklib__quad_ray_intersection__point_2d_ref__vector_2d_ref__quad_ref(__skparam__origin, __skparam__heading, __skparam__q);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Detects if a ray intersects a quad. If an intersection is found, the `hit_point` and `hit_distance` are set to the point of intersection and the distance from the ray's origin to the intersection point. If the ray's `origin` is contained within the quad, `hit_point` is set to the `origin` and `hit_distance` is set to 0. If no intersection is found, `hit_point` and `hit_distance` are not modified.
    /// </summary>
    /// <param name="origin"> The starting point of the ray</param>
    /// <param name="heading"> The direction of the ray as a vector</param>
    /// <param name="q"> The quad to check for intersection</param>
    /// <param name="hitPoint"> The point to set to where the ray intersects the quad</param>
    /// <param name="hitDistance"> The double to set to the distance from the ray's origin to the intersection point</param>
    /// <returns>True if the ray intersects the quad, false otherwise</returns>
    public static bool QuadRayIntersection(Point2D origin, Vector2D heading, Quad q, ref Point2D hitPoint, ref double hitDistance)
    {
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      __sklib_quad __skparam__q;
      __sklib_point_2d __skparam__hit_point;
      double __skparam__hit_distance;
      int __skreturn;
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skparam__hit_point = __skadapter__to_sklib_point_2d(hitPoint);
      __skparam__hit_distance = __skadapter__to_sklib_double(hitDistance);
      __skreturn = __sklib__quad_ray_intersection__point_2d_ref__vector_2d_ref__quad_ref__point_2d_ref__double_ref(__skparam__origin, __skparam__heading, __skparam__q, ref __skparam__hit_point, ref __skparam__hit_distance);
      hitPoint = __skadapter__to_point_2d(__skparam__hit_point);
      hitDistance = __skadapter__to_double(__skparam__hit_distance);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true if two quads intersect.
    /// </summary>
    /// <param name="q1"> The first quad</param>
    /// <param name="q2"> The second quad</param>
    /// <returns>True if the two quads intersect.</returns>
    public static bool QuadsIntersect(Quad q1, Quad q2)
    {
      __sklib_quad __skparam__q1;
      __sklib_quad __skparam__q2;
      int __skreturn;
      __skparam__q1 = __skadapter__to_sklib_quad(q1);
      __skparam__q2 = __skadapter__to_sklib_quad(q2);
      __skreturn = __sklib__quads_intersect__quad_ref__quad_ref(__skparam__q1, __skparam__q2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Change a point in a quad.
    /// </summary>
    /// <param name="q"> The quad to change</param>
    /// <param name="idx"> The index of the point: 0 is top left, 1 is top right, 2 is bottom left, and 3 is bottom right</param>
    /// <param name="value"> The new value for that point in the quad</param>
    public static void SetQuadPoint(ref Quad q, int idx, Point2D value)
    {
      __sklib_quad __skparam__q;
      int __skparam__idx;
      __sklib_point_2d __skparam__value;
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skparam__value = __skadapter__to_sklib_point_2d(value);
      __sklib__set_quad_point__quad_ref__int__point_2d_ref(ref __skparam__q, __skparam__idx, __skparam__value);
      q = __skadapter__to_quad(__skparam__q);
    }
    /// <summary>
    /// Returns the two triangles that make up a quad in a vector.
    /// </summary>
    /// <param name="q"> The quad</param>
    /// <returns>A vector with the two triangles from the quad.</returns>
    public static List<Triangle> TrianglesFrom(Quad q)
    {
      __sklib_quad __skparam__q;
      __sklib_vector_triangle __skreturn;
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skreturn = __sklib__triangles_from__quad_ref(__skparam__q);
      return __skadapter__to_vector_triangle(__skreturn);
    }
    /// <summary>
    /// Generates a random number between 'min' and `max`, including 'min' and 'max'.
    /// </summary>
    /// <param name="min"> the `int` representing of minimum bound.</param>
    /// <param name="max"> the `int` representing of maximum bound.</param>
    /// <returns>Returns an `int` between and including `min` and `max`</returns>
    public static int Rnd(int min, int max)
    {
      int __skparam__min;
      int __skparam__max;
      int __skreturn;
      __skparam__min = __skadapter__to_sklib_int(min);
      __skparam__max = __skadapter__to_sklib_int(max);
      __skreturn = __sklib__rnd__int__int(__skparam__min, __skparam__max);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Generates a random number between 0 and 1
    /// </summary>
    /// <returns>Returns a `float` between `0` and `1`</returns>
    public static float Rnd()
    {
      float __skreturn;
      __skreturn = __sklib__rnd();
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Generates a random number between 0 and `ubound`.
    /// </summary>
    /// <param name="ubound"> the `int` representing the upper bound.</param>
    /// <returns>Returns an `int` between `0` and `ubound`</returns>
    public static int Rnd(int ubound)
    {
      int __skparam__ubound;
      int __skreturn;
      __skparam__ubound = __skadapter__to_sklib_int(ubound);
      __skreturn = __sklib__rnd__int(__skparam__ubound);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Checks if the system has GPIO capabilities.
    /// </summary>
    /// <returns>true if the system has GPIO capabilities, false otherwise.</returns>
    public static bool HasGpio()
    {
      int __skreturn;
      __skreturn = __sklib__has_gpio();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// This function should be called when you are finished using the GPIO library. It sets all pin modes to INPUT and values to LOW.
    /// </summary>
    public static void RaspiCleanup()
    {
      __sklib__raspi_cleanup();
    }
    /// <summary>
    /// This function retrieves the mode of the specified pin.
    /// </summary>
    /// <param name="pin"> The pin to get the mode for.</param>
    /// <returns>The mode of the pin.</returns>
    public static PinModes RaspiGetMode(Pins pin)
    {
      int __skparam__pin;
      int __skreturn;
      __skparam__pin = __skadapter__to_sklib_pins(pin);
      __skreturn = __sklib__raspi_get_mode__pins(__skparam__pin);
      return __skadapter__to_pin_modes(__skreturn);
    }
    /// <summary>
    /// This function initializes the GPIO library for use. It should be called before any other GPIO functions.
    /// </summary>
    public static void RaspiInit()
    {
      __sklib__raspi_init();
    }
    /// <summary>
    /// This function reads the value from the specified pin.
    /// </summary>
    /// <param name="pin"> The pin to read the value from.</param>
    /// <returns>The value read from the pin.</returns>
    public static PinValues RaspiRead(Pins pin)
    {
      int __skparam__pin;
      int __skreturn;
      __skparam__pin = __skadapter__to_sklib_pins(pin);
      __skreturn = __sklib__raspi_read__pins(__skparam__pin);
      return __skadapter__to_pin_values(__skreturn);
    }
    /// <summary>
    /// This function sets the mode of the specified pin to the specified mode.
    /// </summary>
    /// <param name="pin"> The pin to set the mode for.</param>
    /// <param name="mode"> The mode to set for the pin.</param>
    public static void RaspiSetMode(Pins pin, PinModes mode)
    {
      int __skparam__pin;
      int __skparam__mode;
      __skparam__pin = __skadapter__to_sklib_pins(pin);
      __skparam__mode = __skadapter__to_sklib_pin_modes(mode);
      __sklib__raspi_set_mode__pins__pin_modes(__skparam__pin, __skparam__mode);
    }
    /// <summary>
    /// This function sets the pull-up/down mode for the specified pin.
    /// </summary>
    /// <param name="pin"> The pin to set the pull up/down mode for.</param>
    /// <param name="pud"> The pull up/down mode to set for the pin.</param>
    public static void RaspiSetPullUpDown(Pins pin, PullUpDown pud)
    {
      int __skparam__pin;
      int __skparam__pud;
      __skparam__pin = __skadapter__to_sklib_pins(pin);
      __skparam__pud = __skadapter__to_sklib_pull_up_down(pud);
      __sklib__raspi_set_pull_up_down__pins__pull_up_down(__skparam__pin, __skparam__pud);
    }
    /// <summary>
    /// This function sets the PWM duty cycle for the specified pin.
    /// </summary>
    /// <param name="pin"> The pin to set the PWM duty cycle for.</param>
    /// <param name="dutycycle"> The PWM duty cycle to set for the pin.</param>
    public static void RaspiSetPwmDutycycle(Pins pin, int dutycycle)
    {
      int __skparam__pin;
      int __skparam__dutycycle;
      __skparam__pin = __skadapter__to_sklib_pins(pin);
      __skparam__dutycycle = __skadapter__to_sklib_int(dutycycle);
      __sklib__raspi_set_pwm_dutycycle__pins__int(__skparam__pin, __skparam__dutycycle);
    }
    /// <summary>
    /// This function sets the PWM frequency for the specified pin.
    /// </summary>
    /// <param name="pin"> The pin to set the PWM frequency for.</param>
    /// <param name="frequency"> The PWM frequency to set for the pin.</param>
    public static void RaspiSetPwmFrequency(Pins pin, int frequency)
    {
      int __skparam__pin;
      int __skparam__frequency;
      __skparam__pin = __skadapter__to_sklib_pins(pin);
      __skparam__frequency = __skadapter__to_sklib_int(frequency);
      __sklib__raspi_set_pwm_frequency__pins__int(__skparam__pin, __skparam__frequency);
    }
    /// <summary>
    /// This function sets the PWM range for the specified pin.
    /// </summary>
    /// <param name="pin"> The pin to set the PWM range for.</param>
    /// <param name="range"> The PWM range to set for the pin.</param>
    public static void RaspiSetPwmRange(Pins pin, int range)
    {
      int __skparam__pin;
      int __skparam__range;
      __skparam__pin = __skadapter__to_sklib_pins(pin);
      __skparam__range = __skadapter__to_sklib_int(range);
      __sklib__raspi_set_pwm_range__pins__int(__skparam__pin, __skparam__range);
    }
    /// <summary>
    /// This function closes SPI communication on a particular channel.
    /// </summary>
    /// <param name="handle"> A reference to the specific SPI connection to close.</param>
    /// <returns>A value indicating success or failure.</returns>
    public static int RaspiSpiClose(int handle)
    {
      int __skparam__handle;
      int __skreturn;
      __skparam__handle = __skadapter__to_sklib_int(handle);
      __skreturn = __sklib__raspi_spi_close__int(__skparam__handle);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// This function opens SPI communication on a particular channel. It will return -1 if not using Raspberry Pi.
    /// </summary>
    /// <param name="channel"> The SPI channel to use.</param>
    /// <param name="speed"> The speed of data transfer (in baud).</param>
    /// <param name="spiFlags"> Optional flags for the SPI modes and settings.</param>
    /// <returns>The handle referencing this particular connection.</returns>
    public static int RaspiSpiOpen(int channel, int speed, int spiFlags)
    {
      int __skparam__channel;
      int __skparam__speed;
      int __skparam__spi_flags;
      int __skreturn;
      __skparam__channel = __skadapter__to_sklib_int(channel);
      __skparam__speed = __skadapter__to_sklib_int(speed);
      __skparam__spi_flags = __skadapter__to_sklib_int(spiFlags);
      __skreturn = __sklib__raspi_spi_open__int__int__int(__skparam__channel, __skparam__speed, __skparam__spi_flags);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// This function transfers data through SPI, it sends data from sendBuf and receives it into recvBuf.
    /// </summary>
    /// <param name="handle"> The reference for a specific SPI connection.</param>
    /// <param name="sendbuf"> The memory buffer for sending data.</param>
    /// <param name="recvbuf"> The memory buffer for receiving data.</param>
    /// <param name="count"> The number of bytes to be transferred.</param>
    /// <returns>The number of bytes that have actually been transfered.</returns>
    public static int RaspiSpiTransfer(int handle, string sendbuf, string recvbuf, int count)
    {
      int __skparam__handle;
      __sklib_string __skparam__sendBuf;
      __sklib_string __skparam__recvBuf;
      int __skparam__count;
      int __skreturn;
      __skparam__handle = __skadapter__to_sklib_int(handle);
      __skparam__sendBuf = __skadapter__to_sklib_string(sendbuf);
      __skparam__recvBuf = __skadapter__to_sklib_string(recvbuf);
      __skparam__count = __skadapter__to_sklib_int(count);
      __skreturn = __sklib__raspi_spi_transfer__int__string__string__int(__skparam__handle, __skparam__sendBuf, __skparam__recvBuf, __skparam__count);
    __skadapter__free__sklib_string(ref __skparam__sendBuf);
    __skadapter__free__sklib_string(ref __skparam__recvBuf);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// This function writes the specified value to the specified pin.
    /// </summary>
    /// <param name="pin"> The pin to write the value to.</param>
    /// <param name="value"> The value to write to the pin.</param>
    public static void RaspiWrite(Pins pin, PinValues value)
    {
      int __skparam__pin;
      int __skparam__value;
      __skparam__pin = __skadapter__to_sklib_pins(pin);
      __skparam__value = __skadapter__to_sklib_pin_values(value);
      __sklib__raspi_write__pins__pin_values(__skparam__pin, __skparam__value);
    }
    /// <summary>
    /// Draw a quad to the current window.
    /// </summary>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    public static void DrawQuad(Color clr, Quad q)
    {
      __sklib_color __skparam__clr;
      __sklib_quad __skparam__q;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __sklib__draw_quad__color__quad_ref(__skparam__clr, __skparam__q);
    }
    /// <summary>
    /// Draw a quad using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawQuad(Color clr, Quad q, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_quad __skparam__q;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_quad__color__quad_ref__drawing_options_ref(__skparam__clr, __skparam__q, __skparam__opts);
    }
    /// <summary>
    /// Draw a quad on the supplied bitmap to the current bitmap.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    public static void DrawQuadOnBitmap(Bitmap destination, Color clr, Quad q)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_quad __skparam__q;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __sklib__draw_quad_on_bitmap__bitmap__color__quad_ref(__skparam__destination, __skparam__clr, __skparam__q);
    }
    /// <summary>
    /// Draw a quad on the supplied bitmap using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawQuadOnBitmap(Bitmap destination, Color clr, Quad q, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_quad __skparam__q;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_quad_on_bitmap__bitmap__color__quad_ref__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__q, __skparam__opts);
    }
    /// <summary>
    /// Draw a quad on the supplied window to the current window.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    public static void DrawQuadOnWindow(Window destination, Color clr, Quad q)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_quad __skparam__q;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __sklib__draw_quad_on_window__window__color__quad_ref(__skparam__destination, __skparam__clr, __skparam__q);
    }
    /// <summary>
    /// Draw a quad on the supplied window using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawQuadOnWindow(Window destination, Color clr, Quad q, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_quad __skparam__q;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_quad_on_window__window__color__quad_ref__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__q, __skparam__opts);
    }
    /// <summary>
    /// Draw a rectangle onto the current window.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> The rectangle to draw</param>
    public static void DrawRectangle(Color clr, Rectangle rect)
    {
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__draw_rectangle__color__rectangle_ref(__skparam__clr, __skparam__rect);
    }
    /// <summary>
    /// Draw a rectangle using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> The rectangle to draw</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawRectangle(Color clr, Rectangle rect, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_rectangle__color__rectangle_ref__drawing_options_ref(__skparam__clr, __skparam__rect, __skparam__opts);
    }
    /// <summary>
    /// Draw a rectangle to the current window.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The distance from the left of the window/bitmap to the rectangle</param>
    /// <param name="y"> The distance from the top of the window/bitmap to the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    public static void DrawRectangle(Color clr, double x, double y, double width, double height)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __sklib__draw_rectangle__color__double__double__double__double(__skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Draw a rectangle using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The distance from the left of the window/bitmap to the rectangle</param>
    /// <param name="y"> The distance from the top of the window/bitmap to the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawRectangle(Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_rectangle__color__double__double__double__double__drawing_options_ref(__skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height, __skparam__opts);
    }
    /// <summary>
    /// Draw a rectangle to the bitmap using the supplied rect. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> the rectangle to be drawn to the bitmap</param>
    public static void DrawRectangleOnBitmap(Bitmap destination, Color clr, Rectangle rect)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__draw_rectangle_on_bitmap__bitmap__color__rectangle_ref(__skparam__destination, __skparam__clr, __skparam__rect);
    }
    /// <summary>
    /// Draw a rectangle to the bitmap using the supplied rect and drawing options. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> the rectangle to be drawn to the bitmap</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public static void DrawRectangleOnBitmap(Bitmap destination, Color clr, Rectangle rect, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_rectangle_on_bitmap__bitmap__color__rectangle_ref__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__rect, __skparam__opts);
    }
    /// <summary>
    /// Draw a rectangle to the bitmap using. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The x location of the rectangle</param>
    /// <param name="y"> The y location of the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    public static void DrawRectangleOnBitmap(Bitmap destination, Color clr, double x, double y, double width, double height)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __sklib__draw_rectangle_on_bitmap__bitmap__color__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Draw a rectangle to the bitmap using the supplied drawing options. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The x location of the rectangle</param>
    /// <param name="y"> The y location of the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public static void DrawRectangleOnBitmap(Bitmap destination, Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_rectangle_on_bitmap__bitmap__color__double__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height, __skparam__opts);
    }
    /// <summary>
    /// Draw a rectangle to the window using the supplied rect. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> the rectangle to be drawn to the window</param>
    public static void DrawRectangleOnWindow(Window destination, Color clr, Rectangle rect)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__draw_rectangle_on_window__window__color__rectangle_ref(__skparam__destination, __skparam__clr, __skparam__rect);
    }
    /// <summary>
    /// Draw a rectangle to the window using the supplied rect and drawing options. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> the rectangle to be drawn to the window</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public static void DrawRectangleOnWindow(Window destination, Color clr, Rectangle rect, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_rectangle_on_window__window__color__rectangle_ref__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__rect, __skparam__opts);
    }
    /// <summary>
    /// Draw a rectangle to the window using. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The x location of the rectangle</param>
    /// <param name="y"> The y location of the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    public static void DrawRectangleOnWindow(Window destination, Color clr, double x, double y, double width, double height)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __sklib__draw_rectangle_on_window__window__color__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Draw a rectangle to the window using the supplied drawing options. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The x location of the rectangle</param>
    /// <param name="y"> The y location of the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public static void DrawRectangleOnWindow(Window destination, Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_rectangle_on_window__window__color__double__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height, __skparam__opts);
    }
    /// <summary>
    /// Fill a quad on the current window.
    /// </summary>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    public static void FillQuad(Color clr, Quad q)
    {
      __sklib_color __skparam__clr;
      __sklib_quad __skparam__q;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __sklib__fill_quad__color__quad_ref(__skparam__clr, __skparam__q);
    }
    /// <summary>
    /// Fill a quad using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillQuad(Color clr, Quad q, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_quad __skparam__q;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_quad__color__quad_ref__drawing_options_ref(__skparam__clr, __skparam__q, __skparam__opts);
    }
    /// <summary>
    /// Fill a quad on the supplied bitmap on the current bitmap.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    public static void FillQuadOnBitmap(Bitmap destination, Color clr, Quad q)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_quad __skparam__q;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __sklib__fill_quad_on_bitmap__bitmap__color__quad_ref(__skparam__destination, __skparam__clr, __skparam__q);
    }
    /// <summary>
    /// Fill a quad on the supplied bitmap using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillQuadOnBitmap(Bitmap destination, Color clr, Quad q, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_quad __skparam__q;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_quad_on_bitmap__bitmap__color__quad_ref__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__q, __skparam__opts);
    }
    /// <summary>
    /// Fill a quad on the supplied window on the current window.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    public static void FillQuadOnWindow(Window destination, Color clr, Quad q)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_quad __skparam__q;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __sklib__fill_quad_on_window__window__color__quad_ref(__skparam__destination, __skparam__clr, __skparam__q);
    }
    /// <summary>
    /// Fill a quad on the supplied window using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillQuadOnWindow(Window destination, Color clr, Quad q, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_quad __skparam__q;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_quad_on_window__window__color__quad_ref__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__q, __skparam__opts);
    }
    /// <summary>
    /// Fill a rectangle onto the current window.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> The rectangle to draw</param>
    public static void FillRectangle(Color clr, Rectangle rect)
    {
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__fill_rectangle__color__rectangle_ref(__skparam__clr, __skparam__rect);
    }
    /// <summary>
    /// Fills a rectangle using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> The rectangle to draw</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillRectangle(Color clr, Rectangle rect, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_rectangle__color__rectangle_ref__drawing_options_ref(__skparam__clr, __skparam__rect, __skparam__opts);
    }
    /// <summary>
    /// Fills a rectangle to the current window.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The distance from the left of the window/bitmap to the rectangle</param>
    /// <param name="y"> The distance from the top of the window/bitmap to the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    public static void FillRectangle(Color clr, double x, double y, double width, double height)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __sklib__fill_rectangle__color__double__double__double__double(__skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Fills a rectangle using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The distance from the left of the window/bitmap to the rectangle</param>
    /// <param name="y"> The distance from the top of the window/bitmap to the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillRectangle(Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_rectangle__color__double__double__double__double__drawing_options_ref(__skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height, __skparam__opts);
    }
    /// <summary>
    /// Fill a rectangle on the supplied bitmap onto the current bitmap.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> The rectangle to draw</param>
    public static void FillRectangleOnBitmap(Bitmap destination, Color clr, Rectangle rect)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__fill_rectangle_on_bitmap__bitmap__color__rectangle_ref(__skparam__destination, __skparam__clr, __skparam__rect);
    }
    /// <summary>
    /// Fills a rectangle on the supplied bitmap using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> The rectangle to draw</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillRectangleOnBitmap(Bitmap destination, Color clr, Rectangle rect, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_rectangle_on_bitmap__bitmap__color__rectangle_ref__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__rect, __skparam__opts);
    }
    /// <summary>
    /// Fills a rectangle on the supplied bitmap to the current bitmap.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The distance from the left of the bitmap/bitmap to the rectangle</param>
    /// <param name="y"> The distance from the top of the bitmap/bitmap to the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    public static void FillRectangleOnBitmap(Bitmap destination, Color clr, double x, double y, double width, double height)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __sklib__fill_rectangle_on_bitmap__bitmap__color__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Fills a rectangle on the supplied bitmap, using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The destination bitmap</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The distance from the left of the bitmap/bitmap to the rectangle</param>
    /// <param name="y"> The distance from the top of the bitmap/bitmap to the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillRectangleOnBitmap(Bitmap destination, Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_rectangle_on_bitmap__bitmap__color__double__double__double__double__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height, __skparam__opts);
    }
    /// <summary>
    /// Fill a rectangle on the supplied window onto the current window.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> The rectangle to draw</param>
    public static void FillRectangleOnWindow(Window destination, Color clr, Rectangle rect)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__fill_rectangle_on_window__window__color__rectangle_ref(__skparam__destination, __skparam__clr, __skparam__rect);
    }
    /// <summary>
    /// Fills a rectangle on the supplied window using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> The rectangle to draw</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillRectangleOnWindow(Window destination, Color clr, Rectangle rect, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_rectangle __skparam__rect;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_rectangle_on_window__window__color__rectangle_ref__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__rect, __skparam__opts);
    }
    /// <summary>
    /// Fills a rectangle on the supplied window to the current window.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The distance from the left of the window/bitmap to the rectangle</param>
    /// <param name="y"> The distance from the top of the window/bitmap to the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    public static void FillRectangleOnWindow(Window destination, Color clr, double x, double y, double width, double height)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __sklib__fill_rectangle_on_window__window__color__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Fills a rectangle on the supplied window, using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The destination window</param>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The distance from the left of the window/bitmap to the rectangle</param>
    /// <param name="y"> The distance from the top of the window/bitmap to the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillRectangleOnWindow(Window destination, Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_rectangle_on_window__window__color__double__double__double__double__drawing_options_ref(__skparam__destination, __skparam__clr, __skparam__x, __skparam__y, __skparam__width, __skparam__height, __skparam__opts);
    }
    /// <summary>
    /// Return a rectangle that is inset an amount from a given rectangle.
    /// </summary>
    /// <param name="rect"> The rectangle to inset</param>
    /// <param name="insetAmount"> The amount to inset the rectangle</param>
    /// <returns>A new rectangle created inset from `rect`</returns>
    public static Rectangle InsetRectangle(Rectangle rect, float insetAmount)
    {
      __sklib_rectangle __skparam__rect;
      float __skparam__inset_amount;
      __sklib_rectangle __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__inset_amount = __skadapter__to_sklib_float(insetAmount);
      __skreturn = __sklib__inset_rectangle__rectangle_ref__float(__skparam__rect, __skparam__inset_amount);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that represents the intersection of two rectangles.
    /// </summary>
    /// <param name="rect1"> The first rectangle</param>
    /// <param name="rect2"> The second rectangle</param>
    /// <returns>The intersection of rect1 and rect2.</returns>
    public static Rectangle Intersection(Rectangle rect1, Rectangle rect2)
    {
      __sklib_rectangle __skparam__rect1;
      __sklib_rectangle __skparam__rect2;
      __sklib_rectangle __skreturn;
      __skparam__rect1 = __skadapter__to_sklib_rectangle(rect1);
      __skparam__rect2 = __skadapter__to_sklib_rectangle(rect2);
      __skreturn = __sklib__intersection__rectangle_ref__rectangle_ref(__skparam__rect1, __skparam__rect2);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that surrounds a given circle
    /// </summary>
    /// <param name="c"> The circle</param>
    /// <returns>A rectangle that will surround the circle</returns>
    public static Rectangle RectangleAround(Circle c)
    {
      __sklib_circle __skparam__c;
      __sklib_rectangle __skreturn;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skreturn = __sklib__rectangle_around__circle_ref(__skparam__c);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that surrounds a given line segment
    /// </summary>
    /// <param name="l"> The line</param>
    /// <returns>A rectangle that will surround the line</returns>
    public static Rectangle RectangleAround(Line l)
    {
      __sklib_line __skparam__l;
      __sklib_rectangle __skreturn;
      __skparam__l = __skadapter__to_sklib_line(l);
      __skreturn = __sklib__rectangle_around__line_ref(__skparam__l);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that surrounds a given quad.
    /// </summary>
    /// <param name="q"> The quad</param>
    /// <returns>A rectangle that will surround the quad</returns>
    public static Rectangle RectangleAround(Quad q)
    {
      __sklib_quad __skparam__q;
      __sklib_rectangle __skreturn;
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skreturn = __sklib__rectangle_around__quad_ref(__skparam__q);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that surrounds a given triangle
    /// </summary>
    /// <param name="t"> The triangle</param>
    /// <returns>A rectangle that will surround the triangle</returns>
    public static Rectangle RectangleAround(Triangle t)
    {
      __sklib_triangle __skparam__t;
      __sklib_rectangle __skreturn;
      __skparam__t = __skadapter__to_sklib_triangle(t);
      __skreturn = __sklib__rectangle_around__triangle_ref(__skparam__t);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// The location of the bottom of the rectangle.
    /// </summary>
    /// <param name="rect"> The rectangle.</param>
    /// <returns>The distance from the top of the screen to the bottom of the rectangle.</returns>
    public static double RectangleBottom(Rectangle rect)
    {
      __sklib_rectangle __skparam__rect;
      double __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__rectangle_bottom__rectangle_ref(__skparam__rect);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Returns the center point of a given rectangle
    /// </summary>
    /// <param name="rect"> The rectangle</param>
    /// <returns>The center point of the vector</returns>
    public static Point2D RectangleCenter(Rectangle rect)
    {
      __sklib_rectangle __skparam__rect;
      __sklib_point_2d __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__rectangle_center__rectangle_ref(__skparam__rect);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Detects if a rectangle intersects with a circle.
    /// </summary>
    /// <param name="rect"> The rectangle to test</param>
    /// <param name="c"> The circle to test</param>
    /// <returns>True if the rectangle and circle intersect, false otherwise</returns>
    public static bool RectangleCircleIntersect(Rectangle rect, Circle c)
    {
      __sklib_rectangle __skparam__rect;
      __sklib_circle __skparam__c;
      int __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skreturn = __sklib__rectangle_circle_intersect__rectangle_ref__circle_ref(__skparam__rect, __skparam__c);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle at the specified point with a given width and height
    /// </summary>
    /// <param name="pt"> The origin for the rectangle</param>
    /// <param name="width"> Its width</param>
    /// <param name="height"> Its height</param>
    /// <returns>A rectangle with the specified dimensions and location</returns>
    public static Rectangle RectangleFrom(Point2D pt, double width, double height)
    {
      __sklib_point_2d __skparam__pt;
      double __skparam__width;
      double __skparam__height;
      __sklib_rectangle __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skreturn = __sklib__rectangle_from__point_2d__double__double(__skparam__pt, __skparam__width, __skparam__height);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle with pt1 and pt2 defining the two distant edge points.
    /// </summary>
    /// <param name="pt1"> The first point</param>
    /// <param name="pt2"> The second point</param>
    /// <returns>A rectangle enclosing the two points.</returns>
    public static Rectangle RectangleFrom(Point2D pt1, Point2D pt2)
    {
      __sklib_point_2d __skparam__pt1;
      __sklib_point_2d __skparam__pt2;
      __sklib_rectangle __skreturn;
      __skparam__pt1 = __skadapter__to_sklib_point_2d(pt1);
      __skparam__pt2 = __skadapter__to_sklib_point_2d(pt2);
      __skreturn = __sklib__rectangle_from__point_2d__point_2d(__skparam__pt1, __skparam__pt2);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle from a given x,y location with the specified width and height.
    /// </summary>
    /// <param name="x"> The x coordinate of the rectangle</param>
    /// <param name="y"> The y coordinate of the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    /// <returns>A rectangle with the specified dimensions and location.</returns>
    public static Rectangle RectangleFrom(double x, double y, double width, double height)
    {
      double __skparam__x;
      double __skparam__y;
      double __skparam__width;
      double __skparam__height;
      __sklib_rectangle __skreturn;
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__width = __skadapter__to_sklib_double(width);
      __skparam__height = __skadapter__to_sklib_double(height);
      __skreturn = __sklib__rectangle_from__double__double__double__double(__skparam__x, __skparam__y, __skparam__width, __skparam__height);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// The location of the left edge of the rectangle.
    /// </summary>
    /// <param name="rect"> The rectangle.</param>
    /// <returns>The distance from the left of the screen to the left side of the rectangle.</returns>
    public static double RectangleLeft(Rectangle rect)
    {
      __sklib_rectangle __skparam__rect;
      double __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__rectangle_left__rectangle_ref(__skparam__rect);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle that is moved by the provided vector.
    /// </summary>
    /// <param name="rect"> The original rectangle</param>
    /// <param name="offset"> The amount and direction for the rectangle to move</param>
    /// <returns>A new rectangle that represents the original rectangle after being moved by the offset vector.</returns>
    public static Rectangle RectangleOffsetBy(Rectangle rect, Vector2D offset)
    {
      __sklib_rectangle __skparam__rect;
      __sklib_vector_2d __skparam__offset;
      __sklib_rectangle __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__offset = __skadapter__to_sklib_vector_2d(offset);
      __skreturn = __sklib__rectangle_offset_by__rectangle_ref__vector_2d_ref(__skparam__rect, __skparam__offset);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Detects if a ray intersects a rectangle.
    /// </summary>
    /// <param name="origin"> The starting point of the ray</param>
    /// <param name="heading"> The direction of the ray as a vector</param>
    /// <param name="rect"> The rectangle to check for intersection</param>
    /// <returns>True if the ray intersects the rectangle, false otherwise</returns>
    public static bool RectangleRayIntersection(Point2D origin, Vector2D heading, Rectangle rect)
    {
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__rectangle_ray_intersection__point_2d_ref__vector_2d_ref__rectangle_ref(__skparam__origin, __skparam__heading, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Detects if a ray intersects a rectangle. If an intersection is found, the `hit_point` and `hit_distance` are set to the point of intersection and the distance from the ray's origin to the intersection point. If the ray's `origin` is contained within the rectangle, `hit_point` is set to the `origin` and `hit_distance` is set to 0. If no intersection is found, `hit_point` and `hit_distance` are not modified.
    /// </summary>
    /// <param name="origin"> The starting point of the ray</param>
    /// <param name="heading"> The direction of the ray as a vector</param>
    /// <param name="rect"> The rectangle to check for intersection</param>
    /// <param name="hitPoint"> The point to set to where the ray intersects the rectangle</param>
    /// <param name="hitDistance"> The double to set to the distance from the ray's origin to the intersection point</param>
    /// <returns>True if the ray intersects the rectangle, false otherwise</returns>
    public static bool RectangleRayIntersection(Point2D origin, Vector2D heading, Rectangle rect, ref Point2D hitPoint, ref double hitDistance)
    {
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      __sklib_rectangle __skparam__rect;
      __sklib_point_2d __skparam__hit_point;
      double __skparam__hit_distance;
      int __skreturn;
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__hit_point = __skadapter__to_sklib_point_2d(hitPoint);
      __skparam__hit_distance = __skadapter__to_sklib_double(hitDistance);
      __skreturn = __sklib__rectangle_ray_intersection__point_2d_ref__vector_2d_ref__rectangle_ref__point_2d_ref__double_ref(__skparam__origin, __skparam__heading, __skparam__rect, ref __skparam__hit_point, ref __skparam__hit_distance);
      hitPoint = __skadapter__to_point_2d(__skparam__hit_point);
      hitDistance = __skadapter__to_double(__skparam__hit_distance);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// The location of the right edge of the rectangle.
    /// </summary>
    /// <param name="rect"> The rectangle.</param>
    /// <returns>The distance from the left of the screen to the right side of the rectangle.</returns>
    public static double RectangleRight(Rectangle rect)
    {
      __sklib_rectangle __skparam__rect;
      double __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__rectangle_right__rectangle_ref(__skparam__rect);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Get a text representation of the passed in rectangle.
    /// </summary>
    /// <param name="rect"> The rectangle</param>
    /// <returns>A string representation of the rectangle.</returns>
    public static string RectangleToString(Rectangle rect)
    {
      __sklib_rectangle __skparam__rect;
      __sklib_string __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__rectangle_to_string__rectangle_ref(__skparam__rect);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// The top of the rectangle.
    /// </summary>
    /// <param name="rect"> The rectangle.</param>
    /// <returns>Its distance from the top of the screen.</returns>
    public static double RectangleTop(Rectangle rect)
    {
      __sklib_rectangle __skparam__rect;
      double __skreturn;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__rectangle_top__rectangle_ref(__skparam__rect);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Returns true if the two rectangles intersect.
    /// </summary>
    /// <param name="rect1"> The first rectangle</param>
    /// <param name="rect2"> The second rectangle</param>
    /// <returns>True when rect1 and rect2 intersect.</returns>
    public static bool RectanglesIntersect(Rectangle rect1, Rectangle rect2)
    {
      __sklib_rectangle __skparam__rect1;
      __sklib_rectangle __skparam__rect2;
      int __skreturn;
      __skparam__rect1 = __skadapter__to_sklib_rectangle(rect1);
      __skparam__rect2 = __skadapter__to_sklib_rectangle(rect2);
      __skreturn = __sklib__rectangles_intersect__rectangle_ref__rectangle_ref(__skparam__rect1, __skparam__rect2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Remove the function from the list of functions receiving notification of resource freeing.
    /// </summary>
    /// <param name="handler"> The function to remove</param>
    public static void DeregisterFreeNotifier(FreeNotifier handler)
    {
      FreeNotifier __skparam__handler;
      __skparam__handler = __skadapter__to_sklib_free_notifier(handler);
      __sklib__deregister_free_notifier__free_notifier_ptr(__skparam__handler);
    }
    /// <summary>
    /// Gets the path to a give file of a certain resource kind.
    /// </summary>
    /// <param name="filename"> The name of the file of the resource kind.</param>
    /// <param name="kind"> The kind of resource you are loading.</param>
    /// <returns>The full path to the resource.</returns>
    public static string PathToResource(string filename, ResourceKind kind)
    {
      __sklib_string __skparam__filename;
      int __skparam__kind;
      __sklib_string __skreturn;
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __skparam__kind = __skadapter__to_sklib_resource_kind(kind);
      __skreturn = __sklib__path_to_resource__string_ref__resource_kind(__skparam__filename, __skparam__kind);
    __skadapter__free__sklib_string(ref __skparam__filename);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns the path to the resources folder for the SplashKit program. This will be auto detected at startup, but can be changed using `set_resources_path`.
    /// </summary>
    /// <returns>Path to SplashKit Resources folder.</returns>
    public static string PathToResources()
    {
      __sklib_string __skreturn;
      __skreturn = __sklib__path_to_resources();
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns the path to the folder containing a given resource kind. This is the path SplashkKit will search when you load a resource.
    /// </summary>
    /// <param name="kind"> The type of resource you want the path for.</param>
    /// <returns>The path to the folder containing this kind of resource.</returns>
    public static string PathToResources(ResourceKind kind)
    {
      int __skparam__kind;
      __sklib_string __skreturn;
      __skparam__kind = __skadapter__to_sklib_resource_kind(kind);
      __skreturn = __sklib__path_to_resources__resource_kind(__skparam__kind);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Register a function to be called when any resource is freed.
    /// </summary>
    /// <param name="fn"> The function to be called when a resource is freed.</param>
    public static void RegisterFreeNotifier(FreeNotifier fn)
    {
      FreeNotifier __skparam__fn;
      __skparam__fn = __skadapter__to_sklib_free_notifier(fn);
      __sklib__register_free_notifier__free_notifier_ptr(__skparam__fn);
    }
    /// <summary>
    /// Sets the path to the SplashKit resources folder. Resource paths are then located within this folder.
    /// </summary>
    /// <param name="path"> The file path to the SplashKit Resources folder.</param>
    public static void SetResourcesPath(string path)
    {
      __sklib_string __skparam__path;
      __skparam__path = __skadapter__to_sklib_string(path);
      __sklib__set_resources_path__string_ref(__skparam__path);
    __skadapter__free__sklib_string(ref __skparam__path);
    }
    /// <summary>
    /// Fades out all `sound_effect`s over the specified milliseconds.
    /// </summary>
    /// <param name="ms"> The number of milliseconds to fade out all sound effects.</param>
    public static void FadeAllSoundEffectsOut(int ms)
    {
      int __skparam__ms;
      __skparam__ms = __skadapter__to_sklib_int(ms);
      __sklib__fade_all_sound_effects_out__int(__skparam__ms);
    }
    /// <summary>
    /// Fades out the `sound_effect` over the specified milliseconds.
    /// </summary>
    /// <param name="effect"> The `sound_effect` to fade out.</param>
    /// <param name="ms"> The number of milliseconds to fade out the `sound_effect`.</param>
    public static void FadeSoundEffectOut(SoundEffect effect, int ms)
    {
      __sklib_ptr __skparam__effect;
      int __skparam__ms;
      __skparam__effect = __skadapter__to_sklib_sound_effect(effect);
      __skparam__ms = __skadapter__to_sklib_int(ms);
      __sklib__fade_sound_effect_out__sound_effect__int(__skparam__effect, __skparam__ms);
    }
    /// <summary>
    /// Releases all of the sound effects that have been loaded.
    /// </summary>
    public static void FreeAllSoundEffects()
    {
      __sklib__free_all_sound_effects();
    }
    /// <summary>
    /// Releases the SplashKit resources associated with the sound effect.
    /// </summary>
    /// <param name="effect"> The `sound_effect` whose resources should be released.</param>
    public static void FreeSoundEffect(SoundEffect effect)
    {
      __sklib_ptr __skparam__effect;
      __skparam__effect = __skadapter__to_sklib_sound_effect(effect);
      __sklib__free_sound_effect__sound_effect(__skparam__effect);
    }
    /// <summary>
    /// Determines if SplashKit has a sound effect loaded for the supplied name. This checks against all sounds loaded, those loaded without a name are assigned the filename as a default. If this returns `false`, you may want to use `load_sound_effect` to load in a specific sound effect and give it the desired name.
    /// </summary>
    /// <param name="name"> The name to check if a sound effect is loaded.</param>
    /// <returns>Returns `true` if there is a sound effect with the given `name` has has been loaded.</returns>
    public static bool HasSoundEffect(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_sound_effect__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// The supplied `filename` is used to locate the sound effect to load. The supplied `name` indicates the name to use to refer to this `sound_effect`. The `sound_effect` can then be retrieved by passing this `name` to the `sound_effect_named` function.
    /// </summary>
    /// <param name="name"> The name used to refer to the sound effect.</param>
    /// <param name="filename"> The filename used to locate the sound effect to use.</param>
    /// <returns>A new `sound_effect` with the initialised values provided.</returns>
    public static SoundEffect LoadSoundEffect(string name, string filename)
    {
      __sklib_string __skparam__name;
      __sklib_string __skparam__filename;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __skreturn = __sklib__load_sound_effect__string_ref__string_ref(__skparam__name, __skparam__filename);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__filename);
      return __skadapter__to_sound_effect(__skreturn);
    }
    /// <summary>
    /// Plays a sound effect once at full volume.
    /// </summary>
    /// <param name="name"> The name of the effect to play.</param>
    public static void PlaySoundEffect(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__play_sound_effect__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Plays a sound effect once at full volume.
    /// </summary>
    /// <param name="name"> The name of the effect to play.</param>
    /// <param name="volume"> The volume to play the `sound_effect`</param>
    public static void PlaySoundEffect(string name, double volume)
    {
      __sklib_string __skparam__name;
      double __skparam__volume;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__volume = __skadapter__to_sklib_double(volume);
      __sklib__play_sound_effect__string_ref__double(__skparam__name, __skparam__volume);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Plays a sound effect for a specified number of times at full volume.
    /// </summary>
    /// <param name="name"> The name of the effect to play.</param>
    /// <param name="times"> Controls the number of times the sound effect is played.</param>
    public static void PlaySoundEffect(string name, int times)
    {
      __sklib_string __skparam__name;
      int __skparam__times;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__times = __skadapter__to_sklib_int(times);
      __sklib__play_sound_effect__string_ref__int(__skparam__name, __skparam__times);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Plays a sound effect for a specified number of times and playback volume.
    /// </summary>
    /// <param name="name"> The name of the effect to play.</param>
    /// <param name="times"> Controls the number of times the sound effect is played.</param>
    /// <param name="volume"> Indicates the percentage of the original volume to play the `sound_effect` at. This must be between `0` and `1`.</param>
    public static void PlaySoundEffect(string name, int times, double volume)
    {
      __sklib_string __skparam__name;
      int __skparam__times;
      double __skparam__volume;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__times = __skadapter__to_sklib_int(times);
      __skparam__volume = __skadapter__to_sklib_double(volume);
      __sklib__play_sound_effect__string_ref__int__double(__skparam__name, __skparam__times, __skparam__volume);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Plays a sound effect once at full volume.
    /// </summary>
    /// <param name="effect"> The effect indicates which sound effect to start playing.</param>
    public static void PlaySoundEffect(SoundEffect effect)
    {
      __sklib_ptr __skparam__effect;
      __skparam__effect = __skadapter__to_sklib_sound_effect(effect);
      __sklib__play_sound_effect__sound_effect(__skparam__effect);
    }
    /// <summary>
    /// Plays a sound effect once at playback volume.
    /// </summary>
    /// <param name="effect"> The effect indicates which sound effect to start playing.</param>
    /// <param name="volume"> Indicates the percentage of the original volume to play the `sound_effect` at. This must be between `0` and `1`.</param>
    public static void PlaySoundEffect(SoundEffect effect, double volume)
    {
      __sklib_ptr __skparam__effect;
      double __skparam__volume;
      __skparam__effect = __skadapter__to_sklib_sound_effect(effect);
      __skparam__volume = __skadapter__to_sklib_double(volume);
      __sklib__play_sound_effect__sound_effect__double(__skparam__effect, __skparam__volume);
    }
    /// <summary>
    /// Plays a sound effect once at full volume.
    /// </summary>
    /// <param name="effect"> The effect indicates which sound effect to start playing.</param>
    /// <param name="times"> Controls the number of times the sound effect is played.</param>
    public static void PlaySoundEffect(SoundEffect effect, int times)
    {
      __sklib_ptr __skparam__effect;
      int __skparam__times;
      __skparam__effect = __skadapter__to_sklib_sound_effect(effect);
      __skparam__times = __skadapter__to_sklib_int(times);
      __sklib__play_sound_effect__sound_effect__int(__skparam__effect, __skparam__times);
    }
    /// <summary>
    /// This version of `play_sound_effect` allows you to control both the number of times the `sound_effect` is repeated and its playback volume.
    /// </summary>
    /// <param name="effect"> The effect indicates which sound effect to start playing.</param>
    /// <param name="times"> Controls the number of times the sound effect is played.</param>
    /// <param name="volume"> Indicates the percentage of the original volume to play the `sound_effect` at. This must be between `0` and `1`.</param>
    public static void PlaySoundEffect(SoundEffect effect, int times, double volume)
    {
      __sklib_ptr __skparam__effect;
      int __skparam__times;
      double __skparam__volume;
      __skparam__effect = __skadapter__to_sklib_sound_effect(effect);
      __skparam__times = __skadapter__to_sklib_int(times);
      __skparam__volume = __skadapter__to_sklib_double(volume);
      __sklib__play_sound_effect__sound_effect__int__double(__skparam__effect, __skparam__times, __skparam__volume);
    }
    /// <summary>
    /// Returns the filename of the `sound_effect` that has been loaded by SplashKit
    /// </summary>
    /// <param name="effect"> The `sound_effect` to check</param>
    /// <returns>Returns the filename of the `sound_effect` that has been loaded</returns>
    public static string SoundEffectFilename(SoundEffect effect)
    {
      __sklib_ptr __skparam__effect;
      __sklib_string __skreturn;
      __skparam__effect = __skadapter__to_sklib_sound_effect(effect);
      __skreturn = __sklib__sound_effect_filename__sound_effect(__skparam__effect);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns the name of the `sound_effect` that has been loaded by SplashKit
    /// </summary>
    /// <param name="effect"> The `sound_effect` to check</param>
    /// <returns>Returns the name of the `sound_effect` that has been loaded</returns>
    public static string SoundEffectName(SoundEffect effect)
    {
      __sklib_ptr __skparam__effect;
      __sklib_string __skreturn;
      __skparam__effect = __skadapter__to_sklib_sound_effect(effect);
      __skreturn = __sklib__sound_effect_name__sound_effect(__skparam__effect);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Retrieves a `sound_effect` that has been loaded into SplashKit. If the sound effect has not been loaded, this will attempt to use the name to locate the file for you. If a file can be found, the sound effect is loaded and returned.
    /// </summary>
    /// <param name="name"> The name of the sound effect to return.</param>
    /// <returns>Returns the `sound_effect` that has been loaded with the specified `name` using `load_sound_effect`.</returns>
    public static SoundEffect SoundEffectNamed(string name)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sound_effect_named__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_sound_effect(__skreturn);
    }
    /// <summary>
    /// Checks whether the `sound_effect` that matches the name is currently playing
    /// </summary>
    /// <param name="name"> The name of the `sound_effect`</param>
    /// <returns>Returns whether the "sound_effect" that matches the name is currently playing or not</returns>
    public static bool SoundEffectPlaying(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sound_effect_playing__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks whether the `sound_effect` is currently playing
    /// </summary>
    /// <param name="effect"> The `sound_effect` to be tested.</param>
    /// <returns>Returns whether the "sound_effect" is currently playing or not</returns>
    public static bool SoundEffectPlaying(SoundEffect effect)
    {
      __sklib_ptr __skparam__effect;
      int __skreturn;
      __skparam__effect = __skadapter__to_sklib_sound_effect(effect);
      __skreturn = __sklib__sound_effect_playing__sound_effect(__skparam__effect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Lets you test if a sound effect is valid. This will return true when it is a valid sound effect.
    /// </summary>
    /// <param name="effect"> the effect to test</param>
    /// <returns>true when the sound effect is valid.</returns>
    public static bool SoundEffectValid(SoundEffect effect)
    {
      __sklib_ptr __skparam__effect;
      int __skreturn;
      __skparam__effect = __skadapter__to_sklib_sound_effect(effect);
      __skreturn = __sklib__sound_effect_valid__sound_effect(__skparam__effect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Stops the `sound_effect` that matches the name, if it is currently playing.
    /// </summary>
    /// <param name="name"> The name of the `sound_effect` to stop.</param>
    public static void StopSoundEffect(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__stop_sound_effect__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Stops the `sound_effect` if it is currently playing
    /// </summary>
    /// <param name="effect"> The `sound_effect` to stop.</param>
    public static void StopSoundEffect(SoundEffect effect)
    {
      __sklib_ptr __skparam__effect;
      __skparam__effect = __skadapter__to_sklib_sound_effect(effect);
      __sklib__stop_sound_effect__sound_effect(__skparam__effect);
    }
    /// <summary>
    /// Call the supplied function for all sprites in the current pack.
    /// </summary>
    /// <param name="fn"> The sprite function to call on all sprites.</param>
    /// <param name="val"> The value passed to the function for each sprite.</param>
    public static void CallForAllSprites(SpriteFloatFunction fn, float val)
    {
      SpriteFloatFunction __skparam__fn;
      float __skparam__val;
      __skparam__fn = __skadapter__to_sklib_sprite_float_function(fn);
      __skparam__val = __skadapter__to_sklib_float(val);
      __sklib__call_for_all_sprites__sprite_float_function_ptr__float(__skparam__fn, __skparam__val);
    }
    /// <summary>
    /// Call the supplied function for all sprites in the current pack.
    /// </summary>
    /// <param name="fn"> The sprite function to call on all sprites.</param>
    public static void CallForAllSprites(SpriteFunction fn)
    {
      SpriteFunction __skparam__fn;
      __skparam__fn = __skadapter__to_sklib_sprite_function(fn);
      __sklib__call_for_all_sprites__sprite_function_ptr(__skparam__fn);
    }
    /// <summary>
    /// Register a procedure to be called when an events occur on any sprite.
    /// </summary>
    /// <param name="handler"> The function to call when any sprite raises an event</param>
    public static void CallOnSpriteEvent(SpriteEventHandler handler)
    {
      SpriteEventHandler __skparam__handler;
      __skparam__handler = __skadapter__to_sklib_sprite_event_handler(handler);
      __sklib__call_on_sprite_event__sprite_event_handler_ptr(__skparam__handler);
    }
    /// <summary>
    /// Creates a sprite for the passed in bitmap image. The sprite will use the cell information within the bitmap if it is animated at a later stage.  This version of create_sprite will initialise the sprite to use pixel level collisions, no animations, and have one layer named 'layer1'. This version of the constructor will assign a default name to the sprite for resource management purposes.
    /// </summary>
    /// <param name="layer"> The bitmap for the sprite's image.</param>
    /// <returns>The new sprite with image.</returns>
    public static Sprite CreateSprite(Bitmap layer)
    {
      __sklib_ptr __skparam__layer;
      __sklib_ptr __skreturn;
      __skparam__layer = __skadapter__to_sklib_bitmap(layer);
      __skreturn = __sklib__create_sprite__bitmap(__skparam__layer);
      return __skadapter__to_sprite(__skreturn);
    }
    /// <summary>
    /// Creates a sprite for the passed in bitmap image. The sprite will use the cell information within the bitmap if it is animated at a later stage. This version of `create_sprite` will initialise the sprite to use pixel level collisions, the specified animation template, the layer have name 'layer1'.  This version of the constructor will assign a default name to the sprite for resource management purposes.
    /// </summary>
    /// <param name="layer"> The bitmap for the sprite's image.</param>
    /// <param name="ani"> The animation script for the sprite's animations.</param>
    /// <returns>The new sprite with image and animation script.</returns>
    public static Sprite CreateSprite(Bitmap layer, AnimationScript ani)
    {
      __sklib_ptr __skparam__layer;
      __sklib_ptr __skparam__ani;
      __sklib_ptr __skreturn;
      __skparam__layer = __skadapter__to_sklib_bitmap(layer);
      __skparam__ani = __skadapter__to_sklib_animation_script(ani);
      __skreturn = __sklib__create_sprite__bitmap__animation_script(__skparam__layer, __skparam__ani);
      return __skadapter__to_sprite(__skreturn);
    }
    /// <summary>
    /// Creates a sprite for the passed in bitmap image. The sprite will use the cell information within the bitmap if it is animated at a later stage.  This version of create_sprite will initialise the sprite to use pixel level collisions, no animations, and have one layer named 'layer1'. This version of the constructor will assign a default name to the sprite for resource management purposes.
    /// </summary>
    /// <param name="bitmapName"> The name of the bitmap to use as the sprite's layer</param>
    /// <returns>The new sprite with image.</returns>
    public static Sprite CreateSprite(string bitmapName)
    {
      __sklib_string __skparam__bitmap_name;
      __sklib_ptr __skreturn;
      __skparam__bitmap_name = __skadapter__to_sklib_string(bitmapName);
      __skreturn = __sklib__create_sprite__string_ref(__skparam__bitmap_name);
    __skadapter__free__sklib_string(ref __skparam__bitmap_name);
      return __skadapter__to_sprite(__skreturn);
    }
    /// <summary>
    /// Creates a sprite for the passed in bitmap image. The sprite will use the cell information within the sprite if it is animated at a later stage. This version of create_sprite will initialise the sprite to use pixel level collisions, no animation, the layer have name 'layer1'.
    /// </summary>
    /// <param name="name"> The name of the sprite for resource management.</param>
    /// <param name="layer"> The bitmap for the sprite's image.</param>
    /// <returns>The new sprite with image and name.</returns>
    public static Sprite CreateSprite(string name, Bitmap layer)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skparam__layer;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__layer = __skadapter__to_sklib_bitmap(layer);
      __skreturn = __sklib__create_sprite__string_ref__bitmap(__skparam__name, __skparam__layer);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_sprite(__skreturn);
    }
    /// <summary>
    /// Creates a sprite for the passed in bitmap image. The sprite will use the cell information within the sprite if it is animated at a later stage. This version of create_sprite will initialise the sprite to use pixel level collisions, the specified animation template, the layer have name 'layer1'.
    /// </summary>
    /// <param name="name"> The name of the sprite for resource management.</param>
    /// <param name="layer"> The bitmap for the sprite's image.</param>
    /// <param name="ani"> The animation script for the sprite's animations.</param>
    /// <returns>The new sprite with image, animation, and name.</returns>
    public static Sprite CreateSprite(string name, Bitmap layer, AnimationScript ani)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skparam__layer;
      __sklib_ptr __skparam__ani;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__layer = __skadapter__to_sklib_bitmap(layer);
      __skparam__ani = __skadapter__to_sklib_animation_script(ani);
      __skreturn = __sklib__create_sprite__string_ref__bitmap__animation_script(__skparam__name, __skparam__layer, __skparam__ani);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_sprite(__skreturn);
    }
    /// <summary>
    /// Creates a sprite. The bitmap_name is used to indicate the bitmap the sprite will use, and the animation_name is used to indicate which animation_script to use.
    /// </summary>
    /// <param name="bitmapName"> The name of the bitmap to use as the sprite's image.</param>
    /// <param name="animationName"> The name of the animation script to use for this sprite.</param>
    /// <returns>The new sprite with the image and animation.</returns>
    public static Sprite CreateSprite(string bitmapName, string animationName)
    {
      __sklib_string __skparam__bitmap_name;
      __sklib_string __skparam__animation_name;
      __sklib_ptr __skreturn;
      __skparam__bitmap_name = __skadapter__to_sklib_string(bitmapName);
      __skparam__animation_name = __skadapter__to_sklib_string(animationName);
      __skreturn = __sklib__create_sprite__string_ref__string_ref(__skparam__bitmap_name, __skparam__animation_name);
    __skadapter__free__sklib_string(ref __skparam__bitmap_name);
    __skadapter__free__sklib_string(ref __skparam__animation_name);
      return __skadapter__to_sprite(__skreturn);
    }
    /// <summary>
    /// Create a new sprite_pack with a given name. This pack can then be selected and used to control which sprites are drawn/updated in the calls to draw_all_sprites and update_all_sprites.
    /// </summary>
    /// <param name="name"> The name of the new sprite pack.</param>
    public static void CreateSpritePack(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__create_sprite_pack__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Returns the name of the currently selected sprite_pack.
    /// </summary>
    /// <returns>The name of the current sprite pack.</returns>
    public static string CurrentSpritePack()
    {
      __sklib_string __skreturn;
      __skreturn = __sklib__current_sprite_pack();
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// draws all of the sprites in the current sprite pack. Packs can be switched to select between different sets of sprites.
    /// </summary>
    public static void DrawAllSprites()
    {
      __sklib__draw_all_sprites();
    }
    /// <summary>
    /// Draws the sprite at its position in the game offset by a given amount. Only use this method when you want to draw the sprite displaced from its location in your game. Otherwise you should change the sprite's location and then use the standard ''draw_sprite'' routine.
    /// </summary>
    /// <param name="s"> The sprite to draw.</param>
    /// <param name="offset"> The amount to offset the sprite.</param>
    public static void DrawSprite(Sprite s, Vector2D offset)
    {
      __sklib_ptr __skparam__s;
      __sklib_vector_2d __skparam__offset;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__offset = __skadapter__to_sklib_vector_2d(offset);
      __sklib__draw_sprite__sprite__vector_2d_ref(__skparam__s, __skparam__offset);
    }
    /// <summary>
    /// Draws the sprite at its location in the world. This is affected by the position of the camera and the sprites current location.  This is the standard routine for drawing sprites to the screen and should be used in most cases.
    /// </summary>
    /// <param name="s"> The sprite to draw.</param>
    public static void DrawSprite(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __sklib__draw_sprite__sprite(__skparam__s);
    }
    /// <summary>
    /// Draws the sprite at its position in the game offset by a given amount. Only use this method when you want to draw the sprite displaced from its location in your game. Otherwise you should change the sprite's location and then use the standard `draw_sprite` routine.
    /// </summary>
    /// <param name="s"> The sprite to draw.</param>
    /// <param name="xOffset"> The amount to offset on the x axis.</param>
    /// <param name="yOffset"> The amount to offset on the y axis.</param>
    public static void DrawSprite(Sprite s, double xOffset, double yOffset)
    {
      __sklib_ptr __skparam__s;
      double __skparam__x_offset;
      double __skparam__y_offset;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__x_offset = __skadapter__to_sklib_double(xOffset);
      __skparam__y_offset = __skadapter__to_sklib_double(yOffset);
      __sklib__draw_sprite__sprite__double__double(__skparam__s, __skparam__x_offset, __skparam__y_offset);
    }
    /// <summary>
    /// Releases all of the sprites that have been loaded.
    /// </summary>
    public static void FreeAllSprites()
    {
      __sklib__free_all_sprites();
    }
    /// <summary>
    /// Free the resources associated with a sprite.
    /// </summary>
    /// <param name="s"> The sprite to be destroyed.</param>
    public static void FreeSprite(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __sklib__free_sprite__sprite(__skparam__s);
    }
    /// <summary>
    /// Frees the sprite pack and all of its sprites.
    /// </summary>
    /// <param name="name"> The name of the sprite pack to destroy.</param>
    public static void FreeSpritePack(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__free_sprite_pack__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Determines if SplashKit has a sprite for the supplied name. This checks against all sprites, those loaded without a name are assigned a default.
    /// </summary>
    /// <param name="name"> The name of the sprite to locate.</param>
    /// <returns>True if you have created a sprite with this name.</returns>
    public static bool HasSprite(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_sprite__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Indicates if a given sprite_pack has already been created.
    /// </summary>
    /// <param name="name"> The name for the sprite pack.</param>
    /// <returns>True if a sprite pack exists with the indicated name.</returns>
    public static bool HasSpritePack(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_sprite_pack__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// moves the sprite as indicated by its velocity. You can call this directly ot alternatively, this action is performed when the sprite is updated using the ''update_sprite'' routine.
    /// </summary>
    /// <param name="s"> The sprite to move.</param>
    public static void MoveSprite(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __sklib__move_sprite__sprite(__skparam__s);
    }
    /// <summary>
    /// Moves the sprite a given distance based on the value passed in rather than based on the sprite's velocity. Typically this method is used to apply other movement actions to the sprite and the velocity of the sprite is used the intended movement of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to move.</param>
    /// <param name="distance"> The vector that represents the direction and distance to move the sprite.</param>
    public static void MoveSprite(Sprite s, Vector2D distance)
    {
      __sklib_ptr __skparam__s;
      __sklib_vector_2d __skparam__distance;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__distance = __skadapter__to_sklib_vector_2d(distance);
      __sklib__move_sprite__sprite__vector_2d_ref(__skparam__s, __skparam__distance);
    }
    /// <summary>
    /// Moves the sprite a percentage of a given distance based on the value passed in rather than based on the sprite's velocity. Typically this method is used to apply other movement actions to the sprite and the velocity of the sprite is used the intended movement of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to move.</param>
    /// <param name="distance"> The vector that represents the direction and distance to move the sprite.</param>
    /// <param name="pct"> The percentage of the distance to move the sprite.</param>
    public static void MoveSprite(Sprite s, Vector2D distance, float pct)
    {
      __sklib_ptr __skparam__s;
      __sklib_vector_2d __skparam__distance;
      float __skparam__pct;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__distance = __skadapter__to_sklib_vector_2d(distance);
      __skparam__pct = __skadapter__to_sklib_float(pct);
      __sklib__move_sprite__sprite__vector_2d_ref__float(__skparam__s, __skparam__distance, __skparam__pct);
    }
    /// <summary>
    /// Moves the sprite as indicated by a percentage of its velocity. You can call this directly ot alternatively, this action is performed when the sprite is updated using the ''update_sprite'' routines that require a percentage.
    /// </summary>
    /// <param name="s"> The sprite to move.</param>
    /// <param name="pct"> The percentage of the sprite's velocity to move.</param>
    public static void MoveSprite(Sprite s, float pct)
    {
      __sklib_ptr __skparam__s;
      float __skparam__pct;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__pct = __skadapter__to_sklib_float(pct);
      __sklib__move_sprite__sprite__float(__skparam__s, __skparam__pct);
    }
    /// <summary>
    /// This method moves a sprite to a given position in the game.
    /// </summary>
    /// <param name="s"> The sprite to move.</param>
    /// <param name="x"> The sprite's new x location.</param>
    /// <param name="y"> The sprite's new y location.</param>
    public static void MoveSpriteTo(Sprite s, double x, double y)
    {
      __sklib_ptr __skparam__s;
      double __skparam__x;
      double __skparam__y;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__move_sprite_to__sprite__double__double(__skparam__s, __skparam__x, __skparam__y);
    }
    /// <summary>
    /// Selects the named sprite_pack (if it has been created). The selected sprite_pack determines which sprites are drawn and updated with the draw_all_sprites and update_all_sprites code.
    /// </summary>
    /// <param name="name"> The name of the sprite pack to select.</param>
    public static void SelectSpritePack(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__select_sprite_pack__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Adds a new layer to the sprite.
    /// </summary>
    /// <param name="s"> The sprite to add the layer to.</param>
    /// <param name="newLayer"> The new layer's bitmap.</param>
    /// <param name="layerName"> The name of the new layer.</param>
    /// <returns>The index of the new layer.</returns>
    public static int SpriteAddLayer(Sprite s, Bitmap newLayer, string layerName)
    {
      __sklib_ptr __skparam__s;
      __sklib_ptr __skparam__new_layer;
      __sklib_string __skparam__layer_name;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__new_layer = __skadapter__to_sklib_bitmap(newLayer);
      __skparam__layer_name = __skadapter__to_sklib_string(layerName);
      __skreturn = __sklib__sprite_add_layer__sprite__bitmap__string_ref(__skparam__s, __skparam__new_layer, __skparam__layer_name);
    __skadapter__free__sklib_string(ref __skparam__layer_name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Alters the current velocity of the sprite, adding the passed in vector_2d to the current velocity. When the sprite is updated (see `update_sprite`) this vector_2d is used to move the sprite.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The amount to add to the sprite's velocity.</param>
    public static void SpriteAddToVelocity(Sprite s, Vector2D value)
    {
      __sklib_ptr __skparam__s;
      __sklib_vector_2d __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_vector_2d(value);
      __sklib__sprite_add_to_velocity__sprite__vector_2d_ref(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Adds a new kind of value to the sprite
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="name"> The name of the new value to store in the sprite.</param>
    public static void SpriteAddValue(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__sprite_add_value__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Adds a new kind of value to the sprite, setting the initial value to the value passed in.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="name"> The name of the new value to store in the sprite.</param>
    /// <param name="initVal"> The initial value.</param>
    public static void SpriteAddValue(Sprite s, string name, float initVal)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      float __skparam__init_val;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__init_val = __skadapter__to_sklib_float(initVal);
      __sklib__sprite_add_value__sprite__string_ref__float(__skparam__s, __skparam__name, __skparam__init_val);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Returns the anchor point of the sprite. This is the point around which the sprite rotates. This is in sprite coordinates, so as if the sprite is drawn at 0,0.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The anchor point of the sprite.</returns>
    public static Point2D SpriteAnchorPoint(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_point_2d __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_anchor_point__sprite(__skparam__s);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// The sprite anchor position, is the location of the anchor point in world coordinates, based upon the position of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to find where the anchor is in world coordinates</param>
    /// <returns>The location of the sprite's anchor point positioned at the sprite's location</returns>
    public static Point2D SpriteAnchorPosition(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_point_2d __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_anchor_position__sprite(__skparam__s);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Indicates if the sprites animation has ended.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>True if the sprite animation has ended.</returns>
    public static bool SpriteAnimationHasEnded(Sprite s)
    {
      __sklib_ptr __skparam__s;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_animation_has_ended__sprite(__skparam__s);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the name of the sprite's current animation.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The name of the current animation.</returns>
    public static string SpriteAnimationName(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_animation_name__sprite(__skparam__s);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Determines if a sprite is at a given point.
    /// </summary>
    /// <param name="s"> The sprite to test</param>
    /// <param name="pt"> The point to check (in world coordinates)</param>
    /// <returns>True if the sprite is at the given point</returns>
    public static bool SpriteAt(Sprite s, Point2D pt)
    {
      __sklib_ptr __skparam__s;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__sprite_at__sprite__point_2d_ref(__skparam__s, __skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Sends the layer specified forward in the visible layer order.
    /// </summary>
    /// <param name="s"> The sprite to change</param>
    /// <param name="visibleLayer"> The visible layer to bring forward</param>
    public static void SpriteBringLayerForward(Sprite s, int visibleLayer)
    {
      __sklib_ptr __skparam__s;
      int __skparam__visible_layer;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__visible_layer = __skadapter__to_sklib_int(visibleLayer);
      __sklib__sprite_bring_layer_forward__sprite__int(__skparam__s, __skparam__visible_layer);
    }
    /// <summary>
    /// Sends the layer specified to the front in the visible layer order.
    /// </summary>
    /// <param name="s"> The sprite to change</param>
    /// <param name="visibleLayer"> The visible layer to bring to the front</param>
    public static void SpriteBringLayerToFront(Sprite s, int visibleLayer)
    {
      __sklib_ptr __skparam__s;
      int __skparam__visible_layer;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__visible_layer = __skadapter__to_sklib_int(visibleLayer);
      __sklib__sprite_bring_layer_to_front__sprite__int(__skparam__s, __skparam__visible_layer);
    }
    /// <summary>
    /// Register a procedure to call when events occur on the sprite.
    /// </summary>
    /// <param name="s"> The sprite to add the handler to.</param>
    /// <param name="handler"> The function to call when this sprite raises an event.</param>
    public static void SpriteCallOnEvent(Sprite s, SpriteEventHandler handler)
    {
      __sklib_ptr __skparam__s;
      SpriteEventHandler __skparam__handler;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__handler = __skadapter__to_sklib_sprite_event_handler(handler);
      __sklib__sprite_call_on_event__sprite__sprite_event_handler_ptr(__skparam__s, __skparam__handler);
    }
    /// <summary>
    /// Returns the center point of the passed in sprite. This is based on the sprite's Position, Width and Height.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The center point of the sprite</returns>
    public static Point2D SpriteCenterPoint(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_point_2d __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_center_point__sprite(__skparam__s);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Gets a circle in the bounds of the base layer of the indicated sprite.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>A bounding circle that surrounds the sprite</returns>
    public static Circle SpriteCircle(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_circle __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_circle__sprite(__skparam__s);
      return __skadapter__to_circle(__skreturn);
    }
    /// <summary>
    /// Returns the bitmap used by the sprite to determine if it has collided with other objects in the game.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The bitmap used for collisions with this sprite.</returns>
    public static Bitmap SpriteCollisionBitmap(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_ptr __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_collision_bitmap__sprite(__skparam__s);
      return __skadapter__to_bitmap(__skreturn);
    }
    /// <summary>
    /// Gets a circle in the bounds of the indicated sprite's collision rectangle.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>A bounding circle that surrounds the sprite</returns>
    public static Circle SpriteCollisionCircle(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_circle __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_collision_circle__sprite(__skparam__s);
      return __skadapter__to_circle(__skreturn);
    }
    /// <summary>
    /// Returns the kind of collision used with this sprite. This is used when determining if the sprite has collided with other objects in the game.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The kind of collisions performed with this sprite.</returns>
    public static CollisionTestKind SpriteCollisionKind(Sprite s)
    {
      __sklib_ptr __skparam__s;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_collision_kind__sprite(__skparam__s);
      return __skadapter__to_collision_test_kind(__skreturn);
    }
    /// <summary>
    /// Returns the collision rectangle for the specified sprite.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>A collision rectangle that surrounds the sprite.</returns>
    public static Rectangle SpriteCollisionRectangle(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_rectangle __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_collision_rectangle__sprite(__skparam__s);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns the current animation cell for an animated sprite. The cell is updated when the sprite's animation data is updated.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The current cell animation of the sprite.</returns>
    public static int SpriteCurrentCell(Sprite s)
    {
      __sklib_ptr __skparam__s;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_current_cell__sprite(__skparam__s);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns a rectangle of the current cell within the sprite's image. This is used to determine what part of the bitmap should be used when the sprite is drawn.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The current cell rectangle of the sprite.</returns>
    public static Rectangle SpriteCurrentCellRectangle(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_rectangle __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_current_cell_rectangle__sprite(__skparam__s);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Returns the X value of the sprite's velocity.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The x component of the sprite's velocity.</returns>
    public static double SpriteDx(Sprite s)
    {
      __sklib_ptr __skparam__s;
      double __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_dx__sprite(__skparam__s);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Returns the Y value of the sprite's velocity.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The y component of the sprite's velocity.</returns>
    public static double SpriteDy(Sprite s)
    {
      __sklib_ptr __skparam__s;
      double __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_dy__sprite(__skparam__s);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Indicates if the sprite has a value with the given name.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="name"> The name of the value to check.</param>
    /// <returns>True if the sprite has a value with that name.</returns>
    public static bool SpriteHasValue(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sprite_has_value__sprite__string(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the direction the sprite is heading in degrees.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The angle of the sprite velocity.</returns>
    public static float SpriteHeading(Sprite s)
    {
      __sklib_ptr __skparam__s;
      float __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_heading__sprite(__skparam__s);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// The current height of the sprite (aligned to the Y axis).
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The height of the sprite in pixels.</returns>
    public static int SpriteHeight(Sprite s)
    {
      __sklib_ptr __skparam__s;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_height__sprite(__skparam__s);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Hide the specified layer of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to hide the layer of.</param>
    /// <param name="name"> The name of the layer to hide.</param>
    public static void SpriteHideLayer(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__sprite_hide_layer__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Hide the specified layer of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to hide the layer of.</param>
    /// <param name="id"> The index of the layer to hide.</param>
    public static void SpriteHideLayer(Sprite s, int id)
    {
      __sklib_ptr __skparam__s;
      int __skparam__id;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__id = __skadapter__to_sklib_int(id);
      __sklib__sprite_hide_layer__sprite__int(__skparam__s, __skparam__id);
    }
    /// <summary>
    /// Returns the bitmap of the indicated layer of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to get the layer from</param>
    /// <param name="name"> The name of the layer to fetch</param>
    /// <returns>The bitmap at the layer with the indicated name</returns>
    public static Bitmap SpriteLayer(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sprite_layer__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bitmap(__skreturn);
    }
    /// <summary>
    /// Returns the bitmap of the indicated layer of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to get the layer from</param>
    /// <param name="idx"> The index of the layer</param>
    /// <returns>The bitmap of the sprite at that layer</returns>
    public static Bitmap SpriteLayer(Sprite s, int idx)
    {
      __sklib_ptr __skparam__s;
      int __skparam__idx;
      __sklib_ptr __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skreturn = __sklib__sprite_layer__sprite__int(__skparam__s, __skparam__idx);
      return __skadapter__to_bitmap(__skreturn);
    }
    /// <summary>
    /// Gets a circle in the bounds of the indicated layer.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="name"> The name of the layer.</param>
    /// <returns>A bounding circle that surrounds the sprite's layer</returns>
    public static Circle SpriteLayerCircle(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      __sklib_circle __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sprite_layer_circle__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_circle(__skreturn);
    }
    /// <summary>
    /// Gets a circle in the bounds of the indicated layer.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="idx"> The index of the layer.</param>
    /// <returns>A bounding circle that surrounds the sprite's layer</returns>
    public static Circle SpriteLayerCircle(Sprite s, int idx)
    {
      __sklib_ptr __skparam__s;
      int __skparam__idx;
      __sklib_circle __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skreturn = __sklib__sprite_layer_circle__sprite__int(__skparam__s, __skparam__idx);
      return __skadapter__to_circle(__skreturn);
    }
    /// <summary>
    /// Returns the number of layers within the sprite.
    /// </summary>
    /// <param name="s"> The sprite to get the layer count from.</param>
    /// <returns>The number of image layers in the sprite.</returns>
    public static int SpriteLayerCount(Sprite s)
    {
      __sklib_ptr __skparam__s;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_layer_count__sprite(__skparam__s);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// The height of a given layer of the sprite (aligned to the Y axis).
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="name"> The name of the layer to get the details of.</param>
    /// <returns>The height of the sprite's layer in pixels.</returns>
    public static int SpriteLayerHeight(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sprite_layer_height__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// The height of a given layer of the sprite (aligned to the Y axis).
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="idx"> The index of the layer to get the details of.</param>
    /// <returns>The height of the sprite's layer in pixels.</returns>
    public static int SpriteLayerHeight(Sprite s, int idx)
    {
      __sklib_ptr __skparam__s;
      int __skparam__idx;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skreturn = __sklib__sprite_layer_height__sprite__int(__skparam__s, __skparam__idx);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the index of the specified layer.
    /// </summary>
    /// <param name="s"> The sprite to get the layer from</param>
    /// <param name="name"> The name of the layer to get the index of</param>
    /// <returns>The index of the layer in the sprite</returns>
    public static int SpriteLayerIndex(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sprite_layer_index__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the name of the specified layer.
    /// </summary>
    /// <param name="s"> The sprite to get the layer name from</param>
    /// <param name="idx"> The index of the layer you want the name of</param>
    /// <returns>The name of the sprite's layer at that index</returns>
    public static string SpriteLayerName(Sprite s, int idx)
    {
      __sklib_ptr __skparam__s;
      int __skparam__idx;
      __sklib_string __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skreturn = __sklib__sprite_layer_name__sprite__int(__skparam__s, __skparam__idx);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Gets the offset of the specified layer.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="name"> The name of the layer to get the offset of.</param>
    /// <returns>The offset of the named layer in the sprite.</returns>
    public static Vector2D SpriteLayerOffset(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      __sklib_vector_2d __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sprite_layer_offset__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Gets the offset of the specified layer.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="idx"> The index of the layer to get the offset of.</param>
    /// <returns>The offset of the layer in the sprite.</returns>
    public static Vector2D SpriteLayerOffset(Sprite s, int idx)
    {
      __sklib_ptr __skparam__s;
      int __skparam__idx;
      __sklib_vector_2d __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skreturn = __sklib__sprite_layer_offset__sprite__int(__skparam__s, __skparam__idx);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Gets a rectangle that surrounds the indicated layer.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="name"> The name of the layer.</param>
    /// <returns>A bounding rectangle that surrounds the sprite's layer</returns>
    public static Rectangle SpriteLayerRectangle(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      __sklib_rectangle __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sprite_layer_rectangle__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Gets a rectangle that surrounds the indicated layer.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="idx"> The index of the layer.</param>
    /// <returns>A bounding rectangle that surrounds the sprite's layer</returns>
    public static Rectangle SpriteLayerRectangle(Sprite s, int idx)
    {
      __sklib_ptr __skparam__s;
      int __skparam__idx;
      __sklib_rectangle __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skreturn = __sklib__sprite_layer_rectangle__sprite__int(__skparam__s, __skparam__idx);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// The width of a given layer of the sprite (aligned to the X axis).
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="name"> The name of the layer to get the details of.</param>
    /// <returns>The width of the sprite's layer in pixels.</returns>
    public static int SpriteLayerWidth(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sprite_layer_width__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// The width of a given layer of the sprite (aligned to the X axis).
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="idx"> The index of the layer to get the details of.</param>
    /// <returns>The width of the sprite's layer in pixels.</returns>
    public static int SpriteLayerWidth(Sprite s, int idx)
    {
      __sklib_ptr __skparam__s;
      int __skparam__idx;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skreturn = __sklib__sprite_layer_width__sprite__int(__skparam__s, __skparam__idx);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns a matrix that can be used to transform points into the coordinate space of the passed in sprite.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>A matrix that transforms points into the sprites coordinate space.</returns>
    public static Matrix2D SpriteLocationMatrix(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_matrix_2d __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_location_matrix__sprite(__skparam__s);
      return __skadapter__to_matrix_2d(__skreturn);
    }
    /// <summary>
    /// This indicates the mass of the sprite for any of the collide methods from Physics. The mass of two colliding sprites will determine the relative velocitys after the collision.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The mass of the sprite.</returns>
    public static float SpriteMass(Sprite s)
    {
      __sklib_ptr __skparam__s;
      float __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_mass__sprite(__skparam__s);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Indicates if the sprite is moved from its anchor point, or from its top left. When this returns true the location of the sprite will indicate its anchor point. When this returns false the location of the sprite is its top left corner.
    /// </summary>
    /// <param name="s"> The sprite to get the details of.</param>
    /// <returns>True if the sprite moves from its anchor point.</returns>
    public static bool SpriteMoveFromAnchorPoint(Sprite s)
    {
      __sklib_ptr __skparam__s;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_move_from_anchor_point__sprite(__skparam__s);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// This void starts the sprite moving to the indicated destination point, over a specified number of seconds. When the sprite arrives it will raise the sprite_arrived event.
    /// </summary>
    /// <param name="s"> The sprite to move.</param>
    /// <param name="pt"> The sprite's destination.</param>
    /// <param name="takingSeconds"> The time the sprite should take to get to pt.</param>
    public static void SpriteMoveTo(Sprite s, Point2D pt, float takingSeconds)
    {
      __sklib_ptr __skparam__s;
      __sklib_point_2d __skparam__pt;
      float __skparam__taking_seconds;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__taking_seconds = __skadapter__to_sklib_float(takingSeconds);
      __sklib__sprite_move_to__sprite__point_2d_ref__float(__skparam__s, __skparam__pt, __skparam__taking_seconds);
    }
    /// <summary>
    /// Returns the name of the sprite. This name is used for resource management and can be used to interact with the sprite in various routines.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The name of the sprite.</returns>
    public static string SpriteName(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_name__sprite(__skparam__s);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns the `sprite` with the specified name.
    /// </summary>
    /// <param name="name"> The name of the sprite to locate.</param>
    /// <returns>The sprite with that name.</returns>
    public static Sprite SpriteNamed(string name)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sprite_named__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_sprite(__skreturn);
    }
    /// <summary>
    /// Returns true if the sprite is entirely off the current screen.
    /// </summary>
    /// <param name="s"> The sprite to test.</param>
    /// <returns>True if the sprite is entirely off the current window.</returns>
    public static bool SpriteOffscreen(Sprite s)
    {
      __sklib_ptr __skparam__s;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_offscreen__sprite(__skparam__s);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true if a pixel of the `sprite` `s` is at the screen location specified (`pt`), which is converted to a world location.
    /// </summary>
    /// <param name="s"> The sprite to test.</param>
    /// <param name="pt"> The location in screen coordinates to check.</param>
    /// <returns>True if the sprite would draw something at this coordinate on the screen when drawn.</returns>
    public static bool SpriteOnScreenAt(Sprite s, Point2D pt)
    {
      __sklib_ptr __skparam__s;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__sprite_on_screen_at__sprite__point_2d_ref(__skparam__s, __skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true if a pixel of the `sprite` `s` is at the screen location specified.
    /// </summary>
    /// <param name="s"> The sprite to test.</param>
    /// <param name="x"> The x location in screen coordinates to check.</param>
    /// <param name="y"> The y location in screen coordinates to check.</param>
    /// <returns>True if the sprite would draw something at this coordinate on the screen when drawn.</returns>
    public static bool SpriteOnScreenAt(Sprite s, double x, double y)
    {
      __sklib_ptr __skparam__s;
      double __skparam__x;
      double __skparam__y;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__sprite_on_screen_at__sprite__double__double(__skparam__s, __skparam__x, __skparam__y);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the sprite's position.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The location of the sprite.</returns>
    public static Point2D SpritePosition(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_point_2d __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_position__sprite(__skparam__s);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Restart the sprite's current animation, this will play a sound if the first cell of the animation is associated with a sound effect.
    /// </summary>
    /// <param name="s"> The sprite to replay the animation of.</param>
    public static void SpriteReplayAnimation(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __sklib__sprite_replay_animation__sprite(__skparam__s);
    }
    /// <summary>
    /// Restart the sprite's current animation, this will play a sound if with_sound is true and the first cell of the animation is associated with a sound effect.
    /// </summary>
    /// <param name="s"> The sprite to replay the animation of.</param>
    /// <param name="withSound"> If false, the animation will not play associated sound effects when restarted.</param>
    public static void SpriteReplayAnimation(Sprite s, bool withSound)
    {
      __sklib_ptr __skparam__s;
      int __skparam__with_sound;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__sprite_replay_animation__sprite__bool(__skparam__s, __skparam__with_sound);
    }
    /// <summary>
    /// This indicates the angle of rotation of the sprite. This will rotate any images of the sprite before drawing, which can be very slow. avoid using this method with bitmap based sprites where possible.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The angle of the sprite rotation.</returns>
    public static float SpriteRotation(Sprite s)
    {
      __sklib_ptr __skparam__s;
      float __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_rotation__sprite(__skparam__s);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// This indicates the scale of the sprite. This will scale any images of the sprite before drawing, which can be very slow. avoid using this method with bitmap based sprites where possible.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The scale of the sprite.</returns>
    public static float SpriteScale(Sprite s)
    {
      __sklib_ptr __skparam__s;
      float __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_scale__sprite(__skparam__s);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Returns the rectangle representing the location of the sprite on the screen.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>A rectangle indicating where the sprite is on the screen.</returns>
    public static Rectangle SpriteScreenRectangle(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_rectangle __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_screen_rectangle__sprite(__skparam__s);
      return __skadapter__to_rectangle(__skreturn);
    }
    /// <summary>
    /// Sends the layer specified backward in the visible layer order.
    /// </summary>
    /// <param name="s"> The sprite to change</param>
    /// <param name="visibleLayer"> The visible layer to send to backward</param>
    public static void SpriteSendLayerBackward(Sprite s, int visibleLayer)
    {
      __sklib_ptr __skparam__s;
      int __skparam__visible_layer;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__visible_layer = __skadapter__to_sklib_int(visibleLayer);
      __sklib__sprite_send_layer_backward__sprite__int(__skparam__s, __skparam__visible_layer);
    }
    /// <summary>
    /// Sends the layer specified to the back in the visible layer order.
    /// </summary>
    /// <param name="s"> The sprite to change</param>
    /// <param name="visibleLayer"> The visible layer to send to back</param>
    public static void SpriteSendLayerToBack(Sprite s, int visibleLayer)
    {
      __sklib_ptr __skparam__s;
      int __skparam__visible_layer;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__visible_layer = __skadapter__to_sklib_int(visibleLayer);
      __sklib__sprite_send_layer_to_back__sprite__int(__skparam__s, __skparam__visible_layer);
    }
    /// <summary>
    /// Allows you to set the anchor point for the sprite. This is the point around which the sprite rotates. This is in sprite coordinates, as if the sprite is drawn at 0,0.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="pt"> The new anchor point in sprite coordinates.</param>
    public static void SpriteSetAnchorPoint(Sprite s, Point2D pt)
    {
      __sklib_ptr __skparam__s;
      __sklib_point_2d __skparam__pt;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __sklib__sprite_set_anchor_point__sprite__point_2d_ref(__skparam__s, __skparam__pt);
    }
    /// <summary>
    /// Sets the bitmap used by the sprite to determine if it has collided with other objects in the game. By default the collision_bitmap is set to the bitmap from the sprite's first layer.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="bmp"> The new collision bitmap for the sprite.</param>
    public static void SpriteSetCollisionBitmap(Sprite s, Bitmap bmp)
    {
      __sklib_ptr __skparam__s;
      __sklib_ptr __skparam__bmp;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __sklib__sprite_set_collision_bitmap__sprite__bitmap(__skparam__s, __skparam__bmp);
    }
    /// <summary>
    /// Sets the kind of collision used with this sprite. This is used when determining if the sprite has collided with other objects in the game.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The new kind of collision test for this sprite.</param>
    public static void SpriteSetCollisionKind(Sprite s, CollisionTestKind value)
    {
      __sklib_ptr __skparam__s;
      int __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_collision_test_kind(value);
      __sklib__sprite_set_collision_kind__sprite__collision_test_kind(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Sets the X value of the sprite's velocity.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The new x component of the sprite's velocity.</param>
    public static void SpriteSetDx(Sprite s, double value)
    {
      __sklib_ptr __skparam__s;
      double __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_double(value);
      __sklib__sprite_set_dx__sprite__double(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Sets the Y value of the sprite's velocity.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The new y component of the sprite's velocity.</param>
    public static void SpriteSetDy(Sprite s, double value)
    {
      __sklib_ptr __skparam__s;
      double __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_double(value);
      __sklib__sprite_set_dy__sprite__double(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Alters the direction the sprite is heading without changing the speed.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The new angle for the sprite's velocity -- distance remains the same.</param>
    public static void SpriteSetHeading(Sprite s, float value)
    {
      __sklib_ptr __skparam__s;
      float __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_float(value);
      __sklib__sprite_set_heading__sprite__float(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Sets the offset of the specified layer. The offset is used when the layer is drawn in the sprite, and moves the image relative to the sprite.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="name"> The name of the layer to change.</param>
    /// <param name="value"> The new offset.</param>
    public static void SpriteSetLayerOffset(Sprite s, string name, Vector2D value)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      __sklib_vector_2d __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__value = __skadapter__to_sklib_vector_2d(value);
      __sklib__sprite_set_layer_offset__sprite__string_ref__vector_2d_ref(__skparam__s, __skparam__name, __skparam__value);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Sets the offset of the specified layer.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="idx"> The index of the layer to change.</param>
    /// <param name="value"> The new offset.</param>
    public static void SpriteSetLayerOffset(Sprite s, int idx, Vector2D value)
    {
      __sklib_ptr __skparam__s;
      int __skparam__idx;
      __sklib_vector_2d __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skparam__value = __skadapter__to_sklib_vector_2d(value);
      __sklib__sprite_set_layer_offset__sprite__int__vector_2d_ref(__skparam__s, __skparam__idx, __skparam__value);
    }
    /// <summary>
    /// Allows you to change the mass of a sprite.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The new mass for the sprite.</param>
    public static void SpriteSetMass(Sprite s, float value)
    {
      __sklib_ptr __skparam__s;
      float __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_float(value);
      __sklib__sprite_set_mass__sprite__float(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Allows you to indicate if the sprite is moved from its anchor point, or from its top left.  When set to true the location of the sprite will be its anchor point. When set to false the location of the sprite is its top left corner.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The value to set this option.</param>
    public static void SpriteSetMoveFromAnchorPoint(Sprite s, bool value)
    {
      __sklib_ptr __skparam__s;
      int __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_bool(value);
      __sklib__sprite_set_move_from_anchor_point__sprite__bool(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Sets the sprite's position.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The new location for the sprite.</param>
    public static void SpriteSetPosition(Sprite s, Point2D value)
    {
      __sklib_ptr __skparam__s;
      __sklib_point_2d __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_point_2d(value);
      __sklib__sprite_set_position__sprite__point_2d_ref(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Allows you to change the rotation of a sprite.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The new rotation angle for the sprite</param>
    public static void SpriteSetRotation(Sprite s, float value)
    {
      __sklib_ptr __skparam__s;
      float __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_float(value);
      __sklib__sprite_set_rotation__sprite__float(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Allows you to change the scale of a sprite.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The new scale for the sprite.</param>
    public static void SpriteSetScale(Sprite s, float value)
    {
      __sklib_ptr __skparam__s;
      float __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_float(value);
      __sklib__sprite_set_scale__sprite__float(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Alters the speed of the sprite without effecting the direction.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The new speed of the sprite -- direction will remain the same.</param>
    public static void SpriteSetSpeed(Sprite s, double value)
    {
      __sklib_ptr __skparam__s;
      double __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_double(value);
      __sklib__sprite_set_speed__sprite__double(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Assigns a value to the sprite.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="name"> The name of the value to change</param>
    /// <param name="val"> The new value.</param>
    public static void SpriteSetValue(Sprite s, string name, float val)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      float __skparam__val;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__val = __skadapter__to_sklib_float(val);
      __sklib__sprite_set_value__sprite__string_ref__float(__skparam__s, __skparam__name, __skparam__val);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Sets the current velocity of the sprite. When the sprite is updated (see `update_sprite`) this vector_2d is used to move the sprite.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The new sprite velocity.</param>
    public static void SpriteSetVelocity(Sprite s, Vector2D value)
    {
      __sklib_ptr __skparam__s;
      __sklib_vector_2d __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_vector_2d(value);
      __sklib__sprite_set_velocity__sprite__vector_2d_ref(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Sets the X position of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The new x location.</param>
    public static void SpriteSetX(Sprite s, double value)
    {
      __sklib_ptr __skparam__s;
      double __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_double(value);
      __sklib__sprite_set_x__sprite__double(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Sets the Y position of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="value"> The new sprite y.</param>
    public static void SpriteSetY(Sprite s, double value)
    {
      __sklib_ptr __skparam__s;
      double __skparam__value;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__value = __skadapter__to_sklib_double(value);
      __sklib__sprite_set_y__sprite__double(__skparam__s, __skparam__value);
    }
    /// <summary>
    /// Show the specified layer of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to show the layer of.</param>
    /// <param name="name"> The layer to show.</param>
    /// <returns>The index of the layer shown, or -1 if no layer found.</returns>
    public static int SpriteShowLayer(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sprite_show_layer__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Show the specified layer of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to show the layer of.</param>
    /// <param name="id"> The index to show.</param>
    /// <returns>The index of the layer shown, or -1 if no layer found.</returns>
    public static int SpriteShowLayer(Sprite s, int id)
    {
      __sklib_ptr __skparam__s;
      int __skparam__id;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__id = __skadapter__to_sklib_int(id);
      __skreturn = __sklib__sprite_show_layer__sprite__int(__skparam__s, __skparam__id);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the current speed (distance travelled per update) of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The speed of the sprite (pixels per update).</returns>
    public static double SpriteSpeed(Sprite s)
    {
      __sklib_ptr __skparam__s;
      double __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_speed__sprite(__skparam__s);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Start playing an animation from the sprite's animation template. This will play a sound effect if the first cell of the animation has a sound.
    /// </summary>
    /// <param name="s"> The sprite to start the animation of.</param>
    /// <param name="named"> The name of the animation to start from the animation script.</param>
    public static void SpriteStartAnimation(Sprite s, string named)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__named;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__named = __skadapter__to_sklib_string(named);
      __sklib__sprite_start_animation__sprite__string_ref(__skparam__s, __skparam__named);
    __skadapter__free__sklib_string(ref __skparam__named);
    }
    /// <summary>
    /// Start playing an animation from the sprite's animation template. The with_sound parameter determines whether to play a sound effect if the first cell of the animation has a sound.
    /// </summary>
    /// <param name="s"> The sprite to start the animation of.</param>
    /// <param name="named"> The name of the animation to start from the animation script.</param>
    /// <param name="withSound"> If false, the animation will not play associated sound effects when started.</param>
    public static void SpriteStartAnimation(Sprite s, string named, bool withSound)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__named;
      int __skparam__with_sound;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__named = __skadapter__to_sklib_string(named);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__sprite_start_animation__sprite__string_ref__bool(__skparam__s, __skparam__named, __skparam__with_sound);
    __skadapter__free__sklib_string(ref __skparam__named);
    }
    /// <summary>
    /// Start playing an animation from the sprite's animation template. This will play a sound effect if the first cell of the animation has a sound.
    /// </summary>
    /// <param name="s"> The sprite to start the animation of.</param>
    /// <param name="idx"> The index of the animation to start from the animation script.</param>
    public static void SpriteStartAnimation(Sprite s, int idx)
    {
      __sklib_ptr __skparam__s;
      int __skparam__idx;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __sklib__sprite_start_animation__sprite__int(__skparam__s, __skparam__idx);
    }
    /// <summary>
    /// Start playing an animation from the sprite's animation template. The with_sound parameter determines whether to play a sound effect if the first cell of the animation has a sound.
    /// </summary>
    /// <param name="s"> The sprite to start the animation of.</param>
    /// <param name="idx"> The index of the animation to start from the animation script.</param>
    /// <param name="withSound"> If false, the animation will not play associated sound effects when started.</param>
    public static void SpriteStartAnimation(Sprite s, int idx, bool withSound)
    {
      __sklib_ptr __skparam__s;
      int __skparam__idx;
      int __skparam__with_sound;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__sprite_start_animation__sprite__int__bool(__skparam__s, __skparam__idx, __skparam__with_sound);
    }
    /// <summary>
    /// Removes an event handler from the sprite, stopping events from this sprite calling the indicated method.
    /// </summary>
    /// <param name="s"> The sprite to remove the handler from</param>
    /// <param name="handler"> The function to remove from this sprites handlers</param>
    public static void SpriteStopCallingOnEvent(Sprite s, SpriteEventHandler handler)
    {
      __sklib_ptr __skparam__s;
      SpriteEventHandler __skparam__handler;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__handler = __skadapter__to_sklib_sprite_event_handler(handler);
      __sklib__sprite_stop_calling_on_event__sprite__sprite_event_handler_ptr(__skparam__s, __skparam__handler);
    }
    /// <summary>
    /// Toggle the visibility of the specified layer of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="name"> The name of the layer to toggle.</param>
    public static void SpriteToggleLayerVisible(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__sprite_toggle_layer_visible__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Toggle the visibility of the specified layer of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to change.</param>
    /// <param name="id"> The index of the layer to toggle.</param>
    public static void SpriteToggleLayerVisible(Sprite s, int id)
    {
      __sklib_ptr __skparam__s;
      int __skparam__id;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__id = __skadapter__to_sklib_int(id);
      __sklib__sprite_toggle_layer_visible__sprite__int(__skparam__s, __skparam__id);
    }
    /// <summary>
    /// Returns the indicated value of the sprite
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="name"> The name of the value to fetch.</param>
    /// <returns>The value from the sprite's data store.</returns>
    public static float SpriteValue(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      float __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sprite_value__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_float(__skreturn);
    }
    /// <summary>
    /// Returns the number of sprite's values.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The number of values stored in the sprite.</returns>
    public static int SpriteValueCount(Sprite s)
    {
      __sklib_ptr __skparam__s;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_value_count__sprite(__skparam__s);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the current velocity of the sprite. When the sprite is updated (see `update_sprite`) this vector_2d is used to move the sprite.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The sprite's velocity.</returns>
    public static Vector2D SpriteVelocity(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __sklib_vector_2d __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_velocity__sprite(__skparam__s);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the index (z-order) of the sprite's layer.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="name"> The name of the layer to get the z index of.</param>
    /// <returns>The z index of the sprite's layer</returns>
    public static int SpriteVisibleIndexOfLayer(Sprite s, string name)
    {
      __sklib_ptr __skparam__s;
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__sprite_visible_index_of_layer__sprite__string_ref(__skparam__s, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the index (z-order) of the sprite's layer.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="id"> The index of the layer to get the z index of.</param>
    /// <returns>The z index of the sprite's layer</returns>
    public static int SpriteVisibleIndexOfLayer(Sprite s, int id)
    {
      __sklib_ptr __skparam__s;
      int __skparam__id;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__id = __skadapter__to_sklib_int(id);
      __skreturn = __sklib__sprite_visible_index_of_layer__sprite__int(__skparam__s, __skparam__id);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the index of the n'th (idx parameter) visible layer.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="idx"> The index of the visible layer to fetch.</param>
    /// <returns>The layer index of the selected visible layer.</returns>
    public static int SpriteVisibleLayer(Sprite s, int idx)
    {
      __sklib_ptr __skparam__s;
      int __skparam__idx;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skreturn = __sklib__sprite_visible_layer__sprite__int(__skparam__s, __skparam__idx);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the number of layers that are currently visible for the sprite.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The number of visible layers for the sprite.</returns>
    public static int SpriteVisibleLayerCount(Sprite s)
    {
      __sklib_ptr __skparam__s;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_visible_layer_count__sprite(__skparam__s);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the id of the layer at index `idx` that is currently visible. Index 0 is the background, with larger indexes moving toward the foreground. This returns -1 if there are no visible layers.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <param name="idx"> The index of the visible layer.</param>
    /// <returns>The layer index of the visible layer.</returns>
    public static int SpriteVisibleLayerId(Sprite s, int idx)
    {
      __sklib_ptr __skparam__s;
      int __skparam__idx;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__idx = __skadapter__to_sklib_int(idx);
      __skreturn = __sklib__sprite_visible_layer_id__sprite__int(__skparam__s, __skparam__idx);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// The current Width of the sprite (aligned to the X axis).
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The width of the sprite's layer in pixels.</returns>
    public static int SpriteWidth(Sprite s)
    {
      __sklib_ptr __skparam__s;
      int __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_width__sprite(__skparam__s);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the X position of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The x location of the sprite</returns>
    public static double SpriteX(Sprite s)
    {
      __sklib_ptr __skparam__s;
      double __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_x__sprite(__skparam__s);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Returns the Y position of the sprite.
    /// </summary>
    /// <param name="s"> The sprite to get the details from.</param>
    /// <returns>The sprite's y location.</returns>
    public static double SpriteY(Sprite s)
    {
      __sklib_ptr __skparam__s;
      double __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skreturn = __sklib__sprite_y__sprite(__skparam__s);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Removes an global event handler, stopping events calling the indicated void.
    /// </summary>
    /// <param name="handler"> The function to remove from the list of sprite event handlers.</param>
    public static void StopCallingOnSpriteEvent(SpriteEventHandler handler)
    {
      SpriteEventHandler __skparam__handler;
      __skparam__handler = __skadapter__to_sklib_sprite_event_handler(handler);
      __sklib__stop_calling_on_sprite_event__sprite_event_handler_ptr(__skparam__handler);
    }
    /// <summary>
    /// Update all of the sprites in the current sprite pack.
    /// </summary>
    public static void UpdateAllSprites()
    {
      __sklib__update_all_sprites();
    }
    /// <summary>
    /// Update all of the sprites in the current sprite pack, passing in a percentage value to indicate the percentage to update.
    /// </summary>
    /// <param name="pct"> The percentage of the update to apply.</param>
    public static void UpdateAllSprites(float pct)
    {
      float __skparam__pct;
      __skparam__pct = __skadapter__to_sklib_float(pct);
      __sklib__update_all_sprites__float(__skparam__pct);
    }
    /// <summary>
    /// Update the position and animation details of the sprite. This will play a sound effect if the new cell of the animation has a sound.
    /// </summary>
    /// <param name="s"> The sprite to update.</param>
    public static void UpdateSprite(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __sklib__update_sprite__sprite(__skparam__s);
    }
    /// <summary>
    /// Update the position and animation details of the sprite. This will play a sound effect if the new cell of the animation has a sound and with_sound is true.
    /// </summary>
    /// <param name="s"> The sprite to update</param>
    /// <param name="withSound"> If false, animations will not play associated sound effects when updated.</param>
    public static void UpdateSprite(Sprite s, bool withSound)
    {
      __sklib_ptr __skparam__s;
      int __skparam__with_sound;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__update_sprite__sprite__bool(__skparam__s, __skparam__with_sound);
    }
    /// <summary>
    /// Update the position and animation details of the sprite by a given percentage of a single unit of movement/animation. This will play a sound effect if the new cell of the animation has a sound.
    /// </summary>
    /// <param name="s"> The sprite to update.</param>
    /// <param name="pct"> The percent to update.</param>
    public static void UpdateSprite(Sprite s, float pct)
    {
      __sklib_ptr __skparam__s;
      float __skparam__pct;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__pct = __skadapter__to_sklib_float(pct);
      __sklib__update_sprite__sprite__float(__skparam__s, __skparam__pct);
    }
    /// <summary>
    /// Update the position and animation details of the sprite by a given percentage of a single unit of movement/animation. This will play a sound effect if the new cell of the animation has a sound and with_sound is true.
    /// </summary>
    /// <param name="s"> The sprite to update.</param>
    /// <param name="pct"> The percent to update.</param>
    /// <param name="withSound"> If false, animations will not play associated sound effects when updated.</param>
    public static void UpdateSprite(Sprite s, float pct, bool withSound)
    {
      __sklib_ptr __skparam__s;
      float __skparam__pct;
      int __skparam__with_sound;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__pct = __skadapter__to_sklib_float(pct);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__update_sprite__sprite__float__bool(__skparam__s, __skparam__pct, __skparam__with_sound);
    }
    /// <summary>
    /// Updates the animation details of the sprite. This will play a sound effect if the new cell of the animation has a sound.
    /// </summary>
    /// <param name="s"> The sprite to update.</param>
    public static void UpdateSpriteAnimation(Sprite s)
    {
      __sklib_ptr __skparam__s;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __sklib__update_sprite_animation__sprite(__skparam__s);
    }
    /// <summary>
    /// Update the animation details of the sprite. This will play a sound effect if the new cell of the animation has a sound and with_sound is true.
    /// </summary>
    /// <param name="s"> The sprite to update.</param>
    /// <param name="withSound"> If false, animations will not play associated sound effects when updated.</param>
    public static void UpdateSpriteAnimation(Sprite s, bool withSound)
    {
      __sklib_ptr __skparam__s;
      int __skparam__with_sound;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__update_sprite_animation__sprite__bool(__skparam__s, __skparam__with_sound);
    }
    /// <summary>
    /// Update the animation details of the sprite by a given percentage of a single unit of movement/animation. This will play a sound effect if the new cell of the animation has a sound.
    /// </summary>
    /// <param name="s"> The sprite to update.</param>
    /// <param name="pct"> The percent to update.</param>
    public static void UpdateSpriteAnimation(Sprite s, float pct)
    {
      __sklib_ptr __skparam__s;
      float __skparam__pct;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__pct = __skadapter__to_sklib_float(pct);
      __sklib__update_sprite_animation__sprite__float(__skparam__s, __skparam__pct);
    }
    /// <summary>
    /// Update the position and animation details of the sprite by a given percentage of a single unit of movement/animation. This will play a sound effect if the new cell of the animation has a sound and with_sound is true.
    /// </summary>
    /// <param name="s"> The sprite to update.</param>
    /// <param name="pct"> The percent to update.</param>
    /// <param name="withSound"> If false, animations will not play associated sound effects when updated.</param>
    public static void UpdateSpriteAnimation(Sprite s, float pct, bool withSound)
    {
      __sklib_ptr __skparam__s;
      float __skparam__pct;
      int __skparam__with_sound;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__pct = __skadapter__to_sklib_float(pct);
      __skparam__with_sound = __skadapter__to_sklib_bool(withSound);
      __sklib__update_sprite_animation__sprite__float__bool(__skparam__s, __skparam__pct, __skparam__with_sound);
    }
    /// <summary>
    /// Returns a `vector_2d` that is the difference in location from the center of the sprite `s` to the point `pt`.
    /// </summary>
    /// <param name="s"> The sprite that is at the start of the vector.</param>
    /// <param name="pt"> The point that is at the end of the vector.</param>
    /// <returns>A vector pointing from the sprite to the point.</returns>
    public static Vector2D VectorFromCenterSpriteToPoint(Sprite s, Point2D pt)
    {
      __sklib_ptr __skparam__s;
      __sklib_point_2d __skparam__pt;
      __sklib_vector_2d __skreturn;
      __skparam__s = __skadapter__to_sklib_sprite(s);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__vector_from_center_sprite_to_point__sprite__point_2d_ref(__skparam__s, __skparam__pt);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a `vector_2d` that is the difference in the position of two sprites (`s1` and `s2`).
    /// </summary>
    /// <param name="s1"> The sprite that is at the start of the vector.</param>
    /// <param name="s2"> The sprite that is at the end of the vector.</param>
    /// <returns>A vector that points from s1 to s2.</returns>
    public static Vector2D VectorFromTo(Sprite s1, Sprite s2)
    {
      __sklib_ptr __skparam__s1;
      __sklib_ptr __skparam__s2;
      __sklib_vector_2d __skreturn;
      __skparam__s1 = __skadapter__to_sklib_sprite(s1);
      __skparam__s2 = __skadapter__to_sklib_sprite(s2);
      __skreturn = __sklib__vector_from_to__sprite__sprite(__skparam__s1, __skparam__s2);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Get a single character input by the user.
    /// </summary>
    /// <returns>The character typed by the user.</returns>
    public static char ReadChar()
    {
      char __skreturn;
      __skreturn = __sklib__read_char();
      return __skadapter__to_char(__skreturn);
    }
    /// <summary>
    /// Read a line of text from the terminal. The user will see the text as they type it.
    /// </summary>
    /// <returns>The text entered by the user.</returns>
    public static string ReadLine()
    {
      __sklib_string __skreturn;
      __skreturn = __sklib__read_line();
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Checks if there is data waiting to be read by read line or read char.
    /// </summary>
    /// <returns>true if there is data waiting to be read.</returns>
    public static bool TerminalHasInput()
    {
      int __skreturn;
      __skreturn = __sklib__terminal_has_input();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Write the passed in data to the terminal.
    /// </summary>
    /// <param name="data"> The character to write</param>
    public static void Write(char data)
    {
      char __skparam__data;
      __skparam__data = __skadapter__to_sklib_char(data);
      __sklib__write__char(__skparam__data);
    }
    /// <summary>
    /// Write the passed in data to the terminal.
    /// </summary>
    /// <param name="data"> The text to write</param>
    public static void Write(double data)
    {
      double __skparam__data;
      __skparam__data = __skadapter__to_sklib_double(data);
      __sklib__write__double(__skparam__data);
    }
    /// <summary>
    /// Write the passed in data to the terminal.
    /// </summary>
    /// <param name="data"> The text to write</param>
    public static void Write(int data)
    {
      int __skparam__data;
      __skparam__data = __skadapter__to_sklib_int(data);
      __sklib__write__int(__skparam__data);
    }
    /// <summary>
    /// Write the supplied text to the Terminal.
    /// </summary>
    /// <param name="text"> The text to write</param>
    public static void Write(string text)
    {
      __sklib_string __skparam__text;
      __skparam__text = __skadapter__to_sklib_string(text);
      __sklib__write__string(__skparam__text);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// Write the passed in data, then move to the next line/row of the terminal.
    /// </summary>
    /// <param name="data"> The character to write</param>
    public static void WriteLine(char data)
    {
      char __skparam__data;
      __skparam__data = __skadapter__to_sklib_char(data);
      __sklib__write_line__char(__skparam__data);
    }
    /// <summary>
    /// Move to the next line/row of the terminal.
    /// </summary>
    public static void WriteLine()
    {
      __sklib__write_line();
    }
    /// <summary>
    /// Write the passed in data, then move to the next line/row of the terminal.
    /// </summary>
    /// <param name="data"> The text to write</param>
    public static void WriteLine(double data)
    {
      double __skparam__data;
      __skparam__data = __skadapter__to_sklib_double(data);
      __sklib__write_line__double(__skparam__data);
    }
    /// <summary>
    /// Write the passed in data, then move to the next line/row of the terminal.
    /// </summary>
    /// <param name="data"> The text to write</param>
    public static void WriteLine(int data)
    {
      int __skparam__data;
      __skparam__data = __skadapter__to_sklib_int(data);
      __sklib__write_line__int(__skparam__data);
    }
    /// <summary>
    /// Write the passed in text, then move to the next line/row of the terminal.
    /// </summary>
    /// <param name="line"> The text to write</param>
    public static void WriteLine(string line)
    {
      __sklib_string __skparam__line;
      __skparam__line = __skadapter__to_sklib_string(line);
      __sklib__write_line__string(__skparam__line);
    __skadapter__free__sklib_string(ref __skparam__line);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The name of the `font` which will be used to draw the text</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public static void DrawText(string text, Color clr, string fnt, int fontSize, double x, double y)
    {
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      __sklib_string __skparam__fnt;
      int __skparam__font_size;
      double __skparam__x;
      double __skparam__y;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_string(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_text__string_ref__color_ref__string_ref__int__double__double(__skparam__text, __skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__x, __skparam__y);
    __skadapter__free__sklib_string(ref __skparam__text);
    __skadapter__free__sklib_string(ref __skparam__fnt);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The name of the `font` which will be used to draw the text</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public static void DrawText(string text, Color clr, string fnt, int fontSize, double x, double y, DrawingOptions opts)
    {
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      __sklib_string __skparam__fnt;
      int __skparam__font_size;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_string(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_text__string_ref__color_ref__string_ref__int__double__double__drawing_options_ref(__skparam__text, __skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__x, __skparam__y, __skparam__opts);
    __skadapter__free__sklib_string(ref __skparam__text);
    __skadapter__free__sklib_string(ref __skparam__fnt);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public static void DrawText(string text, Color clr, double x, double y)
    {
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_text__string_ref__color_ref__double__double(__skparam__text, __skparam__clr, __skparam__x, __skparam__y);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public static void DrawText(string text, Color clr, double x, double y, DrawingOptions opts)
    {
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_text__string_ref__color_ref__double__double__drawing_options_ref(__skparam__text, __skparam__clr, __skparam__x, __skparam__y, __skparam__opts);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The `font` to be used to draw the text.</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public static void DrawText(string text, Color clr, Font fnt, int fontSize, double x, double y)
    {
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      __sklib_ptr __skparam__fnt;
      int __skparam__font_size;
      double __skparam__x;
      double __skparam__y;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_text__string_ref__color_ref__font__int__double__double(__skparam__text, __skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__x, __skparam__y);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The `font` to be used to draw the text.</param>
    /// <param name="fontSize"> The desired size of the font.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public static void DrawText(string text, Color clr, Font fnt, int fontSize, double x, double y, DrawingOptions opts)
    {
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      __sklib_ptr __skparam__fnt;
      int __skparam__font_size;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_text__string_ref__color_ref__font__int__double__double__drawing_options_ref(__skparam__text, __skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__x, __skparam__y, __skparam__opts);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="bmp"> The bitmap to draw to</param>
    /// <param name="text"> The text string to be written to the bitmap.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The name of the `font` which will be used to draw the text</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public static void DrawTextOnBitmap(Bitmap bmp, string text, Color clr, string fnt, int fontSize, double x, double y)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      __sklib_string __skparam__fnt;
      int __skparam__font_size;
      double __skparam__x;
      double __skparam__y;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_string(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__string_ref__int__double__double(__skparam__bmp, __skparam__text, __skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__x, __skparam__y);
    __skadapter__free__sklib_string(ref __skparam__text);
    __skadapter__free__sklib_string(ref __skparam__fnt);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="bmp"> The bitmap to draw to</param>
    /// <param name="text"> The text string to be written to the bitmap.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The name of the `font` which will be used to draw the text</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public static void DrawTextOnBitmap(Bitmap bmp, string text, Color clr, string fnt, int fontSize, double x, double y, DrawingOptions opts)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      __sklib_string __skparam__fnt;
      int __skparam__font_size;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_string(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__string_ref__int__double__double__drawing_options_ref(__skparam__bmp, __skparam__text, __skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__x, __skparam__y, __skparam__opts);
    __skadapter__free__sklib_string(ref __skparam__text);
    __skadapter__free__sklib_string(ref __skparam__fnt);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="bmp"> The bitmap to draw to</param>
    /// <param name="text"> The text string to be written to the bitmap.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public static void DrawTextOnBitmap(Bitmap bmp, string text, Color clr, double x, double y)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__double__double(__skparam__bmp, __skparam__text, __skparam__clr, __skparam__x, __skparam__y);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="bmp"> The bitmap to draw to</param>
    /// <param name="text"> The text string to be written to the bitmap.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public static void DrawTextOnBitmap(Bitmap bmp, string text, Color clr, double x, double y, DrawingOptions opts)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__double__double__drawing_options_ref(__skparam__bmp, __skparam__text, __skparam__clr, __skparam__x, __skparam__y, __skparam__opts);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="bmp"> The bitmap to draw to</param>
    /// <param name="text"> The text string to be written to the bitmap.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The `font` to be used to draw the text.</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public static void DrawTextOnBitmap(Bitmap bmp, string text, Color clr, Font fnt, int fontSize, double x, double y)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      __sklib_ptr __skparam__fnt;
      int __skparam__font_size;
      double __skparam__x;
      double __skparam__y;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__font__int__double__double(__skparam__bmp, __skparam__text, __skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__x, __skparam__y);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="bmp"> The bitmap to draw to</param>
    /// <param name="text"> The text string to be written to the bitmap.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The `font` to be used to draw the text.</param>
    /// <param name="fontSize"> The desired size of the font.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public static void DrawTextOnBitmap(Bitmap bmp, string text, Color clr, Font fnt, int fontSize, double x, double y, DrawingOptions opts)
    {
      __sklib_ptr __skparam__bmp;
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      __sklib_ptr __skparam__fnt;
      int __skparam__font_size;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_text_on_bitmap__bitmap__string_ref__color_ref__font__int__double__double__drawing_options_ref(__skparam__bmp, __skparam__text, __skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__x, __skparam__y, __skparam__opts);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="wnd"> The window to draw to</param>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The name of the `font` which will be used to draw the text</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public static void DrawTextOnWindow(Window wnd, string text, Color clr, string fnt, int fontSize, double x, double y)
    {
      __sklib_ptr __skparam__wnd;
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      __sklib_string __skparam__fnt;
      int __skparam__font_size;
      double __skparam__x;
      double __skparam__y;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_string(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_text_on_window__window__string_ref__color_ref__string_ref__int__double__double(__skparam__wnd, __skparam__text, __skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__x, __skparam__y);
    __skadapter__free__sklib_string(ref __skparam__text);
    __skadapter__free__sklib_string(ref __skparam__fnt);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="wnd"> The window to draw to</param>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The name of the `font` which will be used to draw the text</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public static void DrawTextOnWindow(Window wnd, string text, Color clr, string fnt, int fontSize, double x, double y, DrawingOptions opts)
    {
      __sklib_ptr __skparam__wnd;
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      __sklib_string __skparam__fnt;
      int __skparam__font_size;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_string(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_text_on_window__window__string_ref__color_ref__string_ref__int__double__double__drawing_options_ref(__skparam__wnd, __skparam__text, __skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__x, __skparam__y, __skparam__opts);
    __skadapter__free__sklib_string(ref __skparam__text);
    __skadapter__free__sklib_string(ref __skparam__fnt);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="wnd"> The window to draw to</param>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public static void DrawTextOnWindow(Window wnd, string text, Color clr, double x, double y)
    {
      __sklib_ptr __skparam__wnd;
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_text_on_window__window__string_ref__color_ref__double__double(__skparam__wnd, __skparam__text, __skparam__clr, __skparam__x, __skparam__y);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="wnd"> The window to draw to</param>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public static void DrawTextOnWindow(Window wnd, string text, Color clr, double x, double y, DrawingOptions opts)
    {
      __sklib_ptr __skparam__wnd;
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_text_on_window__window__string_ref__color_ref__double__double__drawing_options_ref(__skparam__wnd, __skparam__text, __skparam__clr, __skparam__x, __skparam__y, __skparam__opts);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="wnd"> The window to draw to</param>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The `font` to be used to draw the text.</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public static void DrawTextOnWindow(Window wnd, string text, Color clr, Font fnt, int fontSize, double x, double y)
    {
      __sklib_ptr __skparam__wnd;
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      __sklib_ptr __skparam__fnt;
      int __skparam__font_size;
      double __skparam__x;
      double __skparam__y;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __sklib__draw_text_on_window__window__string_ref__color_ref__font__int__double__double(__skparam__wnd, __skparam__text, __skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__x, __skparam__y);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="wnd"> The window to draw to</param>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The `font` to be used to draw the text.</param>
    /// <param name="fontSize"> The desired size of the font.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public static void DrawTextOnWindow(Window wnd, string text, Color clr, Font fnt, int fontSize, double x, double y, DrawingOptions opts)
    {
      __sklib_ptr __skparam__wnd;
      __sklib_string __skparam__text;
      __sklib_color __skparam__clr;
      __sklib_ptr __skparam__fnt;
      int __skparam__font_size;
      double __skparam__x;
      double __skparam__y;
      __sklib_drawing_options __skparam__opts;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_text_on_window__window__string_ref__color_ref__font__int__double__double__drawing_options_ref(__skparam__wnd, __skparam__text, __skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__x, __skparam__y, __skparam__opts);
    __skadapter__free__sklib_string(ref __skparam__text);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="name"> The name of the `font` to be checked.</param>
    /// <param name="fontSize"> The size to check.</param>
    /// <returns>Returns true if there is a font with the supplied name that has the supplied size.</returns>
    public static bool FontHasSize(string name, int fontSize)
    {
      __sklib_string __skparam__name;
      int __skparam__font_size;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skreturn = __sklib__font_has_size__string_ref__int(__skparam__name, __skparam__font_size);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="fnt"> The `font` to be checked.</param>
    /// <param name="fontSize"> The size to check.</param>
    /// <returns>Returns true if the supplied `font` has the supplied size.</returns>
    public static bool FontHasSize(Font fnt, int fontSize)
    {
      __sklib_ptr __skparam__fnt;
      int __skparam__font_size;
      int __skreturn;
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skreturn = __sklib__font_has_size__font__int(__skparam__fnt, __skparam__font_size);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="name"> The name of the `font` to load the size for.</param>
    /// <param name="fontSize"> The desired size of the `font`.</param>
    public static void FontLoadSize(string name, int fontSize)
    {
      __sklib_string __skparam__name;
      int __skparam__font_size;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __sklib__font_load_size__string_ref__int(__skparam__name, __skparam__font_size);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="fnt"> The `font` to load the size for.</param>
    /// <param name="fontSize"> The desired size of the `font`.</param>
    public static void FontLoadSize(Font fnt, int fontSize)
    {
      __sklib_ptr __skparam__fnt;
      int __skparam__font_size;
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __sklib__font_load_size__font__int(__skparam__fnt, __skparam__font_size);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="name"> The name of the font to find.</param>
    /// <returns>Returns the font that has the supplied name.</returns>
    public static Font FontNamed(string name)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__font_named__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_font(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    public static void FreeAllFonts()
    {
      __sklib__free_all_fonts();
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="fnt"> The font to be freed.</param>
    public static void FreeFont(Font fnt)
    {
      __sklib_ptr __skparam__fnt;
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __sklib__free_font__font(__skparam__fnt);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="name"> The name of the font to return the style of.</param>
    /// <returns>Returns the current `font_style` for the `font`.</returns>
    public static FontStyle GetFontStyle(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__get_font_style__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_font_style(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="fnt"> The `font` to return the style of.</param>
    /// <returns>Returns the current `font_style` for the `font`.</returns>
    public static FontStyle GetFontStyle(Font fnt)
    {
      __sklib_ptr __skparam__fnt;
      int __skreturn;
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skreturn = __sklib__get_font_style__font(__skparam__fnt);
      return __skadapter__to_font_style(__skreturn);
    }
    /// <summary>
    /// Searches for and (if found) returns a default system font. Otherwise defaults to the in-built font.
    /// </summary>
    /// <returns>Returns the `font` found, or the in-built font if not</returns>
    public static Font GetSystemFont()
    {
      __sklib_ptr __skreturn;
      __skreturn = __sklib__get_system_font();
      return __skadapter__to_font(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="fnt"> The `font` to check if loaded.</param>
    /// <returns>Returns true if the specified `font` is loaded.</returns>
    public static bool HasFont(Font fnt)
    {
      __sklib_ptr __skparam__fnt;
      int __skreturn;
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skreturn = __sklib__has_font__font(__skparam__fnt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="name"> The name of `font` to check if loaded.</param>
    /// <returns>Returns whether there is a loaded font with the supplied name.</returns>
    public static bool HasFont(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_font__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="name"> The name of the `font` to be loaded from file.</param>
    /// <param name="filename"> The name of the file to load the `font` from.</param>
    /// <returns>Returns a new `font` object.</returns>
    public static Font LoadFont(string name, string filename)
    {
      __sklib_string __skparam__name;
      __sklib_string __skparam__filename;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __skreturn = __sklib__load_font__string_ref__string_ref(__skparam__name, __skparam__filename);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__filename);
      return __skadapter__to_font(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="name"> The name of the `font` to set the style of.</param>
    /// <param name="style"> The new style for the `font`.</param>
    public static void SetFontStyle(string name, FontStyle style)
    {
      __sklib_string __skparam__name;
      int __skparam__style;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__style = __skadapter__to_sklib_font_style(style);
      __sklib__set_font_style__string_ref__font_style(__skparam__name, __skparam__style);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="fnt"> The `font` to set the style of.</param>
    /// <param name="style"> The new style for the `font`.</param>
    public static void SetFontStyle(Font fnt, FontStyle style)
    {
      __sklib_ptr __skparam__fnt;
      int __skparam__style;
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skparam__style = __skadapter__to_sklib_font_style(style);
      __sklib__set_font_style__font__font_style(__skparam__fnt, __skparam__style);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to check the length of.</param>
    /// <param name="fnt"> The font used for the text.</param>
    /// <param name="fontSize"> The size of the font used for the text.</param>
    /// <returns>Returns the height of the text as an integer.</returns>
    public static int TextHeight(string text, string fnt, int fontSize)
    {
      __sklib_string __skparam__text;
      __sklib_string __skparam__fnt;
      int __skparam__font_size;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__fnt = __skadapter__to_sklib_string(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skreturn = __sklib__text_height__string_ref__string_ref__int(__skparam__text, __skparam__fnt, __skparam__font_size);
    __skadapter__free__sklib_string(ref __skparam__text);
    __skadapter__free__sklib_string(ref __skparam__fnt);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to check the length of.</param>
    /// <param name="fnt"> The font used for the text.</param>
    /// <param name="fontSize"> The size of the font used for the text.</param>
    /// <returns>Returns the height of the text as an integer.</returns>
    public static int TextHeight(string text, Font fnt, int fontSize)
    {
      __sklib_string __skparam__text;
      __sklib_ptr __skparam__fnt;
      int __skparam__font_size;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skreturn = __sklib__text_height__string_ref__font__int(__skparam__text, __skparam__fnt, __skparam__font_size);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to check the length of.</param>
    /// <param name="fnt"> The font used for the text.</param>
    /// <param name="fontSize"> The size of the font used for the text.</param>
    /// <returns>Returns the width of the text as an integer.</returns>
    public static int TextWidth(string text, string fnt, int fontSize)
    {
      __sklib_string __skparam__text;
      __sklib_string __skparam__fnt;
      int __skparam__font_size;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__fnt = __skadapter__to_sklib_string(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skreturn = __sklib__text_width__string_ref__string_ref__int(__skparam__text, __skparam__fnt, __skparam__font_size);
    __skadapter__free__sklib_string(ref __skparam__text);
    __skadapter__free__sklib_string(ref __skparam__fnt);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to check the length of.</param>
    /// <param name="fnt"> The font used for the text.</param>
    /// <param name="fontSize"> The size of the font used for the text.</param>
    /// <returns>Returns the width of the text as an integer.</returns>
    public static int TextWidth(string text, Font fnt, int fontSize)
    {
      __sklib_string __skparam__text;
      __sklib_ptr __skparam__fnt;
      int __skparam__font_size;
      int __skreturn;
      __skparam__text = __skadapter__to_sklib_string(text);
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skreturn = __sklib__text_width__string_ref__font__int(__skparam__text, __skparam__fnt, __skparam__font_size);
    __skadapter__free__sklib_string(ref __skparam__text);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Draw the text that the user is currently enterring on the current window.
    /// </summary>
    /// <param name="clr"> The color for the text</param>
    /// <param name="fnt"> The font to use</param>
    /// <param name="fontSize"> The size of the font</param>
    /// <param name="opts"> Any drawing options</param>
    public static void DrawCollectedText(Color clr, Font fnt, int fontSize, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_ptr __skparam__fnt;
      int __skparam__font_size;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__fnt = __skadapter__to_sklib_font(fnt);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_collected_text__color__font__int__drawing_options_ref(__skparam__clr, __skparam__fnt, __skparam__font_size, __skparam__opts);
    }
    /// <summary>
    /// Ends reading text in for the current window.
    /// </summary>
    public static void EndReadingText()
    {
      __sklib__end_reading_text();
    }
    /// <summary>
    /// Ends reading text for the passed in window.
    /// </summary>
    /// <param name="wind"> The window to end reading text</param>
    public static void EndReadingText(Window wind)
    {
      __sklib_ptr __skparam__wind;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __sklib__end_reading_text__window(__skparam__wind);
    }
    /// <summary>
    /// Returns true when the current window is reading text.
    /// </summary>
    /// <returns>True when window is setup to read input from the user.</returns>
    public static bool ReadingText()
    {
      int __skreturn;
      __skreturn = __sklib__reading_text();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true when the window is reading text.
    /// </summary>
    /// <param name="wind"> The window to check</param>
    /// <returns>True when window is setup to read input from the user.</returns>
    public static bool ReadingText(Window wind)
    {
      __sklib_ptr __skparam__wind;
      int __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skreturn = __sklib__reading_text__window(__skparam__wind);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Start reading text in the current window within the bounds of the supplied rectangle.
    /// </summary>
    /// <param name="rect"> The area where the text will be entered.</param>
    public static void StartReadingText(Rectangle rect)
    {
      __sklib_rectangle __skparam__rect;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__start_reading_text__rectangle(__skparam__rect);
    }
    /// <summary>
    /// Start reading text in the current window within the bounds of the supplied rectangle. The text will start with an initial value.
    /// </summary>
    /// <param name="rect"> The area where the text will be entered.</param>
    /// <param name="initialText"> The initial text, which may be edited by the user.</param>
    public static void StartReadingText(Rectangle rect, string initialText)
    {
      __sklib_rectangle __skparam__rect;
      __sklib_string __skparam__initial_text;
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__initial_text = __skadapter__to_sklib_string(initialText);
      __sklib__start_reading_text__rectangle__string(__skparam__rect, __skparam__initial_text);
    __skadapter__free__sklib_string(ref __skparam__initial_text);
    }
    /// <summary>
    /// Start reading text in the window within the bounds of the supplied rectangle.
    /// </summary>
    /// <param name="wind"> The window where the text will be entered</param>
    /// <param name="rect"> The area where the text will be entered.</param>
    public static void StartReadingText(Window wind, Rectangle rect)
    {
      __sklib_ptr __skparam__wind;
      __sklib_rectangle __skparam__rect;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __sklib__start_reading_text__window__rectangle(__skparam__wind, __skparam__rect);
    }
    /// <summary>
    /// Start reading text in the window within the bounds of the supplied rectangle. The text will start with an initial value.
    /// </summary>
    /// <param name="wind"> The window where the text will be entered</param>
    /// <param name="rect"> The area where the text will be entered.</param>
    /// <param name="initialText"> The initial text, which may be edited by the user.</param>
    public static void StartReadingText(Window wind, Rectangle rect, string initialText)
    {
      __sklib_ptr __skparam__wind;
      __sklib_rectangle __skparam__rect;
      __sklib_string __skparam__initial_text;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__initial_text = __skadapter__to_sklib_string(initialText);
      __sklib__start_reading_text__window__rectangle__string(__skparam__wind, __skparam__rect, __skparam__initial_text);
    __skadapter__free__sklib_string(ref __skparam__initial_text);
    }
    /// <summary>
    /// Did the user press escape and cancel the enterring of text?
    /// </summary>
    /// <returns>True when the use has cancelled text entry</returns>
    public static bool TextEntryCancelled()
    {
      int __skreturn;
      __skreturn = __sklib__text_entry_cancelled();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Did the user press escape and cancel the enterring of text?
    /// </summary>
    /// <param name="wind"> The window to check</param>
    /// <returns>True when the use has cancelled text entry</returns>
    public static bool TextEntryCancelled(Window wind)
    {
      __sklib_ptr __skparam__wind;
      int __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skreturn = __sklib__text_entry_cancelled__window(__skparam__wind);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// The text the user has currently enterred on the current window.
    /// </summary>
    /// <returns>The user's text entry</returns>
    public static string TextInput()
    {
      __sklib_string __skreturn;
      __skreturn = __sklib__text_input();
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// The text the user has currently enterred on the current window.
    /// </summary>
    /// <param name="wind"> The window to check</param>
    /// <returns>The user's text entry</returns>
    public static string TextInput(Window wind)
    {
      __sklib_ptr __skparam__wind;
      __sklib_string __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skreturn = __sklib__text_input__window(__skparam__wind);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Create and return a new Timer. The timer will not be started, and will have an initial 'ticks' of 0.
    /// </summary>
    /// <param name="name"> The name of the timer for resource tracking</param>
    /// <returns>A new timer.</returns>
    public static Timer CreateTimer(string name)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__create_timer__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_timer(__skreturn);
    }
    /// <summary>
    /// Free all of timers that have been created.
    /// </summary>
    public static void FreeAllTimers()
    {
      __sklib__free_all_timers();
    }
    /// <summary>
    /// Free the memory used to store this timer.
    /// </summary>
    /// <param name="toFree"> The time to be released.</param>
    public static void FreeTimer(Timer toFree)
    {
      __sklib_ptr __skparam__to_free;
      __skparam__to_free = __skadapter__to_sklib_timer(toFree);
      __sklib__free_timer__timer(__skparam__to_free);
    }
    /// <summary>
    /// Checks if SplashKit has a timer with the indicated name.
    /// </summary>
    /// <param name="name"> The name of the timer</param>
    /// <returns>True if SplashKit has created a timer with that name.</returns>
    public static bool HasTimer(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__has_timer__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Pause the timer, getting ticks from a paused timer will continue to return the same time.
    /// </summary>
    /// <param name="name"> The name of the timer</param>
    public static void PauseTimer(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__pause_timer__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Pause the timer, getting ticks from a paused timer will continue to return the same time.
    /// </summary>
    /// <param name="toPause"> The timer</param>
    public static void PauseTimer(Timer toPause)
    {
      __sklib_ptr __skparam__to_pause;
      __skparam__to_pause = __skadapter__to_sklib_timer(toPause);
      __sklib__pause_timer__timer(__skparam__to_pause);
    }
    /// <summary>
    /// Resets the named timer
    /// </summary>
    /// <param name="name"> The name of the timer</param>
    public static void ResetTimer(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__reset_timer__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Resets the time of a given timer
    /// </summary>
    /// <param name="tmr"> The timer</param>
    public static void ResetTimer(Timer tmr)
    {
      __sklib_ptr __skparam__tmr;
      __skparam__tmr = __skadapter__to_sklib_timer(tmr);
      __sklib__reset_timer__timer(__skparam__tmr);
    }
    /// <summary>
    /// Resumes the named timer.
    /// </summary>
    /// <param name="name"> The name of the timer</param>
    public static void ResumeTimer(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__resume_timer__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Resumes a paused timer.
    /// </summary>
    /// <param name="toResume"> The timer</param>
    public static void ResumeTimer(Timer toResume)
    {
      __sklib_ptr __skparam__to_resume;
      __skparam__to_resume = __skadapter__to_sklib_timer(toResume);
      __sklib__resume_timer__timer(__skparam__to_resume);
    }
    /// <summary>
    /// Start a timer. The timer will then start recording the time that has passed. You can check how long has past since the timer was started using the `timer_ticks` function.
    /// </summary>
    /// <param name="name"> The name of the timer</param>
    public static void StartTimer(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__start_timer__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Start a timer. The timer will then start recording the time that has passed. You can check how long has past since the timer was started using the `timer_ticks` function.
    /// </summary>
    /// <param name="toStart"> The timer</param>
    public static void StartTimer(Timer toStart)
    {
      __sklib_ptr __skparam__to_start;
      __skparam__to_start = __skadapter__to_sklib_timer(toStart);
      __sklib__start_timer__timer(__skparam__to_start);
    }
    /// <summary>
    /// Stop the timer. The time is reset to 0 and you must recall start to begin the timer ticking again.
    /// </summary>
    /// <param name="name"> The name of the timer</param>
    public static void StopTimer(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__stop_timer__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Stop the timer. The time is reset to 0 and you must recall start to begin the timer ticking again.
    /// </summary>
    /// <param name="toStop"> The timer</param>
    public static void StopTimer(Timer toStop)
    {
      __sklib_ptr __skparam__to_stop;
      __skparam__to_stop = __skadapter__to_sklib_timer(toStop);
      __sklib__stop_timer__timer(__skparam__to_stop);
    }
    /// <summary>
    /// Get the timer created with the indicated name.
    /// </summary>
    /// <param name="name"> The name of the timer to fetch</param>
    /// <returns>Returns the timer fetched from SplashKit</returns>
    public static Timer TimerNamed(string name)
    {
      __sklib_string __skparam__name;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__timer_named__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_timer(__skreturn);
    }
    /// <summary>
    /// Indicates if the timer is paused.
    /// </summary>
    /// <param name="name"> The name of the timer</param>
    /// <returns>True if the timer is paused</returns>
    public static bool TimerPaused(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__timer_paused__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Indicates if the timer is paused.
    /// </summary>
    /// <param name="toGet"> The timer</param>
    /// <returns>True if the timer is paused</returns>
    public static bool TimerPaused(Timer toGet)
    {
      __sklib_ptr __skparam__to_get;
      int __skreturn;
      __skparam__to_get = __skadapter__to_sklib_timer(toGet);
      __skreturn = __sklib__timer_paused__timer(__skparam__to_get);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Indicates if the timer is started.
    /// </summary>
    /// <param name="name"> The name of the timer</param>
    /// <returns>True if the timer has been started</returns>
    public static bool TimerStarted(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__timer_started__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Indicates if the timer is started.
    /// </summary>
    /// <param name="toGet"> The timer</param>
    /// <returns>True if the timer has been started</returns>
    public static bool TimerStarted(Timer toGet)
    {
      __sklib_ptr __skparam__to_get;
      int __skreturn;
      __skparam__to_get = __skadapter__to_sklib_timer(toGet);
      __skreturn = __sklib__timer_started__timer(__skparam__to_get);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Gets the number of ticks (milliseconds) that have passed since the timer was started/reset. When paused the timer's ticks will not advance until the timer is once again resumed.
    /// </summary>
    /// <param name="name"> The name of the Timer</param>
    /// <returns>The number of milliseconds that have passed since the timer was created (excluding the time the timer was paused)</returns>
    public static uint TimerTicks(string name)
    {
      __sklib_string __skparam__name;
      uint __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__timer_ticks__string(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_unsigned_int(__skreturn);
    }
    /// <summary>
    /// Gets the number of ticks (milliseconds) that have passed since the timer was started/reset. When paused the timer's ticks will not advance until the timer is once again resumed.
    /// </summary>
    /// <param name="toGet"> The timer</param>
    /// <returns>The number of milliseconds that have passed since the timer was created (excluding the time the timer was paused)</returns>
    public static uint TimerTicks(Timer toGet)
    {
      __sklib_ptr __skparam__to_get;
      uint __skreturn;
      __skparam__to_get = __skadapter__to_sklib_timer(toGet);
      __skreturn = __sklib__timer_ticks__timer(__skparam__to_get);
      return __skadapter__to_unsigned_int(__skreturn);
    }
    /// <summary>
    /// Draw a triangle onto the current window.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    public static void DrawTriangle(Color clr, Triangle tri)
    {
      __sklib_color __skparam__clr;
      __sklib_triangle __skparam__tri;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __sklib__draw_triangle__color__triangle_ref(__skparam__clr, __skparam__tri);
    }
    /// <summary>
    /// Draw a triangle using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawTriangle(Color clr, Triangle tri, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_triangle __skparam__tri;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_triangle__color__triangle_ref__drawing_options(__skparam__clr, __skparam__tri, __skparam__opts);
    }
    /// <summary>
    /// Draw a triangle to the current window.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the window to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the window to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the window to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the window to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the window to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the window to the third point of the triangle</param>
    public static void DrawTriangle(Color clr, double x1, double y1, double x2, double y2, double x3, double y3)
    {
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __sklib__draw_triangle__color__double__double__double__double__double__double(__skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3);
    }
    /// <summary>
    /// Draw a triangle using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap/window to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap/window to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap/window to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap/window to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap/window to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap/window to the third point of the triangle</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawTriangle(Color clr, double x1, double y1, double x2, double y2, double x3, double y3, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_triangle__color__double__double__double__double__double__double__drawing_options(__skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3, __skparam__opts);
    }
    /// <summary>
    /// Draw a triangle on a given bitmap, using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The bitmap which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    public static void DrawTriangleOnBitmap(Bitmap destination, Color clr, Triangle tri)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_triangle __skparam__tri;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __sklib__draw_triangle_on_bitmap__bitmap__color__triangle_ref(__skparam__destination, __skparam__clr, __skparam__tri);
    }
    /// <summary>
    /// Draw a triangle on a given bitmap, using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The bitmap which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawTriangleOnBitmap(Bitmap destination, Color clr, Triangle tri, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_triangle __skparam__tri;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_triangle_on_bitmap__bitmap__color__triangle_ref__drawing_options(__skparam__destination, __skparam__clr, __skparam__tri, __skparam__opts);
    }
    /// <summary>
    /// Draw a triangle to the given bitmap.
    /// </summary>
    /// <param name="destination"> The bitmap which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap to the third point of the triangle</param>
    public static void DrawTriangleOnBitmap(Bitmap destination, Color clr, double x1, double y1, double x2, double y2, double x3, double y3)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __sklib__draw_triangle_on_bitmap__bitmap__color__double__double__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3);
    }
    /// <summary>
    /// Draw a triangle to the given bitmap, using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The bitmap which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap/bitmap to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap/bitmap to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap/bitmap to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap/bitmap to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap/bitmap to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap/bitmap to the third point of the triangle</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawTriangleOnBitmap(Bitmap destination, Color clr, double x1, double y1, double x2, double y2, double x3, double y3, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_triangle_on_bitmap__bitmap__color__double__double__double__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3, __skparam__opts);
    }
    /// <summary>
    /// Draw a triangle on a given window, using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The window which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    public static void DrawTriangleOnWindow(Window destination, Color clr, Triangle tri)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_triangle __skparam__tri;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __sklib__draw_triangle_on_window__window__color__triangle_ref(__skparam__destination, __skparam__clr, __skparam__tri);
    }
    /// <summary>
    /// Draw a triangle on a given window, using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The window which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawTriangleOnWindow(Window destination, Color clr, Triangle tri, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_triangle __skparam__tri;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_triangle_on_window__window__color__triangle_ref__drawing_options(__skparam__destination, __skparam__clr, __skparam__tri, __skparam__opts);
    }
    /// <summary>
    /// Draw a triangle to the given window.
    /// </summary>
    /// <param name="destination"> The window which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the window to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the window to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the window to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the window to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the window to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the window to the third point of the triangle</param>
    public static void DrawTriangleOnWindow(Window destination, Color clr, double x1, double y1, double x2, double y2, double x3, double y3)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __sklib__draw_triangle_on_window__window__color__double__double__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3);
    }
    /// <summary>
    /// Draw a triangle to the given window, using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The window which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap/window to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap/window to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap/window to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap/window to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap/window to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap/window to the third point of the triangle</param>
    /// <param name="opts"> The drawing options</param>
    public static void DrawTriangleOnWindow(Window destination, Color clr, double x1, double y1, double x2, double y2, double x3, double y3, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__draw_triangle_on_window__window__color__double__double__double__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3, __skparam__opts);
    }
    /// <summary>
    /// Draw a triangle onto the current window.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    public static void FillTriangle(Color clr, Triangle tri)
    {
      __sklib_color __skparam__clr;
      __sklib_triangle __skparam__tri;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __sklib__fill_triangle__color__triangle_ref(__skparam__clr, __skparam__tri);
    }
    /// <summary>
    /// Fill a triangle using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillTriangle(Color clr, Triangle tri, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      __sklib_triangle __skparam__tri;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_triangle__color__triangle_ref__drawing_options(__skparam__clr, __skparam__tri, __skparam__opts);
    }
    /// <summary>
    /// Fills a triangle on the current window.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the window to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the window to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the window to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the window to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the window to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the window to the third point of the triangle</param>
    public static void FillTriangle(Color clr, double x1, double y1, double x2, double y2, double x3, double y3)
    {
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __sklib__fill_triangle__color__double__double__double__double__double__double(__skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3);
    }
    /// <summary>
    /// Fills a triangle using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap/window to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap/window to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap/window to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap/window to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap/window to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap/window to the third point of the triangle</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillTriangle(Color clr, double x1, double y1, double x2, double y2, double x3, double y3, DrawingOptions opts)
    {
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __sklib_drawing_options __skparam__opts;
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_triangle__color__double__double__double__double__double__double__drawing_options(__skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3, __skparam__opts);
    }
    /// <summary>
    /// Fill a triangle on a given bitmap
    /// </summary>
    /// <param name="destination"> The bitmap which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    public static void FillTriangleOnBitmap(Bitmap destination, Color clr, Triangle tri)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_triangle __skparam__tri;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __sklib__fill_triangle_on_bitmap__bitmap__color__triangle_ref(__skparam__destination, __skparam__clr, __skparam__tri);
    }
    /// <summary>
    /// Fill a triangle on a given bitmap, using given drawing options
    /// </summary>
    /// <param name="destination"> The bitmap which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillTriangleOnBitmap(Bitmap destination, Color clr, Triangle tri, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_triangle __skparam__tri;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_triangle_on_bitmap__bitmap__color__triangle_ref__drawing_options(__skparam__destination, __skparam__clr, __skparam__tri, __skparam__opts);
    }
    /// <summary>
    /// Fill a triangle on a given bitmap
    /// </summary>
    /// <param name="destination"> The bitmap which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap to the third point of the triangle</param>
    public static void FillTriangleOnBitmap(Bitmap destination, Color clr, double x1, double y1, double x2, double y2, double x3, double y3)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __sklib__fill_triangle_on_bitmap__bitmap__color__double__double__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3);
    }
    /// <summary>
    /// Fill a triangle on a given bitmap, using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The bitmap which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap/bitmap to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap/bitmap to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap/bitmap to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap/bitmap to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap/bitmap to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap/bitmap to the third point of the triangle</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillTriangleOnBitmap(Bitmap destination, Color clr, double x1, double y1, double x2, double y2, double x3, double y3, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_bitmap(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_triangle_on_bitmap__bitmap__color__double__double__double__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3, __skparam__opts);
    }
    /// <summary>
    /// Fill a triangle on a given window
    /// </summary>
    /// <param name="destination"> The window which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    public static void FillTriangleOnWindow(Window destination, Color clr, Triangle tri)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_triangle __skparam__tri;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __sklib__fill_triangle_on_window__window__color__triangle_ref(__skparam__destination, __skparam__clr, __skparam__tri);
    }
    /// <summary>
    /// Fill a triangle on a given window, using given drawing options
    /// </summary>
    /// <param name="destination"> The window which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillTriangleOnWindow(Window destination, Color clr, Triangle tri, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      __sklib_triangle __skparam__tri;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_triangle_on_window__window__color__triangle_ref__drawing_options(__skparam__destination, __skparam__clr, __skparam__tri, __skparam__opts);
    }
    /// <summary>
    /// Fill a triangle on a given window
    /// </summary>
    /// <param name="destination"> The window which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the window to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the window to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the window to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the window to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the window to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the window to the third point of the triangle</param>
    public static void FillTriangleOnWindow(Window destination, Color clr, double x1, double y1, double x2, double y2, double x3, double y3)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __sklib__fill_triangle_on_window__window__color__double__double__double__double__double__double(__skparam__destination, __skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3);
    }
    /// <summary>
    /// Fill a triangle on a given window, using the supplied drawing options.
    /// </summary>
    /// <param name="destination"> The window which the triangle will be drawn on.</param>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap/window to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap/window to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap/window to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap/window to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap/window to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap/window to the third point of the triangle</param>
    /// <param name="opts"> The drawing options</param>
    public static void FillTriangleOnWindow(Window destination, Color clr, double x1, double y1, double x2, double y2, double x3, double y3, DrawingOptions opts)
    {
      __sklib_ptr __skparam__destination;
      __sklib_color __skparam__clr;
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __sklib_drawing_options __skparam__opts;
      __skparam__destination = __skadapter__to_sklib_window(destination);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __skparam__opts = __skadapter__to_sklib_drawing_options(opts);
      __sklib__fill_triangle_on_window__window__color__double__double__double__double__double__double__drawing_options(__skparam__destination, __skparam__clr, __skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3, __skparam__opts);
    }
    /// <summary>
    /// Return the barycenter of the triangle. This is one way of calculating the center point of a triangle.
    /// </summary>
    /// <param name="tri"> The triangle to get the center of</param>
    /// <returns>The point that is the barycenter of `tri`</returns>
    public static Point2D TriangleBarycenter(Triangle tri)
    {
      __sklib_triangle __skparam__tri;
      __sklib_point_2d __skreturn;
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skreturn = __sklib__triangle_barycenter__triangle_ref(__skparam__tri);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Generate a triangle from a set of points.
    /// </summary>
    /// <param name="p1"> The first point of the triangle</param>
    /// <param name="p2"> The second point of the triangle</param>
    /// <param name="p3"> The third point of the triangle</param>
    /// <returns>A triangle with the indicated points</returns>
    public static Triangle TriangleFrom(Point2D p1, Point2D p2, Point2D p3)
    {
      __sklib_point_2d __skparam__p1;
      __sklib_point_2d __skparam__p2;
      __sklib_point_2d __skparam__p3;
      __sklib_triangle __skreturn;
      __skparam__p1 = __skadapter__to_sklib_point_2d(p1);
      __skparam__p2 = __skadapter__to_sklib_point_2d(p2);
      __skparam__p3 = __skadapter__to_sklib_point_2d(p3);
      __skreturn = __sklib__triangle_from__point_2d_ref__point_2d_ref__point_2d_ref(__skparam__p1, __skparam__p2, __skparam__p3);
      return __skadapter__to_triangle(__skreturn);
    }
    /// <summary>
    /// Generate a triangle from a set of points.
    /// </summary>
    /// <param name="x1"> The x coordinate for the first point</param>
    /// <param name="y1"> The y coordinate for the first point</param>
    /// <param name="x2"> The x coordinate for the second point</param>
    /// <param name="y2"> The y coordinate for the second point</param>
    /// <param name="x3"> The x coordinate for the third point</param>
    /// <param name="y3"> The y coordinate for the third point</param>
    /// <returns>A triangle at the indicated points</returns>
    public static Triangle TriangleFrom(double x1, double y1, double x2, double y2, double x3, double y3)
    {
      double __skparam__x1;
      double __skparam__y1;
      double __skparam__x2;
      double __skparam__y2;
      double __skparam__x3;
      double __skparam__y3;
      __sklib_triangle __skreturn;
      __skparam__x1 = __skadapter__to_sklib_double(x1);
      __skparam__y1 = __skadapter__to_sklib_double(y1);
      __skparam__x2 = __skadapter__to_sklib_double(x2);
      __skparam__y2 = __skadapter__to_sklib_double(y2);
      __skparam__x3 = __skadapter__to_sklib_double(x3);
      __skparam__y3 = __skadapter__to_sklib_double(y3);
      __skreturn = __sklib__triangle_from__double__double__double__double__double__double(__skparam__x1, __skparam__y1, __skparam__x2, __skparam__y2, __skparam__x3, __skparam__y3);
      return __skadapter__to_triangle(__skreturn);
    }
    /// <summary>
    /// Returns true if the triangle intersects with the quad.
    /// </summary>
    /// <param name="tri"> The triangle to test</param>
    /// <param name="q"> The quad to test</param>
    /// <returns>True if the triangle and quad intersect</returns>
    public static bool TriangleQuadIntersect(Triangle tri, Quad q)
    {
      __sklib_triangle __skparam__tri;
      __sklib_quad __skparam__q;
      int __skreturn;
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skparam__q = __skadapter__to_sklib_quad(q);
      __skreturn = __sklib__triangle_quad_intersect__triangle_ref__quad_ref(__skparam__tri, __skparam__q);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Detects if a ray intersects a triangle.
    /// </summary>
    /// <param name="origin"> The starting point of the ray</param>
    /// <param name="heading"> The direction of the ray as a vector</param>
    /// <param name="tri"> The triangle to check for intersection</param>
    /// <returns>True if the ray intersects the triangle, false otherwise</returns>
    public static bool TriangleRayIntersection(Point2D origin, Vector2D heading, Triangle tri)
    {
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      __sklib_triangle __skparam__tri;
      int __skreturn;
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skreturn = __sklib__triangle_ray_intersection__point_2d_ref__vector_2d_ref__triangle_ref(__skparam__origin, __skparam__heading, __skparam__tri);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Detects if a ray intersects a triangle. If an intersection is found, the `hit_point` and `hit_distance` are set to the point of intersection and the distance from the ray's origin to the intersection point. If the ray's `origin` is contained within the triangle, `hit_point` is set to the `origin` and `hit_distance` is set to 0. If no intersection is found, `hit_point` and `hit_distance` are not modified.
    /// </summary>
    /// <param name="origin"> The starting point of the ray</param>
    /// <param name="heading"> The direction of the ray as a vector</param>
    /// <param name="tri"> The triangle to check for intersection</param>
    /// <param name="hitPoint"> The point to set to where the ray intersects the triangle</param>
    /// <param name="hitDistance"> The double to set to the distance from the ray's origin to the intersection point</param>
    /// <returns>True if the ray intersects the triangle, false otherwise</returns>
    public static bool TriangleRayIntersection(Point2D origin, Vector2D heading, Triangle tri, ref Point2D hitPoint, ref double hitDistance)
    {
      __sklib_point_2d __skparam__origin;
      __sklib_vector_2d __skparam__heading;
      __sklib_triangle __skparam__tri;
      __sklib_point_2d __skparam__hit_point;
      double __skparam__hit_distance;
      int __skreturn;
      __skparam__origin = __skadapter__to_sklib_point_2d(origin);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skparam__hit_point = __skadapter__to_sklib_point_2d(hitPoint);
      __skparam__hit_distance = __skadapter__to_sklib_double(hitDistance);
      __skreturn = __sklib__triangle_ray_intersection__point_2d_ref__vector_2d_ref__triangle_ref__point_2d_ref__double_ref(__skparam__origin, __skparam__heading, __skparam__tri, ref __skparam__hit_point, ref __skparam__hit_distance);
      hitPoint = __skadapter__to_point_2d(__skparam__hit_point);
      hitDistance = __skadapter__to_double(__skparam__hit_distance);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns true if the triangle intersects with the rectangle.
    /// </summary>
    /// <param name="tri"> The triangle to test</param>
    /// <param name="rect"> The rectangle to test</param>
    /// <returns>True if the triangle and rect intersect</returns>
    public static bool TriangleRectangleIntersect(Triangle tri, Rectangle rect)
    {
      __sklib_triangle __skparam__tri;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__triangle_rectangle_intersect__triangle_ref__rectangle_ref(__skparam__tri, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns a text description of the triangle.
    /// </summary>
    /// <param name="tri"> The triangle</param>
    /// <returns>A text description of the triangle.</returns>
    public static string TriangleToString(Triangle tri)
    {
      __sklib_triangle __skparam__tri;
      __sklib_string __skreturn;
      __skparam__tri = __skadapter__to_sklib_triangle(tri);
      __skreturn = __sklib__triangle_to_string__triangle_ref(__skparam__tri);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns true if the two triangles intersect.
    /// </summary>
    /// <param name="t1"> The first triangle</param>
    /// <param name="t2"> The other triangle</param>
    /// <returns>True if the two triangles intersect</returns>
    public static bool TrianglesIntersect(Triangle t1, Triangle t2)
    {
      __sklib_triangle __skparam__t1;
      __sklib_triangle __skparam__t2;
      int __skreturn;
      __skparam__t1 = __skadapter__to_sklib_triangle(t1);
      __skparam__t2 = __skadapter__to_sklib_triangle(t2);
      __skreturn = __sklib__triangles_intersect__triangle_ref__triangle_ref(__skparam__t1, __skparam__t2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Gets the number of milliseconds that have passed since the program was started.
    /// </summary>
    /// <returns>The number of milliseconds passed</returns>
    public static uint CurrentTicks()
    {
      uint __skreturn;
      __skreturn = __sklib__current_ticks();
      return __skadapter__to_unsigned_int(__skreturn);
    }
    /// <summary>
    /// Puts the program to sleep for a specified number of milliseconds. If this is larger than 1 second, SplashKit will check to see if the user tries to quit during the delay. If the user does quit, the delay function returns without waiting.
    /// </summary>
    /// <param name="milliseconds"> The number of milliseconds to wait</param>
    public static void Delay(int milliseconds)
    {
      int __skparam__milliseconds;
      __skparam__milliseconds = __skadapter__to_sklib_int(milliseconds);
      __sklib__delay__int(__skparam__milliseconds);
    }
    /// <summary>
    /// Display a dialog to the screen with a message for the user.
    /// </summary>
    /// <param name="title"> The title of the dialog window.</param>
    /// <param name="msg"> The message for the dialog window.</param>
    /// <param name="outputFont"> The font for the dialog text</param>
    /// <param name="fontSize"> The size of the font for the dialog text</param>
    public static void DisplayDialog(string title, string msg, Font outputFont, int fontSize)
    {
      __sklib_string __skparam__title;
      __sklib_string __skparam__msg;
      __sklib_ptr __skparam__output_font;
      int __skparam__font_size;
      __skparam__title = __skadapter__to_sklib_string(title);
      __skparam__msg = __skadapter__to_sklib_string(msg);
      __skparam__output_font = __skadapter__to_sklib_font(outputFont);
      __skparam__font_size = __skadapter__to_sklib_int(fontSize);
      __sklib__display_dialog__string_ref__string_ref__font__int(__skparam__title, __skparam__msg, __skparam__output_font, __skparam__font_size);
    __skadapter__free__sklib_string(ref __skparam__title);
    __skadapter__free__sklib_string(ref __skparam__msg);
    }
    /// <summary>
    /// Return a SplashKit resource of `resource_kind` with name `filename` as a string.
    /// </summary>
    /// <param name="filename"> The filename of the resource.</param>
    /// <param name="kind"> The kind of resource.</param>
    /// <returns>The file loaded into a string.</returns>
    public static string FileAsString(string filename, ResourceKind kind)
    {
      __sklib_string __skparam__filename;
      int __skparam__kind;
      __sklib_string __skreturn;
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __skparam__kind = __skadapter__to_sklib_resource_kind(kind);
      __skreturn = __sklib__file_as_string__string__resource_kind(__skparam__filename, __skparam__kind);
    __skadapter__free__sklib_string(ref __skparam__filename);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Calculates the angle from one vector to another.
    /// </summary>
    /// <param name="v1"> The first vector</param>
    /// <param name="v2"> The second vector</param>
    /// <returns>The angle of the line from the end of `v1` to the end of `v2`</returns>
    public static double AngleBetween(Vector2D v1, Vector2D v2)
    {
      __sklib_vector_2d __skparam__v1;
      __sklib_vector_2d __skparam__v2;
      double __skreturn;
      __skparam__v1 = __skadapter__to_sklib_vector_2d(v1);
      __skparam__v2 = __skadapter__to_sklib_vector_2d(v2);
      __skreturn = __sklib__angle_between__vector_2d_ref__vector_2d_ref(__skparam__v1, __skparam__v2);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Calculates the dot product (scalar product) between the two vector parameters provided (`v1` and `v2`). It returns the result as a scalar value.  If the result is 0.0 it means that the vectors are orthogonal (at right angles to each other). If `v1` and `v2` are unit vectors (length of 1.0) and the dot product is 1.0, it means that `v1` and `v2` vectors are parallel.
    /// </summary>
    /// <param name="v1"> The first vector</param>
    /// <param name="v2"> The other vector</param>
    /// <returns>The dot product of `v1` . `v2`</returns>
    public static double DotProduct(Vector2D v1, Vector2D v2)
    {
      __sklib_vector_2d __skparam__v1;
      __sklib_vector_2d __skparam__v2;
      double __skreturn;
      __skparam__v1 = __skadapter__to_sklib_vector_2d(v1);
      __skparam__v2 = __skadapter__to_sklib_vector_2d(v2);
      __skreturn = __sklib__dot_product__vector_2d_ref__vector_2d_ref(__skparam__v1, __skparam__v2);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Returns if the vector is a null/zero vector -- having no size or direction.
    /// </summary>
    /// <param name="v"> The vector</param>
    /// <returns>True if `v` has no magnitude.</returns>
    public static bool IsZeroVector(Vector2D v)
    {
      __sklib_vector_2d __skparam__v;
      int __skreturn;
      __skparam__v = __skadapter__to_sklib_vector_2d(v);
      __skreturn = __sklib__is_zero_vector__vector_2d_ref(__skparam__v);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Casts a ray in a heading and returns true is it intersects with a line
    /// </summary>
    /// <param name="fromPt"> The origin of the ray</param>
    /// <param name="heading"> The direction the ray is heading (as a `vector_2d`)</param>
    /// <param name="l"> The line to be checked</param>
    /// <param name="pt"> Outputs the point where the line and ray intersect</param>
    /// <returns>True if the line and ray will intersect, in which case the value of `pt` will be changed to be the point where the intersection occurs.</returns>
    public static bool RayIntersectionPoint(Point2D fromPt, Vector2D heading, Line l, ref Point2D pt)
    {
      __sklib_point_2d __skparam__from_pt;
      __sklib_vector_2d __skparam__heading;
      __sklib_line __skparam__l;
      __sklib_point_2d __skparam__pt;
      int __skreturn;
      __skparam__from_pt = __skadapter__to_sklib_point_2d(fromPt);
      __skparam__heading = __skadapter__to_sklib_vector_2d(heading);
      __skparam__l = __skadapter__to_sklib_line(l);
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skreturn = __sklib__ray_intersection_point__point_2d_ref__vector_2d_ref__line_ref__point_2d_ref(__skparam__from_pt, __skparam__heading, __skparam__l, ref __skparam__pt);
      pt = __skadapter__to_point_2d(__skparam__pt);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the unit vector of the parameter vector (v). The unit vector has a magnitude of 1, resulting in a vector that indicates the direction of the original vector.
    /// </summary>
    /// <param name="v"> The vector</param>
    /// <returns>The unit vector of `v`</returns>
    public static Vector2D UnitVector(Vector2D v)
    {
      __sklib_vector_2d __skparam__v;
      __sklib_vector_2d __skreturn;
      __skparam__v = __skadapter__to_sklib_vector_2d(v);
      __skreturn = __sklib__unit_vector__vector_2d_ref(__skparam__v);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Adds the two passed in vectors returns the result as new `vector_2d`.
    /// </summary>
    /// <param name="v1"> The first vector.</param>
    /// <param name="v2"> The other vector.</param>
    /// <returns>The result of adding the movements of the two vectors together.</returns>
    public static Vector2D VectorAdd(Vector2D v1, Vector2D v2)
    {
      __sklib_vector_2d __skparam__v1;
      __sklib_vector_2d __skparam__v2;
      __sklib_vector_2d __skreturn;
      __skparam__v1 = __skadapter__to_sklib_vector_2d(v1);
      __skparam__v2 = __skadapter__to_sklib_vector_2d(v2);
      __skreturn = __sklib__vector_add__vector_2d_ref__vector_2d_ref(__skparam__v1, __skparam__v2);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Calculates the angle of a vector
    /// </summary>
    /// <param name="v"> The vector</param>
    /// <returns>The angle of the vector in degrees</returns>
    public static double VectorAngle(Vector2D v)
    {
      __sklib_vector_2d __skparam__v;
      double __skreturn;
      __skparam__v = __skadapter__to_sklib_vector_2d(v);
      __skreturn = __sklib__vector_angle__vector_2d(__skparam__v);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Returns a `vector_2d` from the supplied angle and distance.
    /// </summary>
    /// <param name="angle"> The angle in degrees</param>
    /// <param name="magnitude"> The length of the vector</param>
    /// <returns>A vector that will move things at that angle and magnitude</returns>
    public static Vector2D VectorFromAngle(double angle, double magnitude)
    {
      double __skparam__angle;
      double __skparam__magnitude;
      __sklib_vector_2d __skreturn;
      __skparam__angle = __skadapter__to_sklib_double(angle);
      __skparam__magnitude = __skadapter__to_sklib_double(magnitude);
      __skreturn = __sklib__vector_from_angle__double__double(__skparam__angle, __skparam__magnitude);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a vector that points from the start to the end of a line.
    /// </summary>
    /// <param name="l"> The line</param>
    /// <returns>A vector that will move things from the start to the end of the line</returns>
    public static Vector2D VectorFromLine(Line l)
    {
      __sklib_line __skparam__l;
      __sklib_vector_2d __skreturn;
      __skparam__l = __skadapter__to_sklib_line(l);
      __skreturn = __sklib__vector_from_line__line_ref(__skparam__l);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a vector from a point to a rectangle.
    /// </summary>
    /// <param name="pt"> The point</param>
    /// <param name="rect"> The rectangle</param>
    /// <returns>A vector representing the distance and direction from `pt` to `rect`</returns>
    public static Vector2D VectorFromPointToRect(Point2D pt, Rectangle rect)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_rectangle __skparam__rect;
      __sklib_vector_2d __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__vector_from_point_to_rect__point_2d_ref__rectangle_ref(__skparam__pt, __skparam__rect);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns true if the resulting vector would end in the rectangle if placed at the origin.
    /// </summary>
    /// <param name="v"> The vector</param>
    /// <param name="rect"> The rectangle</param>
    /// <returns>True if the vector would end in the rectangle</returns>
    public static bool VectorInRect(Vector2D v, Rectangle rect)
    {
      __sklib_vector_2d __skparam__v;
      __sklib_rectangle __skparam__rect;
      int __skreturn;
      __skparam__v = __skadapter__to_sklib_vector_2d(v);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skreturn = __sklib__vector_in_rect__vector_2d_ref__rectangle_ref(__skparam__v, __skparam__rect);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns a new Vector that is an inverted version of the parameter vector (v). In other words, the -/+ sign of the x and y values are changed.
    /// </summary>
    /// <param name="v"> The vector</param>
    /// <returns>The inverse (reverse) of `v`</returns>
    public static Vector2D VectorInvert(Vector2D v)
    {
      __sklib_vector_2d __skparam__v;
      __sklib_vector_2d __skreturn;
      __skparam__v = __skadapter__to_sklib_vector_2d(v);
      __skreturn = __sklib__vector_invert__vector_2d_ref(__skparam__v);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a scaled vector that ensures the new vector points in the same direction as v, but has a magnitude that is limited to the length specified in the limit prameter.
    /// </summary>
    /// <param name="v"> The vector</param>
    /// <param name="limit"> Its maximum magnitude</param>
    /// <returns>A new vector in the same direction as v, but with a magnitude that is less than or equal to the limit.</returns>
    public static Vector2D VectorLimit(Vector2D v, double limit)
    {
      __sklib_vector_2d __skparam__v;
      double __skparam__limit;
      __sklib_vector_2d __skreturn;
      __skparam__v = __skadapter__to_sklib_vector_2d(v);
      __skparam__limit = __skadapter__to_sklib_double(limit);
      __skreturn = __sklib__vector_limit__vector_2d_ref__double(__skparam__v, __skparam__limit);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the magnitude (or "length") of the vector.
    /// </summary>
    /// <param name="v"> The vector</param>
    /// <returns>Its magnitude</returns>
    public static double VectorMagnitude(Vector2D v)
    {
      __sklib_vector_2d __skparam__v;
      double __skreturn;
      __skparam__v = __skadapter__to_sklib_vector_2d(v);
      __skreturn = __sklib__vector_magnitude__vector_2d_ref(__skparam__v);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Returns the squared magnitude (or "length") of the vector.
    /// </summary>
    /// <param name="v"> The vector</param>
    /// <returns>Its squared magnitude</returns>
    public static double VectorMagnitudeSquared(Vector2D v)
    {
      __sklib_vector_2d __skparam__v;
      double __skreturn;
      __skparam__v = __skadapter__to_sklib_vector_2d(v);
      __skreturn = __sklib__vector_magnitude_squared__vector_2d_ref(__skparam__v);
      return __skadapter__to_double(__skreturn);
    }
    /// <summary>
    /// Multiplies the vector by the passed in value.
    /// </summary>
    /// <param name="v1"> The original vector</param>
    /// <param name="s"> The amount to multiply by</param>
    /// <returns>A new vector</returns>
    public static Vector2D VectorMultiply(Vector2D v1, double s)
    {
      __sklib_vector_2d __skparam__v1;
      double __skparam__s;
      __sklib_vector_2d __skreturn;
      __skparam__v1 = __skadapter__to_sklib_vector_2d(v1);
      __skparam__s = __skadapter__to_sklib_double(s);
      __skreturn = __sklib__vector_multiply__vector_2d_ref__double(__skparam__v1, __skparam__s);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a new `vector_2d` that is perpendicular ("normal") to the parameter vector `v` provided. The concept of a "normal" vector is usually extracted from (or associated with) a line.  Note: when passed a zero or null vector (a vector with no magnitude or direction) then this function returns a zero/null vector.
    /// </summary>
    /// <param name="v"> The vector</param>
    /// <returns>The normal of `v`</returns>
    public static Vector2D VectorNormal(Vector2D v)
    {
      __sklib_vector_2d __skparam__v;
      __sklib_vector_2d __skreturn;
      __skparam__v = __skadapter__to_sklib_vector_2d(v);
      __skreturn = __sklib__vector_normal__vector_2d_ref(__skparam__v);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a vector to back one circle out of another, assuming the first circle was moving at a specified velocity.
    /// </summary>
    /// <param name="src"> The circle that is moving</param>
    /// <param name="bounds"> The area you want to move the circle out of</param>
    /// <param name="velocity"> The circle's velocity</param>
    /// <returns>A vector that can move the circle out of the bounds</returns>
    public static Vector2D VectorOutOfCircleFromCircle(Circle src, Circle bounds, Vector2D velocity)
    {
      __sklib_circle __skparam__src;
      __sklib_circle __skparam__bounds;
      __sklib_vector_2d __skparam__velocity;
      __sklib_vector_2d __skreturn;
      __skparam__src = __skadapter__to_sklib_circle(src);
      __skparam__bounds = __skadapter__to_sklib_circle(bounds);
      __skparam__velocity = __skadapter__to_sklib_vector_2d(velocity);
      __skreturn = __sklib__vector_out_of_circle_from_circle__circle_ref__circle_ref__vector_2d_ref(__skparam__src, __skparam__bounds, __skparam__velocity);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the vector out to move a point back out of a circle, given the point was moving at the specified velocity.
    /// </summary>
    /// <param name="pt"> The point that is moving</param>
    /// <param name="c"> The circle you want to move the point out of</param>
    /// <param name="velocity"> The point's velocity</param>
    /// <returns>A vector that can move the point out of the circle</returns>
    public static Vector2D VectorOutOfCircleFromPoint(Point2D pt, Circle c, Vector2D velocity)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_circle __skparam__c;
      __sklib_vector_2d __skparam__velocity;
      __sklib_vector_2d __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__velocity = __skadapter__to_sklib_vector_2d(velocity);
      __skreturn = __sklib__vector_out_of_circle_from_point__point_2d_ref__circle_ref__vector_2d_ref(__skparam__pt, __skparam__c, __skparam__velocity);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a vector that can be used to move a circle back out of a rectangle, given that the circle is moving at the specified velocity.
    /// </summary>
    /// <param name="c"> The circle that is moving</param>
    /// <param name="rect"> The area you wan to move the circle out of</param>
    /// <param name="velocity"> The circle's velocity</param>
    /// <returns>A vector that will move the circle out of the rectangle</returns>
    public static Vector2D VectorOutOfRectFromCircle(Circle c, Rectangle rect, Vector2D velocity)
    {
      __sklib_circle __skparam__c;
      __sklib_rectangle __skparam__rect;
      __sklib_vector_2d __skparam__velocity;
      __sklib_vector_2d __skreturn;
      __skparam__c = __skadapter__to_sklib_circle(c);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__velocity = __skadapter__to_sklib_vector_2d(velocity);
      __skreturn = __sklib__vector_out_of_rect_from_circle__circle_ref__rectangle_ref__vector_2d_ref(__skparam__c, __skparam__rect, __skparam__velocity);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Determines the vector needed to move back from point `pt` out of rectangle `rect` given the point was moving at the velocity specified.
    /// </summary>
    /// <param name="pt"> The point you want to move out of a rectangle</param>
    /// <param name="rect"> The rectangle to move out of</param>
    /// <param name="velocity"> The velocity of the point. This is used to determine where the point should return to.</param>
    /// <returns>A vector that can move the point outside of the rectangle.</returns>
    public static Vector2D VectorOutOfRectFromPoint(Point2D pt, Rectangle rect, Vector2D velocity)
    {
      __sklib_point_2d __skparam__pt;
      __sklib_rectangle __skparam__rect;
      __sklib_vector_2d __skparam__velocity;
      __sklib_vector_2d __skreturn;
      __skparam__pt = __skadapter__to_sklib_point_2d(pt);
      __skparam__rect = __skadapter__to_sklib_rectangle(rect);
      __skparam__velocity = __skadapter__to_sklib_vector_2d(velocity);
      __skreturn = __sklib__vector_out_of_rect_from_point__point_2d_ref__rectangle_ref__vector_2d_ref(__skparam__pt, __skparam__rect, __skparam__velocity);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns the vector needed to move rectangle `src` back out of rectangle `bounds` assuming the rectangle was moving at the velocity specified.
    /// </summary>
    /// <param name="src"> The rectangle you want to move.</param>
    /// <param name="bounds"> The area you want to move the rectangle out of</param>
    /// <param name="velocity"> The velocity of the `src` rectangle</param>
    /// <returns>A vector that can move the rectangle out of the bounds</returns>
    public static Vector2D VectorOutOfRectFromRect(Rectangle src, Rectangle bounds, Vector2D velocity)
    {
      __sklib_rectangle __skparam__src;
      __sklib_rectangle __skparam__bounds;
      __sklib_vector_2d __skparam__velocity;
      __sklib_vector_2d __skreturn;
      __skparam__src = __skadapter__to_sklib_rectangle(src);
      __skparam__bounds = __skadapter__to_sklib_rectangle(bounds);
      __skparam__velocity = __skadapter__to_sklib_vector_2d(velocity);
      __skreturn = __sklib__vector_out_of_rect_from_rect__rectangle_ref__rectangle_ref__vector_2d_ref(__skparam__src, __skparam__bounds, __skparam__velocity);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a `vector_2d` created from the difference from the `p1` to the second `p2` points (`Point2D`).
    /// </summary>
    /// <param name="start"> The starting point</param>
    /// <param name="endPt"> The ending point</param>
    /// <returns>A vector that will move things from the starting point to the ending point</returns>
    public static Vector2D VectorPointToPoint(Point2D start, Point2D endPt)
    {
      __sklib_point_2d __skparam__start;
      __sklib_point_2d __skparam__end_pt;
      __sklib_vector_2d __skreturn;
      __skparam__start = __skadapter__to_sklib_point_2d(start);
      __skparam__end_pt = __skadapter__to_sklib_point_2d(endPt);
      __skreturn = __sklib__vector_point_to_point__point_2d_ref__point_2d_ref(__skparam__start, __skparam__end_pt);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Subtracts the second vector parameter (`v2`) from the first vector (`v1`) and returns the result as new `vector_2d`.
    /// </summary>
    /// <param name="v1"> The first vector.</param>
    /// <param name="v2"> The other vector.</param>
    /// <returns>The result of subtracting the movements of `v2` from `v1`.</returns>
    public static Vector2D VectorSubtract(Vector2D v1, Vector2D v2)
    {
      __sklib_vector_2d __skparam__v1;
      __sklib_vector_2d __skparam__v2;
      __sklib_vector_2d __skreturn;
      __skparam__v1 = __skadapter__to_sklib_vector_2d(v1);
      __skparam__v2 = __skadapter__to_sklib_vector_2d(v2);
      __skreturn = __sklib__vector_subtract__vector_2d_ref__vector_2d_ref(__skparam__v1, __skparam__v2);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a new `vector_2d` using the x and y value of a `point_2d` parameter. This is a vector from the origin to that point.
    /// </summary>
    /// <param name="p1"> The point</param>
    /// <returns>A vector from the origin to `p1`</returns>
    public static Vector2D VectorTo(Point2D p1)
    {
      __sklib_point_2d __skparam__p1;
      __sklib_vector_2d __skreturn;
      __skparam__p1 = __skadapter__to_sklib_point_2d(p1);
      __skreturn = __sklib__vector_to__point_2d_ref(__skparam__p1);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Returns a vector to the indicated point.
    /// </summary>
    /// <param name="x"> The amount to move horizontally</param>
    /// <param name="y"> The amount to move vertically</param>
    /// <returns>A vector that will move things the indicated amount</returns>
    public static Vector2D VectorTo(double x, double y)
    {
      double __skparam__x;
      double __skparam__y;
      __sklib_vector_2d __skreturn;
      __skparam__x = __skadapter__to_sklib_double(x);
      __skparam__y = __skadapter__to_sklib_double(y);
      __skreturn = __sklib__vector_to__double__double(__skparam__x, __skparam__y);
      return __skadapter__to_vector_2d(__skreturn);
    }
    /// <summary>
    /// Get a text description of the `vector_2d`.
    /// </summary>
    /// <param name="v"> The vector</param>
    /// <returns>A string representation of the vector</returns>
    public static string VectorToString(Vector2D v)
    {
      __sklib_vector_2d __skparam__v;
      __sklib_string __skreturn;
      __skparam__v = __skadapter__to_sklib_vector_2d(v);
      __skreturn = __sklib__vector_to_string__vector_2d_ref(__skparam__v);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Determines if two vectors are the same.
    /// </summary>
    /// <param name="v1"> The first vector</param>
    /// <param name="v2"> The other vector</param>
    /// <returns>True if the two vectors are equal.</returns>
    public static bool VectorsEqual(Vector2D v1, Vector2D v2)
    {
      __sklib_vector_2d __skparam__v1;
      __sklib_vector_2d __skparam__v2;
      int __skreturn;
      __skparam__v1 = __skadapter__to_sklib_vector_2d(v1);
      __skparam__v2 = __skadapter__to_sklib_vector_2d(v2);
      __skreturn = __sklib__vectors_equal__vector_2d_ref__vector_2d(__skparam__v1, __skparam__v2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Determines if two vectors are not the same.
    /// </summary>
    /// <param name="v1"> The first vector</param>
    /// <param name="v2"> The other vector</param>
    /// <returns>True if the two vectors are different.</returns>
    public static bool VectorsNotEqual(Vector2D v1, Vector2D v2)
    {
      __sklib_vector_2d __skparam__v1;
      __sklib_vector_2d __skparam__v2;
      int __skreturn;
      __skparam__v1 = __skadapter__to_sklib_vector_2d(v1);
      __skparam__v2 = __skadapter__to_sklib_vector_2d(v2);
      __skreturn = __sklib__vectors_not_equal__vector_2d_ref__vector_2d(__skparam__v1, __skparam__v2);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Download an image from a web server and load it into SplashKit so that you can use it.
    /// </summary>
    /// <param name="name"> The name of the bitmap resource when it is loaded</param>
    /// <param name="url"> The URL path to the image resoure</param>
    /// <param name="port"> The port to connect to on the server</param>
    /// <returns>The bitmap that was loaded</returns>
    public static Bitmap DownloadBitmap(string name, string url, ushort port)
    {
      __sklib_string __skparam__name;
      __sklib_string __skparam__url;
      ushort __skparam__port;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__url = __skadapter__to_sklib_string(url);
      __skparam__port = __skadapter__to_sklib_unsigned_short(port);
      __skreturn = __sklib__download_bitmap__string_ref__string_ref__unsigned_short(__skparam__name, __skparam__url, __skparam__port);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__url);
      return __skadapter__to_bitmap(__skreturn);
    }
    /// <summary>
    /// Download a font from a web server and load it into SplashKit so that you can use it.
    /// </summary>
    /// <param name="name"> The name of the font resource when it is loaded</param>
    /// <param name="url"> The URL path to the font resoure</param>
    /// <param name="port"> The port to connect to on the server</param>
    /// <returns>The font that was loaded</returns>
    public static Font DownloadFont(string name, string url, ushort port)
    {
      __sklib_string __skparam__name;
      __sklib_string __skparam__url;
      ushort __skparam__port;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__url = __skadapter__to_sklib_string(url);
      __skparam__port = __skadapter__to_sklib_unsigned_short(port);
      __skreturn = __sklib__download_font__string_ref__string_ref__unsigned_short(__skparam__name, __skparam__url, __skparam__port);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__url);
      return __skadapter__to_font(__skreturn);
    }
    /// <summary>
    /// Download a music file from a web server and load it into SplashKit so that you can use it.
    /// </summary>
    /// <param name="name"> The name of the music resource when it is loaded</param>
    /// <param name="url"> The URL path to the music resoure</param>
    /// <param name="port"> The port to connect to on the server</param>
    /// <returns>The music that was loaded</returns>
    public static Music DownloadMusic(string name, string url, ushort port)
    {
      __sklib_string __skparam__name;
      __sklib_string __skparam__url;
      ushort __skparam__port;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__url = __skadapter__to_sklib_string(url);
      __skparam__port = __skadapter__to_sklib_unsigned_short(port);
      __skreturn = __sklib__download_music__string_ref__string_ref__unsigned_short(__skparam__name, __skparam__url, __skparam__port);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__url);
      return __skadapter__to_music(__skreturn);
    }
    /// <summary>
    /// Download a sound effect from a web server and load it into SplashKit so that you can use it.
    /// </summary>
    /// <param name="name"> The name of the sound effect resource when it is loaded</param>
    /// <param name="url"> The URL path to the sound effect resoure</param>
    /// <param name="port"> The port to connect to on the server</param>
    /// <returns>The sound effect that was loaded</returns>
    public static SoundEffect DownloadSoundEffect(string name, string url, ushort port)
    {
      __sklib_string __skparam__name;
      __sklib_string __skparam__url;
      ushort __skparam__port;
      __sklib_ptr __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__url = __skadapter__to_sklib_string(url);
      __skparam__port = __skadapter__to_sklib_unsigned_short(port);
      __skreturn = __sklib__download_sound_effect__string_ref__string_ref__unsigned_short(__skparam__name, __skparam__url, __skparam__port);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__url);
      return __skadapter__to_sound_effect(__skreturn);
    }
    /// <summary>
    /// Free the response resource.
    /// </summary>
    /// <param name="response"> The response to free</param>
    public static void FreeResponse(HttpResponse response)
    {
      __sklib_ptr __skparam__response;
      __skparam__response = __skadapter__to_sklib_http_response(response);
      __sklib__free_response__http_response(__skparam__response);
    }
    /// <summary>
    /// Make a get request to access a resource on the internet.
    /// </summary>
    /// <param name="url"> The path to the resource, for example http://splashkit.io</param>
    /// <param name="port"> The port on the server (80 for http, 443 for https)</param>
    /// <returns>The response with all of the data received</returns>
    public static HttpResponse HttpGet(string url, ushort port)
    {
      __sklib_string __skparam__url;
      ushort __skparam__port;
      __sklib_ptr __skreturn;
      __skparam__url = __skadapter__to_sklib_string(url);
      __skparam__port = __skadapter__to_sklib_unsigned_short(port);
      __skreturn = __sklib__http_get__string_ref__unsigned_short(__skparam__url, __skparam__port);
    __skadapter__free__sklib_string(ref __skparam__url);
      return __skadapter__to_http_response(__skreturn);
    }
    /// <summary>
    /// Post the supplied information to the indicated url with the given headers.
    /// </summary>
    /// <param name="url"> The url of the server to post the data to</param>
    /// <param name="port"> The port to connect to on the server</param>
    /// <param name="body"> The body of the message to post</param>
    /// <param name="headers"> The headers of the request</param>
    /// <returns>The response from the server</returns>
    public static HttpResponse HttpPost(string url, ushort port, string body, List<string> headers)
    {
      __sklib_string __skparam__url;
      ushort __skparam__port;
      __sklib_string __skparam__body;
      __sklib_vector_string __skparam__headers;
      __sklib_ptr __skreturn;
      __skparam__url = __skadapter__to_sklib_string(url);
      __skparam__port = __skadapter__to_sklib_unsigned_short(port);
      __skparam__body = __skadapter__to_sklib_string(body);
      __skparam__headers = __skadapter__to_sklib_vector_string(headers);
      __skreturn = __sklib__http_post__string_ref__unsigned_short__string_ref__vector_string_ref(__skparam__url, __skparam__port, __skparam__body, __skparam__headers);
    __skadapter__free__sklib_string(ref __skparam__url);
    __skadapter__free__sklib_string(ref __skparam__body);
    __skadapter__free__sklib_vector_string(ref __skparam__headers);
      return __skadapter__to_http_response(__skreturn);
    }
    /// <summary>
    /// Post the supplied information to the indicated url.
    /// </summary>
    /// <param name="url"> The url of the server to post the data to</param>
    /// <param name="port"> The port to connect to on the server</param>
    /// <param name="body"> The body of the message to post</param>
    /// <returns>The response from the server</returns>
    public static HttpResponse HttpPost(string url, ushort port, string body)
    {
      __sklib_string __skparam__url;
      ushort __skparam__port;
      __sklib_string __skparam__body;
      __sklib_ptr __skreturn;
      __skparam__url = __skadapter__to_sklib_string(url);
      __skparam__port = __skadapter__to_sklib_unsigned_short(port);
      __skparam__body = __skadapter__to_sklib_string(body);
      __skreturn = __sklib__http_post__string_ref__unsigned_short__string(__skparam__url, __skparam__port, __skparam__body);
    __skadapter__free__sklib_string(ref __skparam__url);
    __skadapter__free__sklib_string(ref __skparam__body);
      return __skadapter__to_http_response(__skreturn);
    }
    /// <summary>
    /// Read the HTTP response and convert it to text
    /// </summary>
    /// <param name="response"> The response from the server</param>
    /// <returns>The data from the response as text</returns>
    public static string HttpResponseToString(HttpResponse response)
    {
      __sklib_ptr __skparam__response;
      __sklib_string __skreturn;
      __skparam__response = __skadapter__to_sklib_http_response(response);
      __skreturn = __sklib__http_response_to_string__http_response(__skparam__response);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Save the HTTP response downloaded into a file.
    /// </summary>
    /// <param name="response"> The response from the server</param>
    /// <param name="path"> The path to the file where the response should be saved</param>
    public static void SaveResponseToFile(HttpResponse response, string path)
    {
      __sklib_ptr __skparam__response;
      __sklib_string __skparam__path;
      __skparam__response = __skadapter__to_sklib_http_response(response);
      __skparam__path = __skadapter__to_sklib_string(path);
      __sklib__save_response_to_file__http_response__string(__skparam__response, __skparam__path);
    __skadapter__free__sklib_string(ref __skparam__path);
    }
    /// <summary>
    /// Returns true if the given `web_sever` has pending requests.
    /// </summary>
    /// <param name="server"> The `web_server` to check for waiting requests.</param>
    /// <returns>Returns a `bool` denoting whether the `web_server` has pending requests.</returns>
    public static bool HasIncomingRequests(WebServer server)
    {
      __sklib_ptr __skparam__server;
      int __skreturn;
      __skparam__server = __skadapter__to_sklib_web_server(server);
      __skreturn = __sklib__has_incoming_requests__web_server(__skparam__server);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if a request wants to delete a given resource.
    /// </summary>
    /// <param name="request"> The request to check</param>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is a HTTP DELETE request for `path`</returns>
    public static bool IsDeleteRequestFor(HttpRequest request, string path)
    {
      __sklib_ptr __skparam__request;
      __sklib_string __skparam__path;
      int __skreturn;
      __skparam__request = __skadapter__to_sklib_http_request(request);
      __skparam__path = __skadapter__to_sklib_string(path);
      __skreturn = __sklib__is_delete_request_for__http_request__string_ref(__skparam__request, __skparam__path);
    __skadapter__free__sklib_string(ref __skparam__path);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if a request wants to get a given resource.
    /// </summary>
    /// <param name="request"> The request to check</param>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is a HTTP GET request for `path`</returns>
    public static bool IsGetRequestFor(HttpRequest request, string path)
    {
      __sklib_ptr __skparam__request;
      __sklib_string __skparam__path;
      int __skreturn;
      __skparam__request = __skadapter__to_sklib_http_request(request);
      __skparam__path = __skadapter__to_sklib_string(path);
      __skreturn = __sklib__is_get_request_for__http_request__string_ref(__skparam__request, __skparam__path);
    __skadapter__free__sklib_string(ref __skparam__path);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if a request wants to check options for given resource.
    /// </summary>
    /// <param name="request"> The request to check</param>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is a HTTP OPTIONS request for `path`</returns>
    public static bool IsOptionsRequestFor(HttpRequest request, string path)
    {
      __sklib_ptr __skparam__request;
      __sklib_string __skparam__path;
      int __skreturn;
      __skparam__request = __skadapter__to_sklib_http_request(request);
      __skparam__path = __skadapter__to_sklib_string(path);
      __skreturn = __sklib__is_options_request_for__http_request__string_ref(__skparam__request, __skparam__path);
    __skadapter__free__sklib_string(ref __skparam__path);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if a request wants to create (post) a given resource.
    /// </summary>
    /// <param name="request"> The request to check</param>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is a HTTP POST request for `path`</returns>
    public static bool IsPostRequestFor(HttpRequest request, string path)
    {
      __sklib_ptr __skparam__request;
      __sklib_string __skparam__path;
      int __skreturn;
      __skparam__request = __skadapter__to_sklib_http_request(request);
      __skparam__path = __skadapter__to_sklib_string(path);
      __skreturn = __sklib__is_post_request_for__http_request__string_ref(__skparam__request, __skparam__path);
    __skadapter__free__sklib_string(ref __skparam__path);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if a request wants to update (put) a given resource.
    /// </summary>
    /// <param name="request"> The request to check</param>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is a HTTP PUT request for `path`</returns>
    public static bool IsPutRequestFor(HttpRequest request, string path)
    {
      __sklib_ptr __skparam__request;
      __sklib_string __skparam__path;
      int __skreturn;
      __skparam__request = __skadapter__to_sklib_http_request(request);
      __skparam__path = __skadapter__to_sklib_string(path);
      __skreturn = __sklib__is_put_request_for__http_request__string_ref(__skparam__request, __skparam__path);
    __skadapter__free__sklib_string(ref __skparam__path);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if a request is after a given resource.
    /// </summary>
    /// <param name="request"> The request to check</param>
    /// <param name="method"> The kind of request</param>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is for the indicated method and path</returns>
    public static bool IsRequestFor(HttpRequest request, HttpMethod method, string path)
    {
      __sklib_ptr __skparam__request;
      int __skparam__method;
      __sklib_string __skparam__path;
      int __skreturn;
      __skparam__request = __skadapter__to_sklib_http_request(request);
      __skparam__method = __skadapter__to_sklib_http_method(method);
      __skparam__path = __skadapter__to_sklib_string(path);
      __skreturn = __sklib__is_request_for__http_request__http_method__string_ref(__skparam__request, __skparam__method, __skparam__path);
    __skadapter__free__sklib_string(ref __skparam__path);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Checks if a request wants to trace a given resource.
    /// </summary>
    /// <param name="request"> The request to check</param>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is a HTTP TRACE request for `path`</returns>
    public static bool IsTraceRequestFor(HttpRequest request, string path)
    {
      __sklib_ptr __skparam__request;
      __sklib_string __skparam__path;
      int __skreturn;
      __skparam__request = __skadapter__to_sklib_http_request(request);
      __skparam__path = __skadapter__to_sklib_string(path);
      __skreturn = __sklib__is_trace_request_for__http_request__string_ref(__skparam__request, __skparam__path);
    __skadapter__free__sklib_string(ref __skparam__path);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the next request on a given `web_server` instance
    /// </summary>
    /// <param name="server"> The `web_server` to get the `http_request` from.</param>
    /// <returns>Returns the next request on the given `web_server` instance.</returns>
    public static HttpRequest NextWebRequest(WebServer server)
    {
      __sklib_ptr __skparam__server;
      __sklib_ptr __skreturn;
      __skparam__server = __skadapter__to_sklib_web_server(server);
      __skreturn = __sklib__next_web_request__web_server(__skparam__server);
      return __skadapter__to_http_request(__skreturn);
    }
    /// <summary>
    /// Returns the body of the request.
    /// </summary>
    /// <param name="r"> A request object.</param>
    /// <returns>The body of the request.</returns>
    public static string RequestBody(HttpRequest r)
    {
      __sklib_ptr __skparam__r;
      __sklib_string __skreturn;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skreturn = __sklib__request_body__http_request(__skparam__r);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns true if the parameter exists in the query string.
    /// </summary>
    /// <param name="r"> A request object.</param>
    /// <param name="name"> The name of the parameter to check</param>
    /// <returns>True if the parameter exists in the user's request.</returns>
    public static bool RequestHasQueryParameter(HttpRequest r, string name)
    {
      __sklib_ptr __skparam__r;
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__request_has_query_parameter__http_request__string_ref(__skparam__r, __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the headers of the request.
    /// </summary>
    /// <param name="r"> A request object.</param>
    /// <returns>The headers of the request.</returns>
    public static List<string> RequestHeaders(HttpRequest r)
    {
      __sklib_ptr __skparam__r;
      __sklib_vector_string __skreturn;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skreturn = __sklib__request_headers__http_request(__skparam__r);
      return __skadapter__to_vector_string(__skreturn);
    }
    /// <summary>
    /// Returns the HTTP method of the client request.
    /// </summary>
    /// <param name="r"> A request object.</param>
    /// <returns>Returns the request method.</returns>
    public static HttpMethod RequestMethod(HttpRequest r)
    {
      __sklib_ptr __skparam__r;
      int __skreturn;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skreturn = __sklib__request_method__http_request(__skparam__r);
      return __skadapter__to_http_method(__skreturn);
    }
    /// <summary>
    /// Returns the value of a parameter from within the query string, or the supplied default if no matching parameter is found.
    /// </summary>
    /// <param name="r"> A request object.</param>
    /// <param name="name"> The name of the parameter to fetch</param>
    /// <param name="defaultValue"> The value to return if the named parameter is not in the query string.</param>
    /// <returns>Returns value of the parameter from the query string, or the default value if the parameter is not found.</returns>
    public static string RequestQueryParameter(HttpRequest r, string name, string defaultValue)
    {
      __sklib_ptr __skparam__r;
      __sklib_string __skparam__name;
      __sklib_string __skparam__default_value;
      __sklib_string __skreturn;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__default_value = __skadapter__to_sklib_string(defaultValue);
      __skreturn = __sklib__request_query_parameter__http_request__string_ref__string_ref(__skparam__r, __skparam__name, __skparam__default_value);
    __skadapter__free__sklib_string(ref __skparam__name);
    __skadapter__free__sklib_string(ref __skparam__default_value);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns the URI query string of the client request.
    /// </summary>
    /// <param name="r"> A request object.</param>
    /// <returns>Returns the requested URI queries in the form of a string.</returns>
    public static string RequestQueryString(HttpRequest r)
    {
      __sklib_ptr __skparam__r;
      __sklib_string __skreturn;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skreturn = __sklib__request_query_string__http_request(__skparam__r);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns the server URI of the client request.
    /// </summary>
    /// <param name="r"> A request object.</param>
    /// <returns>Returns the requested URI in the form of a string.</returns>
    public static string RequestURI(HttpRequest r)
    {
      __sklib_ptr __skparam__r;
      __sklib_string __skreturn;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skreturn = __sklib__request_uri__http_request(__skparam__r);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Returns an array of strings representing each stub of the URI.  For example a request sent to `http://localhost:8080/names/0` returns...  ["names", "0"]
    /// </summary>
    /// <param name="r"> The request for retrieving URI to split into stubs.</param>
    /// <returns>The array of stubs as strings.</returns>
    public static List<string> RequestURIStubs(HttpRequest r)
    {
      __sklib_ptr __skparam__r;
      __sklib_vector_string __skreturn;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skreturn = __sklib__request_uri_stubs__http_request(__skparam__r);
      return __skadapter__to_vector_string(__skreturn);
    }
    /// <summary>
    /// Serves a css file to the given `http_request`.
    /// </summary>
    /// <param name="r"> The request which is asking for the resource.</param>
    /// <param name="filename"> The name of the file in Resources/server</param>
    public static void SendCSSFileResponse(HttpRequest r, string filename)
    {
      __sklib_ptr __skparam__r;
      __sklib_string __skparam__filename;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __sklib__send_css_file_response__http_request__string_ref(__skparam__r, __skparam__filename);
    __skadapter__free__sklib_string(ref __skparam__filename);
    }
    /// <summary>
    /// Serves a file to the given `http_request`.
    /// </summary>
    /// <param name="r"> The request which is asking for the resource.</param>
    /// <param name="filename"> The name of the file in Resources/server</param>
    /// <param name="contentType"> The type of content being send:</param>
    public static void SendFileResponse(HttpRequest r, string filename, string contentType)
    {
      __sklib_ptr __skparam__r;
      __sklib_string __skparam__filename;
      __sklib_string __skparam__content_type;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __skparam__content_type = __skadapter__to_sklib_string(contentType);
      __sklib__send_file_response__http_request__string_ref__string_ref(__skparam__r, __skparam__filename, __skparam__content_type);
    __skadapter__free__sklib_string(ref __skparam__filename);
    __skadapter__free__sklib_string(ref __skparam__content_type);
    }
    /// <summary>
    /// Serves a HTML file to the given `http_request`.
    /// </summary>
    /// <param name="r"> The request which is asking for the resource.</param>
    /// <param name="filename"> The name of the file in Resources/server</param>
    public static void SendHtmlFileResponse(HttpRequest r, string filename)
    {
      __sklib_ptr __skparam__r;
      __sklib_string __skparam__filename;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __sklib__send_html_file_response__http_request__string_ref(__skparam__r, __skparam__filename);
    __skadapter__free__sklib_string(ref __skparam__filename);
    }
    /// <summary>
    /// Serves a javascript file to the given `http_request`.
    /// </summary>
    /// <param name="r"> The request which is asking for the resource.</param>
    /// <param name="filename"> The name of the file in Resources/server</param>
    public static void SendJavascriptFileResponse(HttpRequest r, string filename)
    {
      __sklib_ptr __skparam__r;
      __sklib_string __skparam__filename;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skparam__filename = __skadapter__to_sklib_string(filename);
      __sklib__send_javascript_file_response__http_request__string_ref(__skparam__r, __skparam__filename);
    __skadapter__free__sklib_string(ref __skparam__filename);
    }
    /// <summary>
    /// Sends a response with no content to a `http_request`.
    /// </summary>
    /// <param name="r"> The `http_request` to send the response to</param>
    public static void SendResponse(HttpRequest r)
    {
      __sklib_ptr __skparam__r;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __sklib__send_response__http_request(__skparam__r);
    }
    /// <summary>
    /// Sends a message to a given `http_request`.
    /// </summary>
    /// <param name="r"> The request to be sent.</param>
    /// <param name="message"> The message to be sent</param>
    public static void SendResponse(HttpRequest r, string message)
    {
      __sklib_ptr __skparam__r;
      __sklib_string __skparam__message;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skparam__message = __skadapter__to_sklib_string(message);
      __sklib__send_response__http_request__string_ref(__skparam__r, __skparam__message);
    __skadapter__free__sklib_string(ref __skparam__message);
    }
    /// <summary>
    /// Sends a response code to a given `http_request`.
    /// </summary>
    /// <param name="r"> The `http_request` to send the response to</param>
    /// <param name="code"> The [HTTP status code](See https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) to be sent.</param>
    public static void SendResponse(HttpRequest r, HttpStatusCode code)
    {
      __sklib_ptr __skparam__r;
      int __skparam__code;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skparam__code = __skadapter__to_sklib_http_status_code(code);
      __sklib__send_response__http_request__http_status_code(__skparam__r, __skparam__code);
    }
    /// <summary>
    /// Sends a message to a given `http_request` with the specified content type.
    /// </summary>
    /// <param name="r"> The `http_request` to send the response to</param>
    /// <param name="code"> The [HTTP status code](See https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) to be sent.</param>
    /// <param name="message"> The messsage, in the form of a `http_response`, to be sent.</param>
    public static void SendResponse(HttpRequest r, HttpStatusCode code, string message)
    {
      __sklib_ptr __skparam__r;
      int __skparam__code;
      __sklib_string __skparam__message;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skparam__code = __skadapter__to_sklib_http_status_code(code);
      __skparam__message = __skadapter__to_sklib_string(message);
      __sklib__send_response__http_request__http_status_code__string_ref(__skparam__r, __skparam__code, __skparam__message);
    __skadapter__free__sklib_string(ref __skparam__message);
    }
    /// <summary>
    /// Sends a message to a given `http_request` with the specified content type.
    /// </summary>
    /// <param name="r"> The `http_request` to send the response to</param>
    /// <param name="code"> The [HTTP status code](See https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) to be sent.</param>
    /// <param name="message"> The messsage, in the form of a `http_response`, to be sent.</param>
    /// <param name="contentType"> The content type of the response.</param>
    public static void SendResponse(HttpRequest r, HttpStatusCode code, string message, string contentType)
    {
      __sklib_ptr __skparam__r;
      int __skparam__code;
      __sklib_string __skparam__message;
      __sklib_string __skparam__content_type;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skparam__code = __skadapter__to_sklib_http_status_code(code);
      __skparam__message = __skadapter__to_sklib_string(message);
      __skparam__content_type = __skadapter__to_sklib_string(contentType);
      __sklib__send_response__http_request__http_status_code__string_ref__string_ref(__skparam__r, __skparam__code, __skparam__message, __skparam__content_type);
    __skadapter__free__sklib_string(ref __skparam__message);
    __skadapter__free__sklib_string(ref __skparam__content_type);
    }
    /// <summary>
    /// Sends a message to a given `http_request` with the specified content type.
    /// </summary>
    /// <param name="r"> The `http_request` to send the response to</param>
    /// <param name="code"> The [HTTP status code](See https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) to be sent.</param>
    /// <param name="message"> The messsage, in the form of a `http_response`, to be sent.</param>
    /// <param name="contentType"> The content type of the response.</param>
    /// <param name="headers"> The response headers</param>
    public static void SendResponse(HttpRequest r, HttpStatusCode code, string message, string contentType, List<string> headers)
    {
      __sklib_ptr __skparam__r;
      int __skparam__code;
      __sklib_string __skparam__message;
      __sklib_string __skparam__content_type;
      __sklib_vector_string __skparam__headers;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skparam__code = __skadapter__to_sklib_http_status_code(code);
      __skparam__message = __skadapter__to_sklib_string(message);
      __skparam__content_type = __skadapter__to_sklib_string(contentType);
      __skparam__headers = __skadapter__to_sklib_vector_string(headers);
      __sklib__send_response__http_request__http_status_code__string_ref__string_ref__vector_string_ref(__skparam__r, __skparam__code, __skparam__message, __skparam__content_type, __skparam__headers);
    __skadapter__free__sklib_string(ref __skparam__message);
    __skadapter__free__sklib_string(ref __skparam__content_type);
    __skadapter__free__sklib_vector_string(ref __skparam__headers);
    }
    /// <summary>
    /// Send a JSON response to a given `http_request`
    /// </summary>
    /// <param name="r"> The request the response belongs to.</param>
    /// <param name="j"> The json to be sent.</param>
    public static void SendResponse(HttpRequest r, Json j)
    {
      __sklib_ptr __skparam__r;
      __sklib_ptr __skparam__j;
      __skparam__r = __skadapter__to_sklib_http_request(r);
      __skparam__j = __skadapter__to_sklib_json(j);
      __sklib__send_response__http_request__json(__skparam__r, __skparam__j);
    }
    /// <summary>
    /// Returns an array of strings representing each stub of the URI.  For example a request sent to `http://localhost:8080/names/0` returns...  ["names", "0"]
    /// </summary>
    /// <param name="uri"> The URI to split into stubs.</param>
    /// <returns>The array of stubs as strings.</returns>
    public static List<string> SplitURIStubs(string uri)
    {
      __sklib_string __skparam__uri;
      __sklib_vector_string __skreturn;
      __skparam__uri = __skadapter__to_sklib_string(uri);
      __skreturn = __sklib__split_uri_stubs__string_ref(__skparam__uri);
    __skadapter__free__sklib_string(ref __skparam__uri);
      return __skadapter__to_vector_string(__skreturn);
    }
    /// <summary>
    /// Creates a new web server listening for connections on port 8080.
    /// </summary>
    /// <returns>Returns a new `web_sever` instance.</returns>
    public static WebServer StartWebServer()
    {
      __sklib_ptr __skreturn;
      __skreturn = __sklib__start_web_server();
      return __skadapter__to_web_server(__skreturn);
    }
    /// <summary>
    /// Starts the web server on a given port number.
    /// </summary>
    /// <param name="port"> The port number to connect through.</param>
    /// <returns>Returns a new `web_server` instance.</returns>
    public static WebServer StartWebServer(ushort port)
    {
      ushort __skparam__port;
      __sklib_ptr __skreturn;
      __skparam__port = __skadapter__to_sklib_unsigned_short(port);
      __skreturn = __sklib__start_web_server__unsigned_short(__skparam__port);
      return __skadapter__to_web_server(__skreturn);
    }
    /// <summary>
    /// Stops a given `web_server` instance.
    /// </summary>
    /// <param name="server"> The server instance to stop.</param>
    public static void StopWebServer(WebServer server)
    {
      __sklib_ptr __skparam__server;
      __skparam__server = __skadapter__to_sklib_web_server(server);
      __sklib__stop_web_server__web_server(__skparam__server);
    }
    /// <summary>
    /// clears a window to the specified color given in `clr`
    /// </summary>
    /// <param name="wind"> the `window` to clear</param>
    /// <param name="clr"> the `color` to clear the window to.</param>
    public static void ClearWindow(Window wind, Color clr)
    {
      __sklib_ptr __skparam__wind;
      __sklib_color __skparam__clr;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skparam__clr = __skadapter__to_sklib_color(clr);
      __sklib__clear_window__window__color(__skparam__wind, __skparam__clr);
    }
    /// <summary>
    /// Releases all of the windows which have been loaded.
    /// </summary>
    public static void CloseAllWindows()
    {
      __sklib__close_all_windows();
    }
    /// <summary>
    /// Closes and frees the current window.
    /// </summary>
    public static void CloseCurrentWindow()
    {
      __sklib__close_current_window();
    }
    /// <summary>
    /// Closes and frees the graphics window identified by `name`.
    /// </summary>
    /// <param name="name"> The name (caption) of the window to close</param>
    public static void CloseWindow(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__close_window__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Closes and frees the graphics window supplied in `wind`.
    /// </summary>
    /// <param name="wind"> The window to close</param>
    public static void CloseWindow(Window wind)
    {
      __sklib_ptr __skparam__wind;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __sklib__close_window__window(__skparam__wind);
    }
    /// <summary>
    /// Returns the window that you are currently interacting with. This will be the default window for drawing options, and events.
    /// </summary>
    /// <returns>The current window</returns>
    public static Window CurrentWindow()
    {
      __sklib_ptr __skreturn;
      __skreturn = __sklib__current_window();
      return __skadapter__to_window(__skreturn);
    }
    /// <summary>
    /// Indicate if the current window has a border.
    /// </summary>
    /// <returns>True if the window has a border</returns>
    public static bool CurrentWindowHasBorder()
    {
      int __skreturn;
      __skreturn = __sklib__current_window_has_border();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the height of the current window.
    /// </summary>
    /// <returns>The height of the current window</returns>
    public static int CurrentWindowHeight()
    {
      int __skreturn;
      __skreturn = __sklib__current_window_height();
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Is the current window currently fullscreen?
    /// </summary>
    /// <returns>True when the window is fullscreen</returns>
    public static bool CurrentWindowIsFullscreen()
    {
      int __skreturn;
      __skreturn = __sklib__current_window_is_fullscreen();
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// The location of the current window.
    /// </summary>
    /// <returns>Its location on the displays</returns>
    public static Point2D CurrentWindowPosition()
    {
      __sklib_point_2d __skreturn;
      __skreturn = __sklib__current_window_position();
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Toggle the current window border.
    /// </summary>
    public static void CurrentWindowToggleBorder()
    {
      __sklib__current_window_toggle_border();
    }
    /// <summary>
    /// Toggle the fullscreen property of the current window
    /// </summary>
    public static void CurrentWindowToggleFullscreen()
    {
      __sklib__current_window_toggle_fullscreen();
    }
    /// <summary>
    /// Returns the width of the current window.
    /// </summary>
    /// <returns>The width of the current window</returns>
    public static int CurrentWindowWidth()
    {
      int __skreturn;
      __skreturn = __sklib__current_window_width();
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// The x location of the current window on the displays.
    /// </summary>
    /// <returns>Its location on the displays</returns>
    public static int CurrentWindowX()
    {
      int __skreturn;
      __skreturn = __sklib__current_window_x();
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// The y location of the current window on the displays.
    /// </summary>
    /// <returns>Its location on the displays</returns>
    public static int CurrentWindowY()
    {
      int __skreturn;
      __skreturn = __sklib__current_window_y();
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Determines if SplashKit has a window loaded with the supplied name. This checks against all windows loaded, those loaded without a name are assigned the filename as a default. If this returns `false`, you may want to use `load_window` to load in a specific window and give it the desired name.
    /// </summary>
    /// <param name="caption"> The name of the window to check for.</param>
    /// <returns>Returns `true` if there is a window with the given `caption` which has has been loaded.</returns>
    public static bool HasWindow(string caption)
    {
      __sklib_string __skparam__caption;
      int __skreturn;
      __skparam__caption = __skadapter__to_sklib_string(caption);
      __skreturn = __sklib__has_window__string(__skparam__caption);
    __skadapter__free__sklib_string(ref __skparam__caption);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Check if the requested window is the current window.
    /// </summary>
    /// <param name="wind"> The window to check</param>
    /// <returns>true if the window is the current window</returns>
    public static bool IsCurrentWindow(Window wind)
    {
      __sklib_ptr __skparam__wind;
      int __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skreturn = __sklib__is_current_window__window(__skparam__wind);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Move the current window to the new location on the displays.
    /// </summary>
    /// <param name="x"> The new x location</param>
    /// <param name="y"> The new y location</param>
    public static void MoveCurrentWindowTo(int x, int y)
    {
      int __skparam__x;
      int __skparam__y;
      __skparam__x = __skadapter__to_sklib_int(x);
      __skparam__y = __skadapter__to_sklib_int(y);
      __sklib__move_current_window_to__int__int(__skparam__x, __skparam__y);
    }
    /// <summary>
    /// Move the window to the new location on the displays.
    /// </summary>
    /// <param name="name"> The name of the window to move</param>
    /// <param name="x"> The new x location</param>
    /// <param name="y"> The new y location</param>
    public static void MoveWindowTo(string name, int x, int y)
    {
      __sklib_string __skparam__name;
      int __skparam__x;
      int __skparam__y;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skparam__x = __skadapter__to_sklib_int(x);
      __skparam__y = __skadapter__to_sklib_int(y);
      __sklib__move_window_to__string_ref__int__int(__skparam__name, __skparam__x, __skparam__y);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Move the window to the new location on the displays.
    /// </summary>
    /// <param name="wind"> the window to move.</param>
    /// <param name="x"> The new x location</param>
    /// <param name="y"> The new y location</param>
    public static void MoveWindowTo(Window wind, int x, int y)
    {
      __sklib_ptr __skparam__wind;
      int __skparam__x;
      int __skparam__y;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skparam__x = __skadapter__to_sklib_int(x);
      __skparam__y = __skadapter__to_sklib_int(y);
      __sklib__move_window_to__window__int__int(__skparam__wind, __skparam__x, __skparam__y);
    }
    /// <summary>
    /// Opens a new graphics window. The supplied `caption` is used to name and identify the window. The supplied `width` and `height` indicate the size of the window. The window can be retrieved by passing `caption` to the `window_named` function.
    /// </summary>
    /// <param name="caption"> The title of the window. If a window with this caption already exists, SplashKit will alter the caption to ensure that it is unique.</param>
    /// <param name="width"> The width of the window</param>
    /// <param name="height"> The height of the window</param>
    /// <returns>A new window</returns>
    public static Window OpenWindow(string caption, int width, int height)
    {
      __sklib_string __skparam__caption;
      int __skparam__width;
      int __skparam__height;
      __sklib_ptr __skreturn;
      __skparam__caption = __skadapter__to_sklib_string(caption);
      __skparam__width = __skadapter__to_sklib_int(width);
      __skparam__height = __skadapter__to_sklib_int(height);
      __skreturn = __sklib__open_window__string__int__int(__skparam__caption, __skparam__width, __skparam__height);
    __skadapter__free__sklib_string(ref __skparam__caption);
      return __skadapter__to_window(__skreturn);
    }
    /// <summary>
    /// Refreshes the window `wind`.
    /// </summary>
    /// <param name="wind"> the `window` to refresh.</param>
    public static void RefreshWindow(Window wind)
    {
      __sklib_ptr __skparam__wind;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __sklib__refresh_window__window(__skparam__wind);
    }
    /// <summary>
    /// Refreshes the window `wind`.
    /// </summary>
    /// <param name="wind"> the `window` to refresh.</param>
    /// <param name="targetFps"> the desired framerate</param>
    public static void RefreshWindow(Window wind, uint targetFps)
    {
      __sklib_ptr __skparam__wind;
      uint __skparam__target_fps;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skparam__target_fps = __skadapter__to_sklib_unsigned_int(targetFps);
      __sklib__refresh_window__window__unsigned_int(__skparam__wind, __skparam__target_fps);
    }
    /// <summary>
    /// Change the size of the current window.
    /// </summary>
    /// <param name="width"> Its new width</param>
    /// <param name="height"> Its new height</param>
    public static void ResizeCurrentWindow(int width, int height)
    {
      int __skparam__width;
      int __skparam__height;
      __skparam__width = __skadapter__to_sklib_int(width);
      __skparam__height = __skadapter__to_sklib_int(height);
      __sklib__resize_current_window__int__int(__skparam__width, __skparam__height);
    }
    /// <summary>
    /// Change the size of the window.
    /// </summary>
    /// <param name="wnd"> The window to change.</param>
    /// <param name="width"> Its new width</param>
    /// <param name="height"> Its new height</param>
    public static void ResizeWindow(Window wnd, int width, int height)
    {
      __sklib_ptr __skparam__wnd;
      int __skparam__width;
      int __skparam__height;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skparam__width = __skadapter__to_sklib_int(width);
      __skparam__height = __skadapter__to_sklib_int(height);
      __sklib__resize_window__window__int__int(__skparam__wnd, __skparam__width, __skparam__height);
    }
    /// <summary>
    /// Set the current window to the window with the supplied caption.
    /// </summary>
    /// <param name="name"> The caption of the new current window.</param>
    public static void SetCurrentWindow(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__set_current_window__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Change the current window. Use this so that you can draw to different windows by default.
    /// </summary>
    /// <param name="wind"> The new current window</param>
    public static void SetCurrentWindow(Window wind)
    {
      __sklib_ptr __skparam__wind;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __sklib__set_current_window__window(__skparam__wind);
    }
    /// <summary>
    /// The caption of the window.
    /// </summary>
    /// <param name="wind"> The window</param>
    /// <returns>The window's caption.</returns>
    public static string WindowCaption(Window wind)
    {
      __sklib_ptr __skparam__wind;
      __sklib_string __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skreturn = __sklib__window_caption__window(__skparam__wind);
      return __skadapter__to_string(__skreturn);
    }
    /// <summary>
    /// Checks all opened windows in the current program to determin if a window with the name `name` is currently open, and will close a window if one is found.
    /// </summary>
    /// <param name="name"> The name of the window to close</param>
    /// <returns>Returns `true` if the window has been asked to close.</returns>
    public static bool WindowCloseRequested(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__window_close_requested__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Closes the window given in `wind`
    /// </summary>
    /// <param name="wind"> the `window` to be closed</param>
    /// <returns>Returns `true` if the window is closed, `false` if there is an error.</returns>
    public static bool WindowCloseRequested(Window wind)
    {
      __sklib_ptr __skparam__wind;
      int __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skreturn = __sklib__window_close_requested__window(__skparam__wind);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Indicate if the window has a border.
    /// </summary>
    /// <param name="name"> The name of the window</param>
    /// <returns>True if the window has a border</returns>
    public static bool WindowHasBorder(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__window_has_border__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Indicate if the window has a border.
    /// </summary>
    /// <param name="wnd"> The window</param>
    /// <returns>True if the window has a border</returns>
    public static bool WindowHasBorder(Window wnd)
    {
      __sklib_ptr __skparam__wnd;
      int __skreturn;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skreturn = __sklib__window_has_border__window(__skparam__wnd);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Indicates if the window has focus.
    /// </summary>
    /// <param name="wind"> The window</param>
    /// <returns>True if the window has the user's focus</returns>
    public static bool WindowHasFocus(Window wind)
    {
      __sklib_ptr __skparam__wind;
      int __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skreturn = __sklib__window_has_focus__window(__skparam__wind);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns the height of the window with the indicated name in pixels.
    /// </summary>
    /// <param name="name"> The name of the window</param>
    /// <returns>The height of the window</returns>
    public static int WindowHeight(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__window_height__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the height of the window in pixels.
    /// </summary>
    /// <param name="wind"> The window</param>
    /// <returns>The height of the window</returns>
    public static int WindowHeight(Window wind)
    {
      __sklib_ptr __skparam__wind;
      int __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skreturn = __sklib__window_height__window(__skparam__wind);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Is the window currently fullscreen?
    /// </summary>
    /// <param name="name"> The name of the window to check</param>
    /// <returns>True when the window is fullscreen</returns>
    public static bool WindowIsFullscreen(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__window_is_fullscreen__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Is the window currently fullscreen?
    /// </summary>
    /// <param name="wnd"> The window to check</param>
    /// <returns>True when the window is fullscreen</returns>
    public static bool WindowIsFullscreen(Window wnd)
    {
      __sklib_ptr __skparam__wnd;
      int __skreturn;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skreturn = __sklib__window_is_fullscreen__window(__skparam__wnd);
      return __skadapter__to_bool(__skreturn);
    }
    /// <summary>
    /// Returns an opened `window` with the given name `caption`, if a window with name `caption` is found.
    /// </summary>
    /// <param name="caption"> the `string` name of the window.</param>
    /// <returns>Returns a `window` with the name specified by `caption`</returns>
    public static Window WindowNamed(string caption)
    {
      __sklib_string __skparam__caption;
      __sklib_ptr __skreturn;
      __skparam__caption = __skadapter__to_sklib_string(caption);
      __skreturn = __sklib__window_named__string(__skparam__caption);
    __skadapter__free__sklib_string(ref __skparam__caption);
      return __skadapter__to_window(__skreturn);
    }
    /// <summary>
    /// The location of the window.
    /// </summary>
    /// <param name="name"> The name of the window.</param>
    /// <returns>Its location on the displays</returns>
    public static Point2D WindowPosition(string name)
    {
      __sklib_string __skparam__name;
      __sklib_point_2d __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__window_position__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// The location of the window.
    /// </summary>
    /// <param name="wnd"> The window.</param>
    /// <returns>Its location on the displays</returns>
    public static Point2D WindowPosition(Window wnd)
    {
      __sklib_ptr __skparam__wnd;
      __sklib_point_2d __skreturn;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skreturn = __sklib__window_position__window(__skparam__wnd);
      return __skadapter__to_point_2d(__skreturn);
    }
    /// <summary>
    /// Sets the icon of the current window.
    /// </summary>
    /// <param name="wind"> The window to change the icon of</param>
    /// <param name="bmp"> The image with the details to show in the icon</param>
    public static void WindowSetIcon(Window wind, Bitmap bmp)
    {
      __sklib_ptr __skparam__wind;
      __sklib_ptr __skparam__bmp;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skparam__bmp = __skadapter__to_sklib_bitmap(bmp);
      __sklib__window_set_icon__window__bitmap(__skparam__wind, __skparam__bmp);
    }
    /// <summary>
    /// Toggle the window border.
    /// </summary>
    /// <param name="name"> The name of the window to change</param>
    public static void WindowToggleBorder(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__window_toggle_border__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Toggle the window border.
    /// </summary>
    /// <param name="wnd"> The window to change</param>
    public static void WindowToggleBorder(Window wnd)
    {
      __sklib_ptr __skparam__wnd;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __sklib__window_toggle_border__window(__skparam__wnd);
    }
    /// <summary>
    /// Toggle the fullscreen property of the window
    /// </summary>
    /// <param name="name"> The name of the window to change</param>
    public static void WindowToggleFullscreen(string name)
    {
      __sklib_string __skparam__name;
      __skparam__name = __skadapter__to_sklib_string(name);
      __sklib__window_toggle_fullscreen__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
    }
    /// <summary>
    /// Toggle the fullscreen property of the window
    /// </summary>
    /// <param name="wnd"> The window to change</param>
    public static void WindowToggleFullscreen(Window wnd)
    {
      __sklib_ptr __skparam__wnd;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __sklib__window_toggle_fullscreen__window(__skparam__wnd);
    }
    /// <summary>
    /// Returns the width of the window with the indicated name in pixels.
    /// </summary>
    /// <param name="name"> The name of the window</param>
    /// <returns>The width of the window</returns>
    public static int WindowWidth(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__window_width__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the width of the window in pixels.
    /// </summary>
    /// <param name="wind"> The window</param>
    /// <returns>The width of the window</returns>
    public static int WindowWidth(Window wind)
    {
      __sklib_ptr __skparam__wind;
      int __skreturn;
      __skparam__wind = __skadapter__to_sklib_window(wind);
      __skreturn = __sklib__window_width__window(__skparam__wind);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// Returns the window that the user currently has selected. This may be different to the current window.
    /// </summary>
    /// <returns>The window the user has selected</returns>
    public static Window WindowWithFocus()
    {
      __sklib_ptr __skreturn;
      __skreturn = __sklib__window_with_focus();
      return __skadapter__to_window(__skreturn);
    }
    /// <summary>
    /// The x location of the window on the displays.
    /// </summary>
    /// <param name="name"> The name of the window</param>
    /// <returns>Its location on the displays</returns>
    public static int WindowX(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__window_x__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// The x location of the window on the displays.
    /// </summary>
    /// <param name="wnd"> The window</param>
    /// <returns>Its location on the displays</returns>
    public static int WindowX(Window wnd)
    {
      __sklib_ptr __skparam__wnd;
      int __skreturn;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skreturn = __sklib__window_x__window(__skparam__wnd);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// The y location of the window on the displays.
    /// </summary>
    /// <param name="name"> The name of the window</param>
    /// <returns>Its location on the displays</returns>
    public static int WindowY(string name)
    {
      __sklib_string __skparam__name;
      int __skreturn;
      __skparam__name = __skadapter__to_sklib_string(name);
      __skreturn = __sklib__window_y__string_ref(__skparam__name);
    __skadapter__free__sklib_string(ref __skparam__name);
      return __skadapter__to_int(__skreturn);
    }
    /// <summary>
    /// The y location of the window on the displays.
    /// </summary>
    /// <param name="wnd"> The window</param>
    /// <returns>Its location on the displays</returns>
    public static int WindowY(Window wnd)
    {
      __sklib_ptr __skparam__wnd;
      int __skreturn;
      __skparam__wnd = __skadapter__to_sklib_window(wnd);
      __skreturn = __sklib__window_y__window(__skparam__wnd);
      return __skadapter__to_int(__skreturn);
    }
  }

    public enum KeyCode
  {
    UnknownKey = 0,
    BackspaceKey = 8,
    TabKey = 9,
    ClearKey = 12,
    ReturnKey = 13,
    PauseKey = 19,
    EscapeKey = 27,
    SpaceKey = 32,
    ExclaimKey = 33,
    DoubleQuoteKey = 34,
    HashKey = 35,
    DollarKey = 36,
    AmpersandKey = 38,
    QuoteKey = 39,
    LeftParenKey = 40,
    RightParenKey = 41,
    AsteriskKey = 42,
    PlusKey = 43,
    CommaKey = 44,
    MinusKey = 45,
    PeriodKey = 46,
    SlashKey = 47,
    Num0Key = 48,
    Num1Key = 49,
    Num2Key = 50,
    Num3Key = 51,
    Num4Key = 52,
    Num5Key = 53,
    Num6Key = 54,
    Num7Key = 55,
    Num8Key = 56,
    Num9Key = 57,
    ColonKey = 58,
    SemiColonKey = 59,
    LessKey = 60,
    EqualsKey = 61,
    GreaterKey = 62,
    QuestionKey = 63,
    AtKey = 64,
    LeftBracketKey = 91,
    BackslashKey = 92,
    RightBracketKey = 93,
    CaretKey = 94,
    UnderscoreKey = 95,
    BackquoteKey = 96,
    AKey = 97,
    BKey = 98,
    CKey = 99,
    DKey = 100,
    EKey = 101,
    FKey = 102,
    GKey = 103,
    HKey = 104,
    IKey = 105,
    JKey = 106,
    KKey = 107,
    LKey = 108,
    MKey = 109,
    NKey = 110,
    OKey = 111,
    PKey = 112,
    QKey = 113,
    RKey = 114,
    SKey = 115,
    TKey = 116,
    UKey = 117,
    VKey = 118,
    WKey = 119,
    XKey = 120,
    YKey = 121,
    ZKey = 122,
    DeleteKey = 127,
    Keypad0 = 256,
    Keypad1 = 257,
    Keypad2 = 258,
    Keypad3 = 259,
    Keypad4 = 260,
    Keypad5 = 261,
    Keypad6 = 262,
    Keypad7 = 263,
    Keypad8 = 264,
    Keypad9 = 265,
    KeypadPeriod = 266,
    KeypadDivide = 267,
    KeypadMultiply = 268,
    KeypadMinus = 269,
    KeypadPlus = 270,
    KeypadEnter = 271,
    KeypadEquals = 272,
    UpKey = 273,
    DownKey = 274,
    RightKey = 275,
    LeftKey = 276,
    InsertKey = 277,
    HomeKey = 278,
    EndKey = 279,
    PageUpKey = 280,
    PageDownKey = 281,
    F1Key = 282,
    F2Key = 283,
    F3Key = 284,
    F4Key = 285,
    F5Key = 286,
    F6Key = 287,
    F7Key = 288,
    F8Key = 289,
    F9Key = 290,
    F10Key = 291,
    F11Key = 292,
    F12Key = 293,
    F13Key = 294,
    F14Key = 295,
    F15Key = 296,
    NumLockKey = 300,
    CapsLockKey = 301,
    ScrollLockKey = 302,
    RightShiftKey = 303,
    LeftShiftKey = 304,
    RightCtrlKey = 305,
    LeftCtrlKey = 306,
    RightAltKey = 307,
    LeftAltKey = 308,
    LeftSuperKey = 311,
    RightSuperKey = 312,
    ModeKey = 313,
    HelpKey = 315,
    SysReqKey = 317,
    MenuKey = 319,
    PowerKey = 320
  }
  public enum LogLevel
  {
    None,
    Info,
    Debug,
    Warning,
    Error,
    Fatal
  }
  public enum LogMode
  {
    LogNone,
    LogConsole,
    LogFileOnly,
    LogConsoleAndFile
  }
  public enum MouseButton
  {
    NoButton,
    LeftButton,
    MiddleButton,
    RightButton,
    MouseX1Button,
    MouseX2Button
  }
  public enum ConnectionType
  {
    TCP,
    UDP,
    Unknown
  }
  public enum ResourceKind
  {
    AnimationResource,
    BundleResource,
    FontResource,
    ImageResource,
    JsonResource,
    MusicResource,
    ServerResource,
    SoundResource,
    TimerResource,
    OtherResource
  }
  public enum CollisionTestKind
  {
    PixelCollisions,
    AabbCollisions
  }
  public enum SpriteEventKind
  {
    SpriteArrivedEvent,
    SpriteAnimationEndedEvent,
    SpriteTouchedEvent,
    SpriteClickedEvent
  }
  public enum DrawingDest
  {
    DrawToScreen,
    DrawToWorld,
    DrawDefault
  }
  public enum FontStyle
  {
    NormalFont = 0,
    BoldFont = 1,
    ItalicFont = 2,
    UnderlineFont = 4
  }
  public enum HttpStatusCode
  {
    HttpStatusOk = 200,
    HttpStatusCreated = 201,
    HttpStatusNoContent = 204,
    HttpStatusMovedPermanently = 301,
    HttpStatusFound = 302,
    HttpStatusSeeOther = 303,
    HttpStatusBadRequest = 400,
    HttpStatusUnauthorized = 401,
    HttpStatusForbidden = 403,
    HttpStatusNotFound = 404,
    HttpStatusMethodNotAllowed = 405,
    HttpStatusRequestTimeout = 408,
    HttpStatusConflict = 409,
    HttpStatusInternalServerError = 500,
    HttpStatusNotImplemented = 501,
    HttpStatusServiceUnavailable = 503
  }
  public enum InterfaceStyle
  {
    FlatDarkStyle = 0,
    ShadedDarkStyle = 1,
    FlatLightStyle = 2,
    ShadedLightStyle = 3,
    Bubble = 4,
    BubbleMulticolored = 5
  }
  public enum PinModes
  {
    GpioInput = 0,
    GpioOutput = 1,
    GpioAlt0 = 4,
    GpioAlt1 = 5,
    GpioAlt2 = 6,
    GpioAlt3 = 7,
    GpioAlt4 = 3,
    GpioAlt5 = 2,
    GpioDefaultMode = 1
  }
  public enum PinValues
  {
    GpioLow = 0,
    GpioHigh = 1,
    GpioDefaultValue = 1
  }
  public enum Pins
  {
    Pin1 = 1,
    Pin2 = 2,
    Pin3 = 3,
    Pin4 = 4,
    Pin5 = 5,
    Pin6 = 6,
    Pin7 = 7,
    Pin8 = 8,
    Pin9 = 9,
    Pin10 = 10,
    Pin11 = 11,
    Pin12 = 12,
    Pin13 = 13,
    Pin14 = 14,
    Pin15 = 15,
    Pin16 = 16,
    Pin17 = 17,
    Pin18 = 18,
    Pin19 = 19,
    Pin20 = 20,
    Pin21 = 21,
    Pin22 = 22,
    Pin23 = 23,
    Pin24 = 24,
    Pin25 = 25,
    Pin26 = 26,
    Pin27 = 27,
    Pin28 = 28,
    Pin29 = 29,
    Pin30 = 30,
    Pin31 = 31,
    Pin32 = 32,
    Pin33 = 33,
    Pin34 = 34,
    Pin35 = 35,
    Pin36 = 36,
    Pin37 = 37,
    Pin38 = 38,
    Pin39 = 39,
    Pin40 = 40
  }
  public enum PullUpDown
  {
    PudOff = 0,
    PudDown = 1,
    PudUp = 2
  }
  public enum HttpMethod
  {
    HttpGetMethod,
    HttpPostMethod,
    HttpPutMethod,
    HttpDeleteMethod,
    HttpOptionsMethod,
    HttpTraceMethod,
    UnknownHttpMethod
  }

  [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi ) ]
  internal struct __sklib_matrix_2d
  {
    // Unpacking array due to C# Marshalling limitations
    public double Elements_0;
    public double Elements_1;
    public double Elements_2;
    public double Elements_3;
    public double Elements_4;
    public double Elements_5;
    public double Elements_6;
    public double Elements_7;
    public double Elements_8;

  }

  public struct Matrix2D
  {
    public double[,] Elements;
  }

  [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi ) ]
  internal struct __sklib_point_2d
  {
    public double X;
    public double Y;

  }

  public struct Point2D
  {
    public double X;
    public double Y;
  }

  [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi ) ]
  internal struct __sklib_circle
  {
    public __sklib_point_2d Center;
    public double Radius;

  }

  public struct Circle
  {
    public Point2D Center;
    public double Radius;

    public void Draw(Color clr)
    {
        SplashKit.DrawCircle(clr, this);
    }


    public void Draw(Color clr, DrawingOptions opts)
    {
        SplashKit.DrawCircle(clr, this, opts);
    }


    public void Fill(Color clr)
    {
        SplashKit.FillCircle(clr, this);
    }


    public void Fill(Color clr, DrawingOptions opts)
    {
        SplashKit.FillCircle(clr, this, opts);
    }

  }

  [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi ) ]
  internal struct __sklib_color
  {
    public float R;
    public float G;
    public float B;
    public float A;

  }

  public struct Color
  {
    public float R;
    public float G;
    public float B;
    public float A;

    public static bool operator ==(Color lhs, Color rhs)
    {
        return Math.Abs(lhs.R - rhs.R) < 0.004 &&
               Math.Abs(lhs.G - rhs.G) < 0.004 &&
               Math.Abs(lhs.B - rhs.B) < 0.004 &&
               Math.Abs(lhs.A - rhs.A) < 0.004;
    }

    public static bool operator !=(Color lhs, Color rhs)
    {
        return !(lhs == rhs);
    }

    public override bool Equals(object? obj)
    {
        if (obj is Color)
            return this == (Color)obj;
        return false;
    }

    public override int GetHashCode()
    {
        return HashCode.Combine(R, G, B, A);
    }

    public static Color HSBColor(double hue, double saturation, double brightness)
    {
        return SplashKit.HSBColor(hue, saturation, brightness);
    }


    public static Color Random()
    {
        return SplashKit.RandomColor();
    }


    public static Color RandomRGB(int alpha)
    {
        return SplashKit.RandomRGBColor(alpha);
    }


    public static Color RGBColor(double red, double green, double blue)
    {
        return SplashKit.RGBColor(red, green, blue);
    }


    public static Color RGBColor(int red, int green, int blue)
    {
        return SplashKit.RGBColor(red, green, blue);
    }


    public static Color RGBAColor(double red, double green, double blue, double alpha)
    {
        return SplashKit.RGBAColor(red, green, blue, alpha);
    }


    public static Color RGBAColor(int red, int green, int blue, int alpha)
    {
        return SplashKit.RGBAColor(red, green, blue, alpha);
    }

    public static Color AliceBlue
    {
        get { return SplashKit.ColorAliceBlue(); }
    }
    public static Color AntiqueWhite
    {
        get { return SplashKit.ColorAntiqueWhite(); }
    }
    public static Color Aqua
    {
        get { return SplashKit.ColorAqua(); }
    }
    public static Color Aquamarine
    {
        get { return SplashKit.ColorAquamarine(); }
    }
    public static Color Azure
    {
        get { return SplashKit.ColorAzure(); }
    }
    public static Color Beige
    {
        get { return SplashKit.ColorBeige(); }
    }
    public static Color Bisque
    {
        get { return SplashKit.ColorBisque(); }
    }
    public static Color Black
    {
        get { return SplashKit.ColorBlack(); }
    }
    public static Color BlanchedAlmond
    {
        get { return SplashKit.ColorBlanchedAlmond(); }
    }
    public static Color Blue
    {
        get { return SplashKit.ColorBlue(); }
    }
    public static Color BlueViolet
    {
        get { return SplashKit.ColorBlueViolet(); }
    }
    public static Color BrightGreen
    {
        get { return SplashKit.ColorBrightGreen(); }
    }
    public static Color Brown
    {
        get { return SplashKit.ColorBrown(); }
    }
    public static Color BurlyWood
    {
        get { return SplashKit.ColorBurlyWood(); }
    }
    public static Color CadetBlue
    {
        get { return SplashKit.ColorCadetBlue(); }
    }
    public static Color Chartreuse
    {
        get { return SplashKit.ColorChartreuse(); }
    }
    public static Color Chocolate
    {
        get { return SplashKit.ColorChocolate(); }
    }
    public static Color Coral
    {
        get { return SplashKit.ColorCoral(); }
    }
    public static Color CornflowerBlue
    {
        get { return SplashKit.ColorCornflowerBlue(); }
    }
    public static Color Cornsilk
    {
        get { return SplashKit.ColorCornsilk(); }
    }
    public static Color Crimson
    {
        get { return SplashKit.ColorCrimson(); }
    }
    public static Color Cyan
    {
        get { return SplashKit.ColorCyan(); }
    }
    public static Color DarkBlue
    {
        get { return SplashKit.ColorDarkBlue(); }
    }
    public static Color DarkCyan
    {
        get { return SplashKit.ColorDarkCyan(); }
    }
    public static Color DarkGoldenrod
    {
        get { return SplashKit.ColorDarkGoldenrod(); }
    }
    public static Color DarkGray
    {
        get { return SplashKit.ColorDarkGray(); }
    }
    public static Color DarkGreen
    {
        get { return SplashKit.ColorDarkGreen(); }
    }
    public static Color DarkKhaki
    {
        get { return SplashKit.ColorDarkKhaki(); }
    }
    public static Color DarkMagenta
    {
        get { return SplashKit.ColorDarkMagenta(); }
    }
    public static Color DarkOliveGreen
    {
        get { return SplashKit.ColorDarkOliveGreen(); }
    }
    public static Color DarkOrange
    {
        get { return SplashKit.ColorDarkOrange(); }
    }
    public static Color DarkOrchid
    {
        get { return SplashKit.ColorDarkOrchid(); }
    }
    public static Color DarkRed
    {
        get { return SplashKit.ColorDarkRed(); }
    }
    public static Color DarkSalmon
    {
        get { return SplashKit.ColorDarkSalmon(); }
    }
    public static Color DarkSeaGreen
    {
        get { return SplashKit.ColorDarkSeaGreen(); }
    }
    public static Color DarkSlateBlue
    {
        get { return SplashKit.ColorDarkSlateBlue(); }
    }
    public static Color DarkSlateGray
    {
        get { return SplashKit.ColorDarkSlateGray(); }
    }
    public static Color DarkTurquoise
    {
        get { return SplashKit.ColorDarkTurquoise(); }
    }
    public static Color DarkViolet
    {
        get { return SplashKit.ColorDarkViolet(); }
    }
    public static Color DeepPink
    {
        get { return SplashKit.ColorDeepPink(); }
    }
    public static Color DeepSkyBlue
    {
        get { return SplashKit.ColorDeepSkyBlue(); }
    }
    public static Color DimGray
    {
        get { return SplashKit.ColorDimGray(); }
    }
    public static Color DodgerBlue
    {
        get { return SplashKit.ColorDodgerBlue(); }
    }
    public static Color Firebrick
    {
        get { return SplashKit.ColorFirebrick(); }
    }
    public static Color FloralWhite
    {
        get { return SplashKit.ColorFloralWhite(); }
    }
    public static Color ForestGreen
    {
        get { return SplashKit.ColorForestGreen(); }
    }
    public static Color Fuchsia
    {
        get { return SplashKit.ColorFuchsia(); }
    }
    public static Color Gainsboro
    {
        get { return SplashKit.ColorGainsboro(); }
    }
    public static Color GhostWhite
    {
        get { return SplashKit.ColorGhostWhite(); }
    }
    public static Color Gold
    {
        get { return SplashKit.ColorGold(); }
    }
    public static Color Goldenrod
    {
        get { return SplashKit.ColorGoldenrod(); }
    }
    public static Color Gray
    {
        get { return SplashKit.ColorGray(); }
    }
    public static Color Green
    {
        get { return SplashKit.ColorGreen(); }
    }
    public static Color GreenYellow
    {
        get { return SplashKit.ColorGreenYellow(); }
    }
    public static Color Honeydew
    {
        get { return SplashKit.ColorHoneydew(); }
    }
    public static Color HotPink
    {
        get { return SplashKit.ColorHotPink(); }
    }
    public static Color IndianRed
    {
        get { return SplashKit.ColorIndianRed(); }
    }
    public static Color Indigo
    {
        get { return SplashKit.ColorIndigo(); }
    }
    public static Color Ivory
    {
        get { return SplashKit.ColorIvory(); }
    }
    public static Color Khaki
    {
        get { return SplashKit.ColorKhaki(); }
    }
    public static Color Lavender
    {
        get { return SplashKit.ColorLavender(); }
    }
    public static Color LavenderBlush
    {
        get { return SplashKit.ColorLavenderBlush(); }
    }
    public static Color LawnGreen
    {
        get { return SplashKit.ColorLawnGreen(); }
    }
    public static Color LemonChiffon
    {
        get { return SplashKit.ColorLemonChiffon(); }
    }
    public static Color LightBlue
    {
        get { return SplashKit.ColorLightBlue(); }
    }
    public static Color LightCoral
    {
        get { return SplashKit.ColorLightCoral(); }
    }
    public static Color LightCyan
    {
        get { return SplashKit.ColorLightCyan(); }
    }
    public static Color LightGoldenrodYellow
    {
        get { return SplashKit.ColorLightGoldenrodYellow(); }
    }
    public static Color LightGray
    {
        get { return SplashKit.ColorLightGray(); }
    }
    public static Color LightGreen
    {
        get { return SplashKit.ColorLightGreen(); }
    }
    public static Color LightPink
    {
        get { return SplashKit.ColorLightPink(); }
    }
    public static Color LightSalmon
    {
        get { return SplashKit.ColorLightSalmon(); }
    }
    public static Color LightSeaGreen
    {
        get { return SplashKit.ColorLightSeaGreen(); }
    }
    public static Color LightSkyBlue
    {
        get { return SplashKit.ColorLightSkyBlue(); }
    }
    public static Color LightSlateGray
    {
        get { return SplashKit.ColorLightSlateGray(); }
    }
    public static Color LightSteelBlue
    {
        get { return SplashKit.ColorLightSteelBlue(); }
    }
    public static Color LightYellow
    {
        get { return SplashKit.ColorLightYellow(); }
    }
    public static Color Lime
    {
        get { return SplashKit.ColorLime(); }
    }
    public static Color LimeGreen
    {
        get { return SplashKit.ColorLimeGreen(); }
    }
    public static Color Linen
    {
        get { return SplashKit.ColorLinen(); }
    }
    public static Color Magenta
    {
        get { return SplashKit.ColorMagenta(); }
    }
    public static Color Maroon
    {
        get { return SplashKit.ColorMaroon(); }
    }
    public static Color MediumAquamarine
    {
        get { return SplashKit.ColorMediumAquamarine(); }
    }
    public static Color MediumBlue
    {
        get { return SplashKit.ColorMediumBlue(); }
    }
    public static Color MediumOrchid
    {
        get { return SplashKit.ColorMediumOrchid(); }
    }
    public static Color MediumPurple
    {
        get { return SplashKit.ColorMediumPurple(); }
    }
    public static Color MediumSeaGreen
    {
        get { return SplashKit.ColorMediumSeaGreen(); }
    }
    public static Color MediumSlateBlue
    {
        get { return SplashKit.ColorMediumSlateBlue(); }
    }
    public static Color MediumSpringGreen
    {
        get { return SplashKit.ColorMediumSpringGreen(); }
    }
    public static Color MediumTurquoise
    {
        get { return SplashKit.ColorMediumTurquoise(); }
    }
    public static Color MediumVioletRed
    {
        get { return SplashKit.ColorMediumVioletRed(); }
    }
    public static Color MidnightBlue
    {
        get { return SplashKit.ColorMidnightBlue(); }
    }
    public static Color MintCream
    {
        get { return SplashKit.ColorMintCream(); }
    }
    public static Color MistyRose
    {
        get { return SplashKit.ColorMistyRose(); }
    }
    public static Color Moccasin
    {
        get { return SplashKit.ColorMoccasin(); }
    }
    public static Color NavajoWhite
    {
        get { return SplashKit.ColorNavajoWhite(); }
    }
    public static Color Navy
    {
        get { return SplashKit.ColorNavy(); }
    }
    public static Color OldLace
    {
        get { return SplashKit.ColorOldLace(); }
    }
    public static Color Olive
    {
        get { return SplashKit.ColorOlive(); }
    }
    public static Color OliveDrab
    {
        get { return SplashKit.ColorOliveDrab(); }
    }
    public static Color Orange
    {
        get { return SplashKit.ColorOrange(); }
    }
    public static Color OrangeRed
    {
        get { return SplashKit.ColorOrangeRed(); }
    }
    public static Color Orchid
    {
        get { return SplashKit.ColorOrchid(); }
    }
    public static Color PaleGoldenrod
    {
        get { return SplashKit.ColorPaleGoldenrod(); }
    }
    public static Color PaleGreen
    {
        get { return SplashKit.ColorPaleGreen(); }
    }
    public static Color PaleTurquoise
    {
        get { return SplashKit.ColorPaleTurquoise(); }
    }
    public static Color PaleVioletRed
    {
        get { return SplashKit.ColorPaleVioletRed(); }
    }
    public static Color PapayaWhip
    {
        get { return SplashKit.ColorPapayaWhip(); }
    }
    public static Color PeachPuff
    {
        get { return SplashKit.ColorPeachPuff(); }
    }
    public static Color Peru
    {
        get { return SplashKit.ColorPeru(); }
    }
    public static Color Pink
    {
        get { return SplashKit.ColorPink(); }
    }
    public static Color Plum
    {
        get { return SplashKit.ColorPlum(); }
    }
    public static Color PowderBlue
    {
        get { return SplashKit.ColorPowderBlue(); }
    }
    public static Color Purple
    {
        get { return SplashKit.ColorPurple(); }
    }
    public static Color Red
    {
        get { return SplashKit.ColorRed(); }
    }
    public static Color RosyBrown
    {
        get { return SplashKit.ColorRosyBrown(); }
    }
    public static Color RoyalBlue
    {
        get { return SplashKit.ColorRoyalBlue(); }
    }
    public static Color SaddleBrown
    {
        get { return SplashKit.ColorSaddleBrown(); }
    }
    public static Color Salmon
    {
        get { return SplashKit.ColorSalmon(); }
    }
    public static Color SandyBrown
    {
        get { return SplashKit.ColorSandyBrown(); }
    }
    public static Color SeaGreen
    {
        get { return SplashKit.ColorSeaGreen(); }
    }
    public static Color SeaShell
    {
        get { return SplashKit.ColorSeaShell(); }
    }
    public static Color Sienna
    {
        get { return SplashKit.ColorSienna(); }
    }
    public static Color Silver
    {
        get { return SplashKit.ColorSilver(); }
    }
    public static Color SkyBlue
    {
        get { return SplashKit.ColorSkyBlue(); }
    }
    public static Color SlateBlue
    {
        get { return SplashKit.ColorSlateBlue(); }
    }
    public static Color SlateGray
    {
        get { return SplashKit.ColorSlateGray(); }
    }
    public static Color Snow
    {
        get { return SplashKit.ColorSnow(); }
    }
    public static Color SpringGreen
    {
        get { return SplashKit.ColorSpringGreen(); }
    }
    public static Color SteelBlue
    {
        get { return SplashKit.ColorSteelBlue(); }
    }
    public static Color SwinburneRed
    {
        get { return SplashKit.ColorSwinburneRed(); }
    }
    public static Color Tan
    {
        get { return SplashKit.ColorTan(); }
    }
    public static Color Teal
    {
        get { return SplashKit.ColorTeal(); }
    }
    public static Color Thistle
    {
        get { return SplashKit.ColorThistle(); }
    }
    public static Color Tomato
    {
        get { return SplashKit.ColorTomato(); }
    }
    public static Color Transparent
    {
        get { return SplashKit.ColorTransparent(); }
    }
    public static Color Turquoise
    {
        get { return SplashKit.ColorTurquoise(); }
    }
    public static Color Violet
    {
        get { return SplashKit.ColorViolet(); }
    }
    public static Color Wheat
    {
        get { return SplashKit.ColorWheat(); }
    }
    public static Color White
    {
        get { return SplashKit.ColorWhite(); }
    }
    public static Color WhiteSmoke
    {
        get { return SplashKit.ColorWhiteSmoke(); }
    }
    public static Color Yellow
    {
        get { return SplashKit.ColorYellow(); }
    }
    public static Color YellowGreen
    {
        get { return SplashKit.ColorYellowGreen(); }
    }
  }

  [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi ) ]
  internal struct __sklib_rectangle
  {
    public double X;
    public double Y;
    public double Width;
    public double Height;

  }

  public struct Rectangle
  {
    public double X;
    public double Y;
    public double Width;
    public double Height;
  }

  [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi ) ]
  internal struct __sklib_drawing_options
  {
    public IntPtr Dest;
    public float ScaleX;
    public float ScaleY;
    public float Angle;
    public float AnchorOffsetX;
    public float AnchorOffsetY;
    public int FlipX;
    public int FlipY;
    public int IsPart;
    public __sklib_rectangle Part;
    public int DrawCell;
    public int Camera;
    public int LineWidth;
    public __sklib_ptr Anim;

  }

  public struct DrawingOptions
  {
    public IntPtr Dest;
    public float ScaleX;
    public float ScaleY;
    public float Angle;
    public float AnchorOffsetX;
    public float AnchorOffsetY;
    public bool FlipX;
    public bool FlipY;
    public bool IsPart;
    public Rectangle Part;
    public int DrawCell;
    public DrawingDest Camera;
    public int LineWidth;
    public Animation Anim;
  }

  [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi ) ]
  internal struct __sklib_line
  {
    public __sklib_point_2d StartPoint;
    public __sklib_point_2d EndPoint;

  }

  public struct Line
  {
    public Point2D StartPoint;
    public Point2D EndPoint;
  }

  [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi ) ]
  internal struct __sklib_quad
  {
    // Unpacking array due to C# Marshalling limitations
    public __sklib_point_2d Points_0;
    public __sklib_point_2d Points_1;
    public __sklib_point_2d Points_2;
    public __sklib_point_2d Points_3;

  }

  public struct Quad
  {
    public Point2D[] Points;
  }

  [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi ) ]
  internal struct __sklib_triangle
  {
    // Unpacking array due to C# Marshalling limitations
    public __sklib_point_2d Points_0;
    public __sklib_point_2d Points_1;
    public __sklib_point_2d Points_2;

  }

  public struct Triangle
  {
    public Point2D[] Points;
  }

  [ StructLayout( LayoutKind.Sequential, CharSet=CharSet.Ansi ) ]
  internal struct __sklib_vector_2d
  {
    public double X;
    public double Y;

  }

  public struct Vector2D
  {
    public double X;
    public double Y;
  }

    [UnmanagedFunctionPointerAttribute(CallingConvention.Cdecl)]
    public delegate void KeyCallback(int code);

    [UnmanagedFunctionPointerAttribute(CallingConvention.Cdecl)]
    public delegate void FreeNotifier(IntPtr pointer);

    [UnmanagedFunctionPointerAttribute(CallingConvention.Cdecl)]
    public delegate void SpriteEventHandler(IntPtr s, int evt);

    [UnmanagedFunctionPointerAttribute(CallingConvention.Cdecl)]
    public delegate void SpriteFloatFunction(IntPtr s, float f);

    [UnmanagedFunctionPointerAttribute(CallingConvention.Cdecl)]
    public delegate void SpriteFunction(IntPtr s);
//----------------------------------------------------------------------------
// PointerWrapper.cs
//----------------------------------------------------------------------------
//
//  Contains code used by the SplashKit resources.
//
//----------------------------------------------------------------------------

    /// <summary>
    /// Wraps a pointer to a SplashKit resource
    /// </summary>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public abstract class PointerWrapper : IDisposable
    {
        /// <summary>
        /// The ptrRegistry is responsible for maintaining copies of all wrapped SplashKit pointers.
        /// </summary>
        protected static readonly Dictionary<IntPtr, PointerWrapper> _ptrRegister;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        internal static void Remove(IntPtr ptr)
        {
            // System.Console.WriteLine("Delete {0}", ptr);
            if (_ptrRegister.ContainsKey(ptr))
            {
                _ptrRegister.Remove(ptr);
            }
        }

        private static FreeNotifier _RemoveMethod = PointerWrapper.Remove;

        static PointerWrapper()
        {
            //Register Remove with SplashKit
            //Console.WriteLine("Registering");
            _ptrRegister = new Dictionary<IntPtr, PointerWrapper>();
            SplashKit.RegisterFreeNotifier(_RemoveMethod);
        }

        /// <summary>
        /// "Super Dodgy" (but correct) work around for the fact that C# has no unload methods for classes.
        /// </summary>
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        internal class ReleaserClass
        {
            ~ReleaserClass()
            {
                //Console.WriteLine("Deregistering");
                SplashKit.DeregisterFreeNotifier(_RemoveMethod);
            }
        }

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        internal static ReleaserClass releaser = new ReleaserClass();

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected internal IntPtr Pointer;

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        protected internal abstract void DoFree();

        [System.Diagnostics.DebuggerNonUserCode(), System.Diagnostics.DebuggerStepThrough(), System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        internal PointerWrapper(IntPtr ptr, bool register)
        {
            Pointer = ptr;

            if ( ! register ) return;

            if ( PointerWrapper._ptrRegister.ContainsKey(ptr) ) throw new InvalidOperationException("Error managing resources -- attempting to create/load object twice.");
            PointerWrapper._ptrRegister[ptr] = this;
        }

        protected PointerWrapper(PointerWrapper other)
        {
          Pointer = other.Pointer;
        }

        [System.Diagnostics.DebuggerNonUserCode(), System.Diagnostics.DebuggerStepThrough(),System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public static implicit operator IntPtr(PointerWrapper? p)
        {
            if ( p == null ) return IntPtr.Zero;
            else return p.Pointer;
        }

        #region IDisposable Members

        /// <summary>
        /// Clean up the native resources used by this resource.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCode(), System.Diagnostics.DebuggerStepThrough()]
        public void Dispose()
        {
            if (PointerWrapper._ptrRegister.ContainsKey(this.Pointer))
                DoFree();
        }

        #endregion

        /// <summary>
        /// Returns a string representation of the resource. This is in the format
        /// "Type @address".
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCode(), System.Diagnostics.DebuggerStepThrough()]
        public override String ToString()
        {
            return String.Format("{0} @{1:x}", GetType().Name, Pointer);
        }

        /// <summary>
        /// Determines if the PointerWrappers is equal to the passed in object.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCode(), System.Diagnostics.DebuggerStepThrough()]
        public override bool Equals(object? other)
        {
            if (other == null) return this.Pointer == IntPtr.Zero;
            if (other is PointerWrapper) return this.Pointer == ((PointerWrapper)other).Pointer;
            else if (other is IntPtr) return this.Pointer == ((IntPtr)other);
            else return false;
        }

        /// <summary>
        /// Returns the hash code of the PointerWrapper based on what it points to.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCode(), System.Diagnostics.DebuggerStepThrough()]
        public override int GetHashCode()
        {
            return this.Pointer.GetHashCode();
        }

        /// <summary>
        /// Determines if two PointerWrappers are equal.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCode(), System.Diagnostics.DebuggerStepThrough()]
        public static bool operator ==(PointerWrapper? pw1, PointerWrapper? pw2)
        {
            if ((object?)pw1 == null && (object?)pw2 == null) return true;
            if ((object?)pw1 == null || (object?)pw2 == null) return false;
            return pw1.Pointer == pw2.Pointer;
        }

        /// <summary>
        /// Determines if two PointerWrappers are not equal.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCode(), System.Diagnostics.DebuggerStepThrough()]
        public static bool operator !=(PointerWrapper? pw1, PointerWrapper? pw2)
        {
            if ((object?)pw1 == null && (object?)pw2 == null) return false;
            if ((object?)pw1 == null || (object?)pw2 == null) return true;
            return pw1.Pointer != pw2.Pointer;
        }
    }

/// <summary>
/// This class represents Json, which wraps a pointer to SplashKit resources.
/// </summary>
public class Json : PointerWrapper
{
  private Json(IntPtr ptr) : base(ptr, true) {}

  internal static Json FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as Json;
    #pragma warning restore CS8603
    return new Json(ptr);
  }

    /// <summary>
    /// Creates a new instance of Json using the provided parameters.
    /// </summary>
    public Json() : base ( SplashKit.CreateJson(), false )
    { }
    /// <summary>
    /// Creates a new instance of Json using the provided parameters.
    /// </summary>
    /// <param name="jsonString"> The JSON formatted `string` to be converted to a `json` object.</param>
    public Json(string jsonString) : base ( SplashKit.CreateJson(jsonString), false )
    { }
    protected internal override void DoFree()
    {
        SplashKit.FreeJson(this);
    }
    /// <summary>
    /// Releases all of the `json` objects which have been loaded.
    /// </summary>
    public static void FreeAll()
    {
        SplashKit.FreeAllJson();
    }

    /// <summary>
    /// Returns the count of keys in the top-level `json` object.
    /// </summary>
    /// <returns>The count of keys in the top-level `json` object.</returns>
    public int CountKeys()
    {
        return SplashKit.JsonCountKeys(this);
    }

    /// <summary>
    /// Reads a `json` object from a JSON string stored in `Resources/json/filename` and loads the data into the returned `json` object.
    /// </summary>
    /// <param name="filename"> The filename of the file to be written to `Resources/json/`.</param>
    /// <returns>Returns the `json` object loaded from the JSON file in `filename`.</returns>
    public static Json FromFile(string filename)
    {
        return SplashKit.JsonFromFile(filename);
    }

    /// <summary>
    /// Reads a `json` object from a `string` in the JSON format.
    /// </summary>
    /// <param name="jString"> A `string` in the JSON format.</param>
    /// <returns>Returns a `json` object loaded with data from `string j_string`.</returns>
    public static Json FromJsonString(string jString)
    {
        return SplashKit.JsonFromString(jString);
    }

    /// <summary>
    /// Checks if the `json` object contains the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key to be checked.</param>
    /// <returns>Returns `true` if the `json j` object contains a key for `string` key.</returns>
    public bool HasKey(string key)
    {
        return SplashKit.JsonHasKey(this, key);
    }

    /// <summary>
    /// Reads an array of `double` values from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <param name="outResult"> The array which will be filled with the data stored for `string` key.</param>
    public void ReadArray(string key, ref List<double> outResult)
    {
        SplashKit.JsonReadArray(this, key, ref outResult);
    }

    /// <summary>
    /// Reads an array of `json` object values from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <param name="outResult"> The array which will be filled with the data stored for `string` key.</param>
    public void ReadArray(string key, ref List<Json> outResult)
    {
        SplashKit.JsonReadArray(this, key, ref outResult);
    }

    /// <summary>
    /// Reads an array of `string` values from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <param name="outResult"> The array which will be filled with the data stored for `string` key.</param>
    public void ReadArray(string key, ref List<string> outResult)
    {
        SplashKit.JsonReadArray(this, key, ref outResult);
    }

    /// <summary>
    /// Reads an array of `bool` values from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <param name="outResult"> The array which will be filled with the data stored for `string` key.</param>
    public void ReadArray(string key, ref List<bool> outResult)
    {
        SplashKit.JsonReadArray(this, key, ref outResult);
    }

    /// <summary>
    /// Reads a `bool` value from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <returns>Returns the `bool` value stored at the `string` key.</returns>
    public bool ReadBool(string key)
    {
        return SplashKit.JsonReadBool(this, key);
    }

    /// <summary>
    /// Reads a `float` value from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <returns>Returns the `float` value stored at the `string` key.</returns>
    public float ReadNumber(string key)
    {
        return SplashKit.JsonReadNumber(this, key);
    }

    /// <summary>
    /// Reads a `double` value from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <returns>Returns the `double` value stored at the `string` key.</returns>
    public double ReadDouble(string key)
    {
        return SplashKit.JsonReadNumberAsDouble(this, key);
    }

    /// <summary>
    /// Reads a `integer` value from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <returns>Returns the `integer` value stored at the `string` key.</returns>
    public int ReadInteger(string key)
    {
        return SplashKit.JsonReadNumberAsInt(this, key);
    }

    /// <summary>
    /// Reads a `json` object value from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <returns>Returns the `json` object value stored at the `string` key.</returns>
    public Json ReadObject(string key)
    {
        return SplashKit.JsonReadObject(this, key);
    }

    /// <summary>
    /// Reads a `string` value from the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key used to find data in the `json` object.</param>
    /// <returns>Returns the `string` value stored at the `string` key.</returns>
    public string ReadString(string key)
    {
        return SplashKit.JsonReadString(this, key);
    }

    /// <summary>
    /// Adds an array of `string` values to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public void AddArray(string key, List<string> value)
    {
        SplashKit.JsonSetArray(this, key, value);
    }

    /// <summary>
    /// Adds an array of `double` values to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public void AddArray(string key, List<double> value)
    {
        SplashKit.JsonSetArray(this, key, value);
    }

    /// <summary>
    /// Adds an array of `bool` values to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public void AddArray(string key, List<bool> value)
    {
        SplashKit.JsonSetArray(this, key, value);
    }

    /// <summary>
    /// Adds an array of `json` object values to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public void AddArray(string key, List<Json> value)
    {
        SplashKit.JsonSetArray(this, key, value);
    }

    /// <summary>
    /// Adds a `bool` value to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public void AddBool(string key, bool value)
    {
        SplashKit.JsonSetBool(this, key, value);
    }

    /// <summary>
    /// Adds an `int` value to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public void AddNumber(string key, int value)
    {
        SplashKit.JsonSetNumber(this, key, value);
    }

    /// <summary>
    /// Adds a `double` value to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public void AddNumber(string key, double value)
    {
        SplashKit.JsonSetNumber(this, key, value);
    }

    /// <summary>
    /// Adds a `float` value to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public void AddNumber(string key, float value)
    {
        SplashKit.JsonSetNumber(this, key, value);
    }

    /// <summary>
    /// Adds a `json` object to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="obj"> The value to be inserted into the `json` object.</param>
    public void AddObject(string key, Json obj)
    {
        SplashKit.JsonSetObject(this, key, obj);
    }

    /// <summary>
    /// Adds a `string` value to the `json` object for the given `string` key.
    /// </summary>
    /// <param name="key"> The `string` key where data will be stored in the `json` object.</param>
    /// <param name="value"> The value to be inserted into the `json` object.</param>
    public void AddString(string key, string value)
    {
        SplashKit.JsonSetString(this, key, value);
    }

    /// <summary>
    /// Writes the `json` object to a JSON string stored in `Resources/json/filename`.
    /// </summary>
    /// <param name="j"> The `json` object to be written to file.</param>
    /// <param name="filename"> The filename of the file to be stored in `Resources/json/`</param>
    public static void ToFile(Json j, string filename)
    {
        SplashKit.JsonToFile(j, filename);
    }

    /// <summary>
    /// Converts and returns the `json` object as a `string`.
    /// </summary>
    /// <param name="j"> The `json` object to be converted to a `string`.</param>
    /// <returns>Returns the `json` object as a `string`.</returns>
    public static string ToJsonString(Json j)
    {
        return SplashKit.JsonToString(j);
    }

}
/// <summary>
/// This class represents Music, which wraps a pointer to SplashKit resources.
/// </summary>
public class Music : PointerWrapper
{
  private Music(IntPtr ptr) : base(ptr, true) {}

  internal static Music FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as Music;
    #pragma warning restore CS8603
    return new Music(ptr);
  }

    /// <summary>
    /// Creates a new instance of Music using the provided parameters.
    /// </summary>
    /// <param name="name"> The name of the resource for SplashKit</param>
    /// <param name="filename"> The filename to load</param>
    public Music(string name, string filename) : base ( SplashKit.LoadMusic(name, filename), false )
    { }
    protected internal override void DoFree()
    {
        SplashKit.FreeMusic(this);
    }
    /// <summary>
    /// Fades music up to full volume over a specified number of milliseconds.
    /// </summary>
    /// <param name="ms"> How many milliseconds it takes to fade the `music` to full volume</param>
    public void FadeIn(int ms)
    {
        SplashKit.FadeMusicIn(this, ms);
    }

    /// <summary>
    /// Fades music up to full volume over a specified number of milliseconds for a specified number of times.
    /// </summary>
    /// <param name="times"> Controls the number of times the music is played.</param>
    /// <param name="ms"> How many milliseconds it takes to fade the `music` to full volume</param>
    public void FadeIn(int times, int ms)
    {
        SplashKit.FadeMusicIn(this, times, ms);
    }

    /// <summary>
    /// Plays a music file once at full volume.
    /// </summary>
    public void Play()
    {
        SplashKit.PlayMusic(this);
    }

    /// <summary>
    /// Plays a music file a specified number of times at full volume.
    /// </summary>
    /// <param name="times"> Controls the number of times the music is played.</param>
    public void Play(int times)
    {
        SplashKit.PlayMusic(this, times);
    }

    /// <summary>
    /// Plays a music file for a specified number of times and playback volume.
    /// </summary>
    /// <param name="times"> Controls the number of times the music is played.</param>
    /// <param name="volume"> Indicates the percentage of the original volume to play the `music` at. This must be between `0` and `1`.</param>
    public void Play(int times, double volume)
    {
        SplashKit.PlayMusic(this, times, volume);
    }

    /// <summary>
    /// Gets or sets the Filename property of the Music.
    /// </summary>
    public string Filename
    {
        get { return SplashKit.MusicFilename(this); }
    }
    /// <summary>
    /// Gets or sets the Name property of the Music.
    /// </summary>
    public string Name
    {
        get { return SplashKit.MusicName(this); }
    }
}
/// <summary>
/// This class represents Connection, which wraps a pointer to SplashKit resources.
/// </summary>
public class Connection : PointerWrapper
{
  private Connection(IntPtr ptr) : base(ptr, true) {}

  internal static Connection FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as Connection;
    #pragma warning restore CS8603
    return new Connection(ptr);
  }

    /// <summary>
    /// Creates a new instance of Connection using the provided parameters.
    /// </summary>
    /// <param name="name"> The name for the connection</param>
    /// <param name="host"> The address of the server</param>
    /// <param name="port"> The server's port</param>
    public Connection(string name, string host, ushort port) : base ( SplashKit.OpenConnection(name, host, port), false )
    { }
    /// <summary>
    /// Creates a new instance of Connection using the provided parameters.
    /// </summary>
    /// <param name="name"> The name for the connection</param>
    /// <param name="host"> The address of the server</param>
    /// <param name="port"> The server's port</param>
    /// <param name="protocol"> The protocol used to connect to the server</param>
    public Connection(string name, string host, ushort port, ConnectionType protocol) : base ( SplashKit.OpenConnection(name, host, port, protocol), false )
    { }
    protected internal override void DoFree()
    {
        SplashKit.CloseConnection(this);
    }
    /// <summary>
    /// Clear all of the messages from a connection.
    /// </summary>
    public void ClearMessages()
    {
        SplashKit.ClearMessages(this);
    }

    /// <summary>
    /// Close the connection
    /// </summary>
    /// <returns>True if this succeeds.</returns>
    public bool Close()
    {
        return SplashKit.CloseConnection(this);
    }

    /// <summary>
    /// Reads the first message from the connection.
    /// </summary>
    /// <returns>The first message read from the connection</returns>
    public Message ReadMessage()
    {
        return SplashKit.ReadMessage(this);
    }

    /// <summary>
    /// Read message data from a connection.
    /// </summary>
    /// <returns>The data from the first message on the connection</returns>
    public string ReadMessageData()
    {
        return SplashKit.ReadMessageData(this);
    }

    /// <summary>
    /// Attempt to reconnect the connection.
    /// </summary>
    public void Reconnect()
    {
        SplashKit.Reconnect(this);
    }

    /// <summary>
    /// Send a message to the connection.
    /// </summary>
    /// <param name="aMsg"> The message to send</param>
    /// <returns>True if the message sends.</returns>
    public bool SendMessage(string aMsg)
    {
        return SplashKit.SendMessageTo(aMsg, this);
    }

    /// <summary>
    /// Gets or sets the IP property of the Connection.
    /// </summary>
    public uint IP
    {
        get { return SplashKit.ConnectionIP(this); }
    }
    /// <summary>
    /// Gets or sets the Port property of the Connection.
    /// </summary>
    public ushort Port
    {
        get { return SplashKit.ConnectionPort(this); }
    }
    /// <summary>
    /// Gets or sets the HasMessages property of the Connection.
    /// </summary>
    public bool HasMessages
    {
        get { return SplashKit.HasMessages(this); }
    }
    /// <summary>
    /// Gets or sets the IsOpen property of the Connection.
    /// </summary>
    public bool IsOpen
    {
        get { return SplashKit.IsConnectionOpen(this); }
    }
    /// <summary>
    /// Gets or sets the MessageCount property of the Connection.
    /// </summary>
    public uint MessageCount
    {
        get { return SplashKit.MessageCount(this); }
    }
}
/// <summary>
/// This class represents Message, which wraps a pointer to SplashKit resources.
/// </summary>
public class Message : PointerWrapper
{
  private Message(IntPtr ptr) : base(ptr, true) {}

  internal static Message FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as Message;
    #pragma warning restore CS8603
    return new Message(ptr);
  }

    protected internal override void DoFree()
    {
        SplashKit.CloseMessage(this);
    }
    /// <summary>
    /// Closes the message.
    /// </summary>
    public void Close()
    {
        SplashKit.CloseMessage(this);
    }

    /// <summary>
    /// Gets or sets the Data property of the Message.
    /// </summary>
    public string Data
    {
        get { return SplashKit.MessageData(this); }
    }
    /// <summary>
    /// Gets or sets the DataBytes property of the Message.
    /// </summary>
    public List<byte> DataBytes
    {
        get { return SplashKit.MessageDataBytes(this); }
    }
    /// <summary>
    /// Gets or sets the Host property of the Message.
    /// </summary>
    public string Host
    {
        get { return SplashKit.MessageHost(this); }
    }
    /// <summary>
    /// Gets or sets the Port property of the Message.
    /// </summary>
    public ushort Port
    {
        get { return SplashKit.MessagePort(this); }
    }
    /// <summary>
    /// Gets or sets the Protocol property of the Message.
    /// </summary>
    public ConnectionType Protocol
    {
        get { return SplashKit.MessageProtocol(this); }
    }
}
/// <summary>
/// This class represents ServerSocket, which wraps a pointer to SplashKit resources.
/// </summary>
public class ServerSocket : PointerWrapper
{
  private ServerSocket(IntPtr ptr) : base(ptr, true) {}

  internal static ServerSocket FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as ServerSocket;
    #pragma warning restore CS8603
    return new ServerSocket(ptr);
  }

    /// <summary>
    /// Creates a new instance of ServerSocket using the provided parameters.
    /// </summary>
    /// <param name="name"> The name used to access the Server in splashkit</param>
    /// <param name="port"> The port that clients will use to connect to the server</param>
    public ServerSocket(string name, ushort port) : base ( SplashKit.CreateServer(name, port), false )
    { }
    /// <summary>
    /// Creates a new instance of ServerSocket using the provided parameters.
    /// </summary>
    /// <param name="name"> The name used to access the Server in splashkit</param>
    /// <param name="port"> The port that clients will use to connect to the server</param>
    /// <param name="protocol"> The protocol used by the server</param>
    public ServerSocket(string name, ushort port, ConnectionType protocol) : base ( SplashKit.CreateServer(name, port, protocol), false )
    { }
    protected internal override void DoFree()
    {
        SplashKit.CloseServer(this);
    }
    /// <summary>
    /// Accept new connections for a server
    /// </summary>
    /// <returns>True if a connection was accepted</returns>
    public bool AcceptNewConnection()
    {
        return SplashKit.AcceptNewConnection(this);
    }

    /// <summary>
    /// Broadcast a message to all connections of a server.
    /// </summary>
    /// <param name="aMsg"> The message to send</param>
    public void BroadcastMessage(string aMsg)
    {
        SplashKit.BroadcastMessage(aMsg, this);
    }

    /// <summary>
    /// Clear all of the messages from a server.
    /// </summary>
    public void ClearMessages()
    {
        SplashKit.ClearMessages(this);
    }

    /// <summary>
    /// Closes the server, all connections with clients will be shut and the port will be closed.
    /// </summary>
    /// <returns>True if the close was successful</returns>
    public bool Close()
    {
        return SplashKit.CloseServer(this);
    }

    /// <summary>
    /// Get the oldest new connections made to the server, and reduces the new connection count by 1.
    /// </summary>
    /// <returns>The oldest new connection</returns>
    public Connection FetchNewConnection()
    {
        return SplashKit.FetchNewConnection(this);
    }

    /// <summary>
    /// Reads the first message from the server.
    /// </summary>
    /// <returns>The first message read from the server</returns>
    public Message ReadMessage()
    {
        return SplashKit.ReadMessage(this);
    }

    /// <summary>
    /// Read message data from a server.
    /// </summary>
    /// <returns>The data from the first message on the server</returns>
    public string ReadMessageData()
    {
        return SplashKit.ReadMessageData(this);
    }

    /// <summary>
    /// Allows you to reset the new connection count to 0. (The connections are kept)
    /// </summary>
    public void ResetNewConnectionCount()
    {
        SplashKit.ResetNewConnectionCount(this);
    }

    /// <summary>
    /// Get a connection from the server.
    /// </summary>
    /// <param name="idx"> The index of the connection</param>
    /// <returns>The connection at the supplied index</returns>
    public Connection RetrieveConnection(int idx)
    {
        return SplashKit.RetrieveConnection(this, idx);
    }

    /// <summary>
    /// Gets or sets the ConnectionCount property of the ServerSocket.
    /// </summary>
    public uint ConnectionCount
    {
        get { return SplashKit.ConnectionCount(this); }
    }
    /// <summary>
    /// Gets or sets the HasMessages property of the ServerSocket.
    /// </summary>
    public bool HasMessages
    {
        get { return SplashKit.HasMessages(this); }
    }
    /// <summary>
    /// Gets or sets the LastConnection property of the ServerSocket.
    /// </summary>
    public Connection LastConnection
    {
        get { return SplashKit.LastConnection(this); }
    }
    /// <summary>
    /// Gets or sets the MessageCount property of the ServerSocket.
    /// </summary>
    public uint MessageCount
    {
        get { return SplashKit.MessageCount(this); }
    }
    /// <summary>
    /// Gets or sets the NewConnectionCount property of the ServerSocket.
    /// </summary>
    public int NewConnectionCount
    {
        get { return SplashKit.NewConnectionCount(this); }
    }
    /// <summary>
    /// Gets or sets the HasNewConnections property of the ServerSocket.
    /// </summary>
    public bool HasNewConnections
    {
        get { return SplashKit.ServerHasNewConnection(this); }
    }
}
/// <summary>
/// This class represents SoundEffect, which wraps a pointer to SplashKit resources.
/// </summary>
public class SoundEffect : PointerWrapper
{
  private SoundEffect(IntPtr ptr) : base(ptr, true) {}

  internal static SoundEffect FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as SoundEffect;
    #pragma warning restore CS8603
    return new SoundEffect(ptr);
  }

    /// <summary>
    /// Creates a new instance of SoundEffect using the provided parameters.
    /// </summary>
    /// <param name="name"> The name used to refer to the sound effect.</param>
    /// <param name="filename"> The filename used to locate the sound effect to use.</param>
    public SoundEffect(string name, string filename) : base ( SplashKit.LoadSoundEffect(name, filename), false )
    { }
    protected internal override void DoFree()
    {
        SplashKit.FreeSoundEffect(this);
    }
    /// <summary>
    /// Fades out the `sound_effect` over the specified milliseconds.
    /// </summary>
    /// <param name="ms"> The number of milliseconds to fade out the `sound_effect`.</param>
    public void FadeOut(int ms)
    {
        SplashKit.FadeSoundEffectOut(this, ms);
    }

    /// <summary>
    /// Releases the SplashKit resources associated with the sound effect.
    /// </summary>
    public void Close()
    {
        SplashKit.FreeSoundEffect(this);
    }

    /// <summary>
    /// Plays a sound effect once at full volume.
    /// </summary>
    public void Play()
    {
        SplashKit.PlaySoundEffect(this);
    }

    /// <summary>
    /// Plays a sound effect once at playback volume.
    /// </summary>
    /// <param name="volume"> Indicates the percentage of the original volume to play the `sound_effect` at. This must be between `0` and `1`.</param>
    public void Play(double volume)
    {
        SplashKit.PlaySoundEffect(this, volume);
    }

    /// <summary>
    /// Plays a sound effect once at full volume.
    /// </summary>
    /// <param name="times"> Controls the number of times the sound effect is played.</param>
    public void Play(int times)
    {
        SplashKit.PlaySoundEffect(this, times);
    }

    /// <summary>
    /// This version of `play_sound_effect` allows you to control both the number of times the `sound_effect` is repeated and its playback volume.
    /// </summary>
    /// <param name="times"> Controls the number of times the sound effect is played.</param>
    /// <param name="volume"> Indicates the percentage of the original volume to play the `sound_effect` at. This must be between `0` and `1`.</param>
    public void Play(int times, double volume)
    {
        SplashKit.PlaySoundEffect(this, times, volume);
    }

    /// <summary>
    /// Stops the `sound_effect` if it is currently playing
    /// </summary>
    public void Stop()
    {
        SplashKit.StopSoundEffect(this);
    }

    /// <summary>
    /// Gets or sets the Filename property of the SoundEffect.
    /// </summary>
    public string Filename
    {
        get { return SplashKit.SoundEffectFilename(this); }
    }
    /// <summary>
    /// Gets or sets the Name property of the SoundEffect.
    /// </summary>
    public string Name
    {
        get { return SplashKit.SoundEffectName(this); }
    }
    /// <summary>
    /// Gets or sets the IsPlaying property of the SoundEffect.
    /// </summary>
    public bool IsPlaying
    {
        get { return SplashKit.SoundEffectPlaying(this); }
    }
}
/// <summary>
/// This class represents Sprite, which wraps a pointer to SplashKit resources.
/// </summary>
public class Sprite : PointerWrapper
{
  private Sprite(IntPtr ptr) : base(ptr, true) {}

  internal static Sprite FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as Sprite;
    #pragma warning restore CS8603
    return new Sprite(ptr);
  }

    /// <summary>
    /// Creates a new instance of Sprite using the provided parameters.
    /// </summary>
    /// <param name="layer"> The bitmap for the sprite's image.</param>
    public Sprite(Bitmap layer) : base ( SplashKit.CreateSprite(layer), false )
    { }
    /// <summary>
    /// Creates a new instance of Sprite using the provided parameters.
    /// </summary>
    /// <param name="layer"> The bitmap for the sprite's image.</param>
    /// <param name="ani"> The animation script for the sprite's animations.</param>
    public Sprite(Bitmap layer, AnimationScript ani) : base ( SplashKit.CreateSprite(layer, ani), false )
    { }
    /// <summary>
    /// Creates a new instance of Sprite using the provided parameters.
    /// </summary>
    /// <param name="bitmapName"> The name of the bitmap to use as the sprite's layer</param>
    public Sprite(string bitmapName) : base ( SplashKit.CreateSprite(bitmapName), false )
    { }
    /// <summary>
    /// Creates a new instance of Sprite using the provided parameters.
    /// </summary>
    /// <param name="name"> The name of the sprite for resource management.</param>
    /// <param name="layer"> The bitmap for the sprite's image.</param>
    public Sprite(string name, Bitmap layer) : base ( SplashKit.CreateSprite(name, layer), false )
    { }
    /// <summary>
    /// Creates a new instance of Sprite using the provided parameters.
    /// </summary>
    /// <param name="name"> The name of the sprite for resource management.</param>
    /// <param name="layer"> The bitmap for the sprite's image.</param>
    /// <param name="ani"> The animation script for the sprite's animations.</param>
    public Sprite(string name, Bitmap layer, AnimationScript ani) : base ( SplashKit.CreateSprite(name, layer, ani), false )
    { }
    /// <summary>
    /// Creates a new instance of Sprite using the provided parameters.
    /// </summary>
    /// <param name="bitmapName"> The name of the bitmap to use as the sprite's image.</param>
    /// <param name="animationName"> The name of the animation script to use for this sprite.</param>
    public Sprite(string bitmapName, string animationName) : base ( SplashKit.CreateSprite(bitmapName, animationName), false )
    { }
    protected internal override void DoFree()
    {
        SplashKit.FreeSprite(this);
    }
    /// <summary>
    /// Tests if a sprite will collide with a bitmap drawn at the indicated location.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <returns>True if the sprite collides with the bitmap when drawn at the indicated location.</returns>
    public bool BitmapCollision(Bitmap bmp, double x, double y)
    {
        return SplashKit.SpriteBitmapCollision(this, bmp, x, y);
    }

    /// <summary>
    /// Tests if a sprite will collide with a bitmap drawn at the indicated location.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="pt"> The point where the bitmap is drawn</param>
    /// <returns>True if the sprite collides with the bitmap cell when drawn at the indicated location.</returns>
    public bool BitmapCollision(Bitmap bmp, int cell, Point2D pt)
    {
        return SplashKit.SpriteBitmapCollision(this, bmp, cell, pt);
    }

    /// <summary>
    /// Tests if a sprite will collide with a bitmap drawn at the indicated location.
    /// </summary>
    /// <param name="bmp"> The bitmap to test</param>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <returns>True if the sprite collides with the bitmap cell when drawn at the indicated location.</returns>
    public bool BitmapCollision(Bitmap bmp, int cell, double x, double y)
    {
        return SplashKit.SpriteBitmapCollision(this, bmp, cell, x, y);
    }

    /// <summary>
    /// Tests if a sprite is drawn within an given area (circle).
    /// </summary>
    /// <param name="c"> The circle to check</param>
    /// <returns>True if the sprite it drawn in the circle area</returns>
    public bool CircleCollision(Circle c)
    {
        return SplashKit.SpriteCircleCollision(this, c);
    }

    /// <summary>
    /// Tests if two given sprites `s1` and `s2` are collided
    /// </summary>
    /// <param name="s2"> the second `sprite` to test</param>
    /// <returns>return `true` if both `s1` and `s2` are colliding, false otherwise.</returns>
    public bool SpriteCollision(Sprite s2)
    {
        return SplashKit.SpriteCollision(this, s2);
    }

    /// <summary>
    /// Tests if a sprite is drawn at a given point.
    /// </summary>
    /// <param name="pt"> The point to check</param>
    /// <returns>True if the sprite it drawn at the indicated point</returns>
    public bool PointCollision(Point2D pt)
    {
        return SplashKit.SpritePointCollision(this, pt);
    }

    /// <summary>
    /// Tests if a sprite is drawn within an given area (quad).
    /// </summary>
    /// <param name="q"> The quad to check</param>
    /// <returns>True if the sprite it drawn in the quad area</returns>
    public bool QuadCollision(Quad q)
    {
        return SplashKit.SpriteQuadCollision(this, q);
    }

    /// <summary>
    /// Tests if a sprite is drawn along a given ray.
    /// </summary>
    /// <param name="origin"> The origin of the ray</param>
    /// <param name="heading"> The heading of the ray</param>
    /// <returns>True if the sprite is drawn along the ray</returns>
    public bool RayCollision(Point2D origin, Vector2D heading)
    {
        return SplashKit.SpriteRayCollision(this, origin, heading);
    }

    /// <summary>
    /// Tests if a sprite is drawn within an given area (rectangle).
    /// </summary>
    /// <param name="rect"> The rectangle to check</param>
    /// <returns>True if the sprite it drawn in the rectangle area</returns>
    public bool RectangleCollision(Rectangle rect)
    {
        return SplashKit.SpriteRectangleCollision(this, rect);
    }

    /// <summary>
    /// Tests if a sprite is drawn within an given area (triangle).
    /// </summary>
    /// <param name="t"> The triangle to check</param>
    /// <returns>True if the sprite it drawn in the triangle area</returns>
    public bool TriangleCollision(Triangle t)
    {
        return SplashKit.SpriteTriangleCollision(this, t);
    }

    /// <summary>
    /// Draws the sprite at its position in the game offset by a given amount. Only use this method when you want to draw the sprite displaced from its location in your game. Otherwise you should change the sprite's location and then use the standard ''draw_sprite'' routine.
    /// </summary>
    /// <param name="offset"> The amount to offset the sprite.</param>
    public void Draw(Vector2D offset)
    {
        SplashKit.DrawSprite(this, offset);
    }

    /// <summary>
    /// Draws the sprite at its location in the world. This is affected by the position of the camera and the sprites current location.  This is the standard routine for drawing sprites to the screen and should be used in most cases.
    /// </summary>
    public void Draw()
    {
        SplashKit.DrawSprite(this);
    }

    /// <summary>
    /// Draws the sprite at its position in the game offset by a given amount. Only use this method when you want to draw the sprite displaced from its location in your game. Otherwise you should change the sprite's location and then use the standard `draw_sprite` routine.
    /// </summary>
    /// <param name="xOffset"> The amount to offset on the x axis.</param>
    /// <param name="yOffset"> The amount to offset on the y axis.</param>
    public void Draw(double xOffset, double yOffset)
    {
        SplashKit.DrawSprite(this, xOffset, yOffset);
    }

    /// <summary>
    /// moves the sprite as indicated by its velocity. You can call this directly ot alternatively, this action is performed when the sprite is updated using the ''update_sprite'' routine.
    /// </summary>
    public void Move()
    {
        SplashKit.MoveSprite(this);
    }

    /// <summary>
    /// Moves the sprite a given distance based on the value passed in rather than based on the sprite's velocity. Typically this method is used to apply other movement actions to the sprite and the velocity of the sprite is used the intended movement of the sprite.
    /// </summary>
    /// <param name="distance"> The vector that represents the direction and distance to move the sprite.</param>
    public void Move(Vector2D distance)
    {
        SplashKit.MoveSprite(this, distance);
    }

    /// <summary>
    /// Moves the sprite a percentage of a given distance based on the value passed in rather than based on the sprite's velocity. Typically this method is used to apply other movement actions to the sprite and the velocity of the sprite is used the intended movement of the sprite.
    /// </summary>
    /// <param name="distance"> The vector that represents the direction and distance to move the sprite.</param>
    /// <param name="pct"> The percentage of the distance to move the sprite.</param>
    public void Move(Vector2D distance, float pct)
    {
        SplashKit.MoveSprite(this, distance, pct);
    }

    /// <summary>
    /// Moves the sprite as indicated by a percentage of its velocity. You can call this directly ot alternatively, this action is performed when the sprite is updated using the ''update_sprite'' routines that require a percentage.
    /// </summary>
    /// <param name="pct"> The percentage of the sprite's velocity to move.</param>
    public void Move(float pct)
    {
        SplashKit.MoveSprite(this, pct);
    }

    /// <summary>
    /// This method moves a sprite to a given position in the game.
    /// </summary>
    /// <param name="x"> The sprite's new x location.</param>
    /// <param name="y"> The sprite's new y location.</param>
    public void MoveTo(double x, double y)
    {
        SplashKit.MoveSpriteTo(this, x, y);
    }

    /// <summary>
    /// Adds a new layer to the sprite.
    /// </summary>
    /// <param name="newLayer"> The new layer's bitmap.</param>
    /// <param name="layerName"> The name of the new layer.</param>
    /// <returns>The index of the new layer.</returns>
    public int AddLayer(Bitmap newLayer, string layerName)
    {
        return SplashKit.SpriteAddLayer(this, newLayer, layerName);
    }

    /// <summary>
    /// Alters the current velocity of the sprite, adding the passed in vector_2d to the current velocity. When the sprite is updated (see `update_sprite`) this vector_2d is used to move the sprite.
    /// </summary>
    /// <param name="value"> The amount to add to the sprite's velocity.</param>
    public void AddToVelocity(Vector2D value)
    {
        SplashKit.SpriteAddToVelocity(this, value);
    }

    /// <summary>
    /// Adds a new kind of value to the sprite
    /// </summary>
    /// <param name="name"> The name of the new value to store in the sprite.</param>
    public void AddValue(string name)
    {
        SplashKit.SpriteAddValue(this, name);
    }

    /// <summary>
    /// Adds a new kind of value to the sprite, setting the initial value to the value passed in.
    /// </summary>
    /// <param name="name"> The name of the new value to store in the sprite.</param>
    /// <param name="initVal"> The initial value.</param>
    public void AddValue(string name, float initVal)
    {
        SplashKit.SpriteAddValue(this, name, initVal);
    }

    /// <summary>
    /// Returns the name of the sprite's current animation.
    /// </summary>
    /// <returns>The name of the current animation.</returns>
    public string AnimationName()
    {
        return SplashKit.SpriteAnimationName(this);
    }

    /// <summary>
    /// Sends the layer specified forward in the visible layer order.
    /// </summary>
    /// <param name="visibleLayer"> The visible layer to bring forward</param>
    public void SendLayerForward(int visibleLayer)
    {
        SplashKit.SpriteBringLayerForward(this, visibleLayer);
    }

    /// <summary>
    /// Sends the layer specified to the front in the visible layer order.
    /// </summary>
    /// <param name="visibleLayer"> The visible layer to bring to the front</param>
    public void SendLayerTofront(int visibleLayer)
    {
        SplashKit.SpriteBringLayerToFront(this, visibleLayer);
    }

    /// <summary>
    /// Register a procedure to call when events occur on the sprite.
    /// </summary>
    /// <param name="handler"> The function to call when this sprite raises an event.</param>
    public void CallOnEvent(SpriteEventHandler handler)
    {
        SplashKit.SpriteCallOnEvent(this, handler);
    }

    /// <summary>
    /// Gets a circle in the bounds of the base layer of the indicated sprite.
    /// </summary>
    /// <returns>A bounding circle that surrounds the sprite</returns>
    public Circle Circle()
    {
        return SplashKit.SpriteCircle(this);
    }

    /// <summary>
    /// Gets a circle in the bounds of the indicated sprite's collision rectangle.
    /// </summary>
    /// <returns>A bounding circle that surrounds the sprite</returns>
    public Circle CollisionCircle()
    {
        return SplashKit.SpriteCollisionCircle(this);
    }

    /// <summary>
    /// Hide the specified layer of the sprite.
    /// </summary>
    /// <param name="name"> The name of the layer to hide.</param>
    public void HideLayer(string name)
    {
        SplashKit.SpriteHideLayer(this, name);
    }

    /// <summary>
    /// Hide the specified layer of the sprite.
    /// </summary>
    /// <param name="id"> The index of the layer to hide.</param>
    public void HideLayer(int id)
    {
        SplashKit.SpriteHideLayer(this, id);
    }

    /// <summary>
    /// Returns the bitmap of the indicated layer of the sprite.
    /// </summary>
    /// <param name="name"> The name of the layer to fetch</param>
    /// <returns>The bitmap at the layer with the indicated name</returns>
    public Bitmap Layer(string name)
    {
        return SplashKit.SpriteLayer(this, name);
    }

    /// <summary>
    /// Returns the bitmap of the indicated layer of the sprite.
    /// </summary>
    /// <param name="idx"> The index of the layer</param>
    /// <returns>The bitmap of the sprite at that layer</returns>
    public Bitmap Layer(int idx)
    {
        return SplashKit.SpriteLayer(this, idx);
    }

    /// <summary>
    /// Gets a circle in the bounds of the indicated layer.
    /// </summary>
    /// <param name="name"> The name of the layer.</param>
    /// <returns>A bounding circle that surrounds the sprite's layer</returns>
    public Circle LayerCircle(string name)
    {
        return SplashKit.SpriteLayerCircle(this, name);
    }

    /// <summary>
    /// Gets a circle in the bounds of the indicated layer.
    /// </summary>
    /// <param name="idx"> The index of the layer.</param>
    /// <returns>A bounding circle that surrounds the sprite's layer</returns>
    public Circle LayerCircle(int idx)
    {
        return SplashKit.SpriteLayerCircle(this, idx);
    }

    /// <summary>
    /// The height of a given layer of the sprite (aligned to the Y axis).
    /// </summary>
    /// <param name="name"> The name of the layer to get the details of.</param>
    /// <returns>The height of the sprite's layer in pixels.</returns>
    public int LayerHeight(string name)
    {
        return SplashKit.SpriteLayerHeight(this, name);
    }

    /// <summary>
    /// The height of a given layer of the sprite (aligned to the Y axis).
    /// </summary>
    /// <param name="idx"> The index of the layer to get the details of.</param>
    /// <returns>The height of the sprite's layer in pixels.</returns>
    public int LayerHeight(int idx)
    {
        return SplashKit.SpriteLayerHeight(this, idx);
    }

    /// <summary>
    /// Returns the index of the specified layer.
    /// </summary>
    /// <param name="name"> The name of the layer to get the index of</param>
    /// <returns>The index of the layer in the sprite</returns>
    public int IndexOfLayer(string name)
    {
        return SplashKit.SpriteLayerIndex(this, name);
    }

    /// <summary>
    /// Returns the name of the specified layer.
    /// </summary>
    /// <param name="idx"> The index of the layer you want the name of</param>
    /// <returns>The name of the sprite's layer at that index</returns>
    public string LayerName(int idx)
    {
        return SplashKit.SpriteLayerName(this, idx);
    }

    /// <summary>
    /// Gets the offset of the specified layer.
    /// </summary>
    /// <param name="name"> The name of the layer to get the offset of.</param>
    /// <returns>The offset of the named layer in the sprite.</returns>
    public Vector2D LayerOffset(string name)
    {
        return SplashKit.SpriteLayerOffset(this, name);
    }

    /// <summary>
    /// Gets the offset of the specified layer.
    /// </summary>
    /// <param name="idx"> The index of the layer to get the offset of.</param>
    /// <returns>The offset of the layer in the sprite.</returns>
    public Vector2D LayerOffset(int idx)
    {
        return SplashKit.SpriteLayerOffset(this, idx);
    }

    /// <summary>
    /// Gets a rectangle that surrounds the indicated layer.
    /// </summary>
    /// <param name="name"> The name of the layer.</param>
    /// <returns>A bounding rectangle that surrounds the sprite's layer</returns>
    public Rectangle LayerRectangle(string name)
    {
        return SplashKit.SpriteLayerRectangle(this, name);
    }

    /// <summary>
    /// Gets a rectangle that surrounds the indicated layer.
    /// </summary>
    /// <param name="idx"> The index of the layer.</param>
    /// <returns>A bounding rectangle that surrounds the sprite's layer</returns>
    public Rectangle LayerRectangle(int idx)
    {
        return SplashKit.SpriteLayerRectangle(this, idx);
    }

    /// <summary>
    /// The width of a given layer of the sprite (aligned to the X axis).
    /// </summary>
    /// <param name="name"> The name of the layer to get the details of.</param>
    /// <returns>The width of the sprite's layer in pixels.</returns>
    public int LayerWidth(string name)
    {
        return SplashKit.SpriteLayerWidth(this, name);
    }

    /// <summary>
    /// The width of a given layer of the sprite (aligned to the X axis).
    /// </summary>
    /// <param name="idx"> The index of the layer to get the details of.</param>
    /// <returns>The width of the sprite's layer in pixels.</returns>
    public int LayerWidth(int idx)
    {
        return SplashKit.SpriteLayerWidth(this, idx);
    }

    /// <summary>
    /// This void starts the sprite moving to the indicated destination point, over a specified number of seconds. When the sprite arrives it will raise the sprite_arrived event.
    /// </summary>
    /// <param name="pt"> The sprite's destination.</param>
    /// <param name="takingSeconds"> The time the sprite should take to get to pt.</param>
    public void MoveTo(Point2D pt, float takingSeconds)
    {
        SplashKit.SpriteMoveTo(this, pt, takingSeconds);
    }

    /// <summary>
    /// Returns true if the sprite is entirely off the current screen.
    /// </summary>
    /// <returns>True if the sprite is entirely off the current window.</returns>
    public bool Offscreen()
    {
        return SplashKit.SpriteOffscreen(this);
    }

    /// <summary>
    /// Returns true if a pixel of the `sprite` `s` is at the screen location specified (`pt`), which is converted to a world location.
    /// </summary>
    /// <param name="pt"> The location in screen coordinates to check.</param>
    /// <returns>True if the sprite would draw something at this coordinate on the screen when drawn.</returns>
    public bool OnScreenAt(Point2D pt)
    {
        return SplashKit.SpriteOnScreenAt(this, pt);
    }

    /// <summary>
    /// Returns true if a pixel of the `sprite` `s` is at the screen location specified.
    /// </summary>
    /// <param name="x"> The x location in screen coordinates to check.</param>
    /// <param name="y"> The y location in screen coordinates to check.</param>
    /// <returns>True if the sprite would draw something at this coordinate on the screen when drawn.</returns>
    public bool OnScreenAt(double x, double y)
    {
        return SplashKit.SpriteOnScreenAt(this, x, y);
    }

    /// <summary>
    /// Restart the sprite's current animation, this will play a sound if the first cell of the animation is associated with a sound effect.
    /// </summary>
    public void ReplayAnimation()
    {
        SplashKit.SpriteReplayAnimation(this);
    }

    /// <summary>
    /// Restart the sprite's current animation, this will play a sound if with_sound is true and the first cell of the animation is associated with a sound effect.
    /// </summary>
    /// <param name="withSound"> If false, the animation will not play associated sound effects when restarted.</param>
    public void ReplayAnimation(bool withSound)
    {
        SplashKit.SpriteReplayAnimation(this, withSound);
    }

    /// <summary>
    /// Sends the layer specified backward in the visible layer order.
    /// </summary>
    /// <param name="visibleLayer"> The visible layer to send to backward</param>
    public void SendLayerTobackward(int visibleLayer)
    {
        SplashKit.SpriteSendLayerBackward(this, visibleLayer);
    }

    /// <summary>
    /// Sends the layer specified to the back in the visible layer order.
    /// </summary>
    /// <param name="visibleLayer"> The visible layer to send to back</param>
    public void SendLayerToBack(int visibleLayer)
    {
        SplashKit.SpriteSendLayerToBack(this, visibleLayer);
    }

    /// <summary>
    /// Sets the offset of the specified layer. The offset is used when the layer is drawn in the sprite, and moves the image relative to the sprite.
    /// </summary>
    /// <param name="name"> The name of the layer to change.</param>
    /// <param name="value"> The new offset.</param>
    public void SetLayerOffset(string name, Vector2D value)
    {
        SplashKit.SpriteSetLayerOffset(this, name, value);
    }

    /// <summary>
    /// Sets the offset of the specified layer.
    /// </summary>
    /// <param name="idx"> The index of the layer to change.</param>
    /// <param name="value"> The new offset.</param>
    public void SetLayerOffset(int idx, Vector2D value)
    {
        SplashKit.SpriteSetLayerOffset(this, idx, value);
    }

    /// <summary>
    /// Assigns a value to the sprite.
    /// </summary>
    /// <param name="name"> The name of the value to change</param>
    /// <param name="val"> The new value.</param>
    public void SetValue(string name, float val)
    {
        SplashKit.SpriteSetValue(this, name, val);
    }

    /// <summary>
    /// Show the specified layer of the sprite.
    /// </summary>
    /// <param name="name"> The layer to show.</param>
    /// <returns>The index of the layer shown, or -1 if no layer found.</returns>
    public int ShowLayer(string name)
    {
        return SplashKit.SpriteShowLayer(this, name);
    }

    /// <summary>
    /// Show the specified layer of the sprite.
    /// </summary>
    /// <param name="id"> The index to show.</param>
    /// <returns>The index of the layer shown, or -1 if no layer found.</returns>
    public int ShowLayer(int id)
    {
        return SplashKit.SpriteShowLayer(this, id);
    }

    /// <summary>
    /// Start playing an animation from the sprite's animation template. This will play a sound effect if the first cell of the animation has a sound.
    /// </summary>
    /// <param name="named"> The name of the animation to start from the animation script.</param>
    public void StartAnimation(string named)
    {
        SplashKit.SpriteStartAnimation(this, named);
    }

    /// <summary>
    /// Start playing an animation from the sprite's animation template. The with_sound parameter determines whether to play a sound effect if the first cell of the animation has a sound.
    /// </summary>
    /// <param name="named"> The name of the animation to start from the animation script.</param>
    /// <param name="withSound"> If false, the animation will not play associated sound effects when started.</param>
    public void StartAnimation(string named, bool withSound)
    {
        SplashKit.SpriteStartAnimation(this, named, withSound);
    }

    /// <summary>
    /// Start playing an animation from the sprite's animation template. This will play a sound effect if the first cell of the animation has a sound.
    /// </summary>
    /// <param name="idx"> The index of the animation to start from the animation script.</param>
    public void StartAnimation(int idx)
    {
        SplashKit.SpriteStartAnimation(this, idx);
    }

    /// <summary>
    /// Start playing an animation from the sprite's animation template. The with_sound parameter determines whether to play a sound effect if the first cell of the animation has a sound.
    /// </summary>
    /// <param name="idx"> The index of the animation to start from the animation script.</param>
    /// <param name="withSound"> If false, the animation will not play associated sound effects when started.</param>
    public void StartAnimation(int idx, bool withSound)
    {
        SplashKit.SpriteStartAnimation(this, idx, withSound);
    }

    /// <summary>
    /// Removes an event handler from the sprite, stopping events from this sprite calling the indicated method.
    /// </summary>
    /// <param name="handler"> The function to remove from this sprites handlers</param>
    public void StopCallingOnEvent(SpriteEventHandler handler)
    {
        SplashKit.SpriteStopCallingOnEvent(this, handler);
    }

    /// <summary>
    /// Toggle the visibility of the specified layer of the sprite.
    /// </summary>
    /// <param name="name"> The name of the layer to toggle.</param>
    public void ToggleLayerVisible(string name)
    {
        SplashKit.SpriteToggleLayerVisible(this, name);
    }

    /// <summary>
    /// Toggle the visibility of the specified layer of the sprite.
    /// </summary>
    /// <param name="id"> The index of the layer to toggle.</param>
    public void ToggleLayerVisible(int id)
    {
        SplashKit.SpriteToggleLayerVisible(this, id);
    }

    /// <summary>
    /// Returns the indicated value of the sprite
    /// </summary>
    /// <param name="name"> The name of the value to fetch.</param>
    /// <returns>The value from the sprite's data store.</returns>
    public float Value(string name)
    {
        return SplashKit.SpriteValue(this, name);
    }

    /// <summary>
    /// Returns the index (z-order) of the sprite's layer.
    /// </summary>
    /// <param name="name"> The name of the layer to get the z index of.</param>
    /// <returns>The z index of the sprite's layer</returns>
    public int VisibleIndexOfLayer(string name)
    {
        return SplashKit.SpriteVisibleIndexOfLayer(this, name);
    }

    /// <summary>
    /// Returns the index (z-order) of the sprite's layer.
    /// </summary>
    /// <param name="id"> The index of the layer to get the z index of.</param>
    /// <returns>The z index of the sprite's layer</returns>
    public int VisibleIndexOfLayer(int id)
    {
        return SplashKit.SpriteVisibleIndexOfLayer(this, id);
    }

    /// <summary>
    /// Returns the index of the n'th (idx parameter) visible layer.
    /// </summary>
    /// <param name="idx"> The index of the visible layer to fetch.</param>
    /// <returns>The layer index of the selected visible layer.</returns>
    public int VisibleLayer(int idx)
    {
        return SplashKit.SpriteVisibleLayer(this, idx);
    }

    /// <summary>
    /// Returns the id of the layer at index `idx` that is currently visible. Index 0 is the background, with larger indexes moving toward the foreground. This returns -1 if there are no visible layers.
    /// </summary>
    /// <param name="idx"> The index of the visible layer.</param>
    /// <returns>The layer index of the visible layer.</returns>
    public int VisibleLayerIdAt(int idx)
    {
        return SplashKit.SpriteVisibleLayerId(this, idx);
    }

    /// <summary>
    /// Update the position and animation details of the sprite. This will play a sound effect if the new cell of the animation has a sound.
    /// </summary>
    public void Update()
    {
        SplashKit.UpdateSprite(this);
    }

    /// <summary>
    /// Update the position and animation details of the sprite. This will play a sound effect if the new cell of the animation has a sound and with_sound is true.
    /// </summary>
    /// <param name="withSound"> If false, animations will not play associated sound effects when updated.</param>
    public void Update(bool withSound)
    {
        SplashKit.UpdateSprite(this, withSound);
    }

    /// <summary>
    /// Update the position and animation details of the sprite by a given percentage of a single unit of movement/animation. This will play a sound effect if the new cell of the animation has a sound.
    /// </summary>
    /// <param name="pct"> The percent to update.</param>
    public void Update(float pct)
    {
        SplashKit.UpdateSprite(this, pct);
    }

    /// <summary>
    /// Update the position and animation details of the sprite by a given percentage of a single unit of movement/animation. This will play a sound effect if the new cell of the animation has a sound and with_sound is true.
    /// </summary>
    /// <param name="pct"> The percent to update.</param>
    /// <param name="withSound"> If false, animations will not play associated sound effects when updated.</param>
    public void Update(float pct, bool withSound)
    {
        SplashKit.UpdateSprite(this, pct, withSound);
    }

    /// <summary>
    /// Updates the animation details of the sprite. This will play a sound effect if the new cell of the animation has a sound.
    /// </summary>
    public void UpdateAnimation()
    {
        SplashKit.UpdateSpriteAnimation(this);
    }

    /// <summary>
    /// Update the animation details of the sprite. This will play a sound effect if the new cell of the animation has a sound and with_sound is true.
    /// </summary>
    /// <param name="withSound"> If false, animations will not play associated sound effects when updated.</param>
    public void UpdateAnimation(bool withSound)
    {
        SplashKit.UpdateSpriteAnimation(this, withSound);
    }

    /// <summary>
    /// Update the animation details of the sprite by a given percentage of a single unit of movement/animation. This will play a sound effect if the new cell of the animation has a sound.
    /// </summary>
    /// <param name="pct"> The percent to update.</param>
    public void UpdateAnimation(float pct)
    {
        SplashKit.UpdateSpriteAnimation(this, pct);
    }

    /// <summary>
    /// Update the position and animation details of the sprite by a given percentage of a single unit of movement/animation. This will play a sound effect if the new cell of the animation has a sound and with_sound is true.
    /// </summary>
    /// <param name="pct"> The percent to update.</param>
    /// <param name="withSound"> If false, animations will not play associated sound effects when updated.</param>
    public void UpdateAnimation(float pct, bool withSound)
    {
        SplashKit.UpdateSpriteAnimation(this, pct, withSound);
    }

    /// <summary>
    /// Returns a `vector_2d` that is the difference in location from the center of the sprite `s` to the point `pt`.
    /// </summary>
    /// <param name="pt"> The point that is at the end of the vector.</param>
    /// <returns>A vector pointing from the sprite to the point.</returns>
    public Vector2D VectorTo(Point2D pt)
    {
        return SplashKit.VectorFromCenterSpriteToPoint(this, pt);
    }

    /// <summary>
    /// Returns a `vector_2d` that is the difference in the position of two sprites (`s1` and `s2`).
    /// </summary>
    /// <param name="s2"> The sprite that is at the end of the vector.</param>
    /// <returns>A vector that points from s1 to s2.</returns>
    public Vector2D VectorTo(Sprite s2)
    {
        return SplashKit.VectorFromTo(this, s2);
    }

    /// <summary>
    /// Gets or sets the AnchorPoint property of the Sprite.
    /// </summary>
    public Point2D AnchorPoint
    {
        get { return SplashKit.SpriteAnchorPoint(this); }
        set { SplashKit.SpriteSetAnchorPoint(this, value); }
    }
    /// <summary>
    /// Gets or sets the AnimationHasEnded property of the Sprite.
    /// </summary>
    public bool AnimationHasEnded
    {
        get { return SplashKit.SpriteAnimationHasEnded(this); }
    }
    /// <summary>
    /// Gets or sets the SpriteCenterPoint property of the Sprite.
    /// </summary>
    public Point2D SpriteCenterPoint
    {
        get { return SplashKit.SpriteCenterPoint(this); }
    }
    /// <summary>
    /// Gets or sets the CollisionBitmap property of the Sprite.
    /// </summary>
    public Bitmap CollisionBitmap
    {
        get { return SplashKit.SpriteCollisionBitmap(this); }
        set { SplashKit.SpriteSetCollisionBitmap(this, value); }
    }
    /// <summary>
    /// Gets or sets the CollisionKind property of the Sprite.
    /// </summary>
    public CollisionTestKind CollisionKind
    {
        get { return SplashKit.SpriteCollisionKind(this); }
        set { SplashKit.SpriteSetCollisionKind(this, value); }
    }
    /// <summary>
    /// Gets or sets the CollisionRectangle property of the Sprite.
    /// </summary>
    public Rectangle CollisionRectangle
    {
        get { return SplashKit.SpriteCollisionRectangle(this); }
    }
    /// <summary>
    /// Gets or sets the CurrentCell property of the Sprite.
    /// </summary>
    public int CurrentCell
    {
        get { return SplashKit.SpriteCurrentCell(this); }
    }
    /// <summary>
    /// Gets or sets the CurrentCellRectangle property of the Sprite.
    /// </summary>
    public Rectangle CurrentCellRectangle
    {
        get { return SplashKit.SpriteCurrentCellRectangle(this); }
    }
    /// <summary>
    /// Gets or sets the Dx property of the Sprite.
    /// </summary>
    public double Dx
    {
        get { return SplashKit.SpriteDx(this); }
        set { SplashKit.SpriteSetDx(this, value); }
    }
    /// <summary>
    /// Gets or sets the Dy property of the Sprite.
    /// </summary>
    public double Dy
    {
        get { return SplashKit.SpriteDy(this); }
        set { SplashKit.SpriteSetDy(this, value); }
    }
    /// <summary>
    /// Gets or sets the Heading property of the Sprite.
    /// </summary>
    public float Heading
    {
        get { return SplashKit.SpriteHeading(this); }
        set { SplashKit.SpriteSetHeading(this, value); }
    }
    /// <summary>
    /// Gets or sets the Height property of the Sprite.
    /// </summary>
    public int Height
    {
        get { return SplashKit.SpriteHeight(this); }
    }
    /// <summary>
    /// Gets or sets the LayerCount property of the Sprite.
    /// </summary>
    public int LayerCount
    {
        get { return SplashKit.SpriteLayerCount(this); }
    }
    /// <summary>
    /// Gets or sets the LocationMatrix property of the Sprite.
    /// </summary>
    public Matrix2D LocationMatrix
    {
        get { return SplashKit.SpriteLocationMatrix(this); }
    }
    /// <summary>
    /// Gets or sets the Mass property of the Sprite.
    /// </summary>
    public float Mass
    {
        get { return SplashKit.SpriteMass(this); }
        set { SplashKit.SpriteSetMass(this, value); }
    }
    /// <summary>
    /// Gets or sets the MoveFromAnchorPoint property of the Sprite.
    /// </summary>
    public bool MoveFromAnchorPoint
    {
        get { return SplashKit.SpriteMoveFromAnchorPoint(this); }
        set { SplashKit.SpriteSetMoveFromAnchorPoint(this, value); }
    }
    /// <summary>
    /// Gets or sets the Name property of the Sprite.
    /// </summary>
    public string Name
    {
        get { return SplashKit.SpriteName(this); }
    }
    /// <summary>
    /// Gets or sets the Position property of the Sprite.
    /// </summary>
    public Point2D Position
    {
        get { return SplashKit.SpritePosition(this); }
        set { SplashKit.SpriteSetPosition(this, value); }
    }
    /// <summary>
    /// Gets or sets the Rotation property of the Sprite.
    /// </summary>
    public float Rotation
    {
        get { return SplashKit.SpriteRotation(this); }
        set { SplashKit.SpriteSetRotation(this, value); }
    }
    /// <summary>
    /// Gets or sets the Scale property of the Sprite.
    /// </summary>
    public float Scale
    {
        get { return SplashKit.SpriteScale(this); }
        set { SplashKit.SpriteSetScale(this, value); }
    }
    /// <summary>
    /// Gets or sets the ScreenRectangle property of the Sprite.
    /// </summary>
    public Rectangle ScreenRectangle
    {
        get { return SplashKit.SpriteScreenRectangle(this); }
    }
    /// <summary>
    /// Gets or sets the Speed property of the Sprite.
    /// </summary>
    public double Speed
    {
        get { return SplashKit.SpriteSpeed(this); }
        set { SplashKit.SpriteSetSpeed(this, value); }
    }
    /// <summary>
    /// Gets or sets the Velocity property of the Sprite.
    /// </summary>
    public Vector2D Velocity
    {
        get { return SplashKit.SpriteVelocity(this); }
        set { SplashKit.SpriteSetVelocity(this, value); }
    }
    /// <summary>
    /// Gets or sets the X property of the Sprite.
    /// </summary>
    public double X
    {
        get { return SplashKit.SpriteX(this); }
        set { SplashKit.SpriteSetX(this, value); }
    }
    /// <summary>
    /// Gets or sets the Y property of the Sprite.
    /// </summary>
    public double Y
    {
        get { return SplashKit.SpriteY(this); }
        set { SplashKit.SpriteSetY(this, value); }
    }
    /// <summary>
    /// Gets or sets the ValueCount property of the Sprite.
    /// </summary>
    public int ValueCount
    {
        get { return SplashKit.SpriteValueCount(this); }
    }
    /// <summary>
    /// Gets or sets the VisibleLayerCount property of the Sprite.
    /// </summary>
    public int VisibleLayerCount
    {
        get { return SplashKit.SpriteVisibleLayerCount(this); }
    }
    /// <summary>
    /// Gets or sets the Width property of the Sprite.
    /// </summary>
    public int Width
    {
        get { return SplashKit.SpriteWidth(this); }
    }
}
/// <summary>
/// This class represents Timer, which wraps a pointer to SplashKit resources.
/// </summary>
public class Timer : PointerWrapper
{
  private Timer(IntPtr ptr) : base(ptr, true) {}

  internal static Timer FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as Timer;
    #pragma warning restore CS8603
    return new Timer(ptr);
  }

    /// <summary>
    /// Creates a new instance of Timer using the provided parameters.
    /// </summary>
    /// <param name="name"> The name of the timer for resource tracking</param>
    public Timer(string name) : base ( SplashKit.CreateTimer(name), false )
    { }
    protected internal override void DoFree()
    {
        SplashKit.FreeTimer(this);
    }
    /// <summary>
    /// Pause the timer, getting ticks from a paused timer will continue to return the same time.
    /// </summary>
    public void Pause()
    {
        SplashKit.PauseTimer(this);
    }

    /// <summary>
    /// Resets the time of a given timer
    /// </summary>
    public void Reset()
    {
        SplashKit.ResetTimer(this);
    }

    /// <summary>
    /// Resumes a paused timer.
    /// </summary>
    public void Resume()
    {
        SplashKit.ResumeTimer(this);
    }

    /// <summary>
    /// Start a timer. The timer will then start recording the time that has passed. You can check how long has past since the timer was started using the `timer_ticks` function.
    /// </summary>
    public void Start()
    {
        SplashKit.StartTimer(this);
    }

    /// <summary>
    /// Stop the timer. The time is reset to 0 and you must recall start to begin the timer ticking again.
    /// </summary>
    public void Stop()
    {
        SplashKit.StopTimer(this);
    }

    /// <summary>
    /// Gets or sets the IsPaused property of the Timer.
    /// </summary>
    public bool IsPaused
    {
        get { return SplashKit.TimerPaused(this); }
    }
    /// <summary>
    /// Gets or sets the IsStarted property of the Timer.
    /// </summary>
    public bool IsStarted
    {
        get { return SplashKit.TimerStarted(this); }
    }
    /// <summary>
    /// Gets or sets the Ticks property of the Timer.
    /// </summary>
    public uint Ticks
    {
        get { return SplashKit.TimerTicks(this); }
    }
}
/// <summary>
/// This class represents Animation, which wraps a pointer to SplashKit resources.
/// </summary>
public class Animation : PointerWrapper
{
  private Animation(IntPtr ptr) : base(ptr, true) {}

  internal static Animation FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as Animation;
    #pragma warning restore CS8603
    return new Animation(ptr);
  }

    protected internal override void DoFree()
    {
        SplashKit.FreeAnimation(this);
    }
    /// <summary>
    /// Setup an `animation` to follow the script from an indicated name. This will switch the animation to use the supplied script. It locates the name of the animation with the animation script and sets the `anim` to start at that point in the script.
    /// </summary>
    /// <param name="script"> The `animation_script` to assign the `animation` to.</param>
    /// <param name="name"> The name of the `animation` to be assigned.</param>
    public void Assign(AnimationScript script, string name)
    {
        SplashKit.AssignAnimation(this, script, name);
    }

    /// <summary>
    /// Assigns an `animation` to an `animation_script`. This may play a sound effect if the animation is set to play a sound effect on its first frame.
    /// </summary>
    /// <param name="script"> The `animation_script` to assign the `animation` to.</param>
    /// <param name="name"> The name of the `animation` to be assigned.</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public void Assign(AnimationScript script, string name, bool withSound)
    {
        SplashKit.AssignAnimation(this, script, name, withSound);
    }

    /// <summary>
    /// Assigns an `animation` to an `animation_script`.
    /// </summary>
    /// <param name="script"> The `animation_script` to assign the `animation` to.</param>
    /// <param name="idx"> The index of the `animation` to create.</param>
    public void Assign(AnimationScript script, int idx)
    {
        SplashKit.AssignAnimation(this, script, idx);
    }

    /// <summary>
    /// Assigns an `animation` to an `animation_script`. This may play a sound effect if the animation is set to play a sound effect on its first frame.
    /// </summary>
    /// <param name="script"> The `animation_script` to assign the `animation` to.</param>
    /// <param name="idx"> The index of the `animation` to create.</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public void Assign(AnimationScript script, int idx, bool withSound)
    {
        SplashKit.AssignAnimation(this, script, idx, withSound);
    }

    /// <summary>
    /// Assigns an `animation` to an `animation_script`.
    /// </summary>
    /// <param name="scriptName"> The name of the `animation_script` to assign the `animation` to.</param>
    /// <param name="name"> The name of the `animation` to be assigned.</param>
    public void Assign(string scriptName, string name)
    {
        SplashKit.AssignAnimation(this, scriptName, name);
    }

    /// <summary>
    /// Assigns an `animation` to an `animation_script`. This may play a sound effect if the animation is set to play a sound effect on its first frame.
    /// </summary>
    /// <param name="scriptName"> The name of the `animation_script` to assign the `animation` to.</param>
    /// <param name="name"> The name of the `animation` to be assigned</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public void Assign(string scriptName, string name, bool withSound)
    {
        SplashKit.AssignAnimation(this, scriptName, name, withSound);
    }

    /// <summary>
    /// Setup an `animation` to follow the script from an indicated index. This uses the index from the current animation script and sets the supplied animation to start at that point in the script.
    /// </summary>
    /// <param name="idx"> The index of the animation to use from its current script.</param>
    public void Assign(int idx)
    {
        SplashKit.AssignAnimation(this, idx);
    }

    /// <summary>
    /// Setup an `animation` to follow the script from an indicated index. This uses the index from the current animation script and sets the supplied animation to start at that point in the script.
    /// </summary>
    /// <param name="idx"> The index of the animation to use from its current script.</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public void Assign(int idx, bool withSound)
    {
        SplashKit.AssignAnimation(this, idx, withSound);
    }

    /// <summary>
    /// Setup an `animation` to follow the script from an indicated name. This locates the name of the animation from the current animation script and sets the supplied animation to start at that point in the script.
    /// </summary>
    /// <param name="name"> The name of the animation to use from its current script.</param>
    public void Assign(string name)
    {
        SplashKit.AssignAnimation(this, name);
    }

    /// <summary>
    /// Setup an `animation` to follow the script from an indicated name. This locates the name of the animation from the current animation script and sets the supplied animation to start at that point in the script.
    /// </summary>
    /// <param name="name"> The name of the animation to use from its current script.</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public void Assign(string name, bool withSound)
    {
        SplashKit.AssignAnimation(this, name, withSound);
    }

    /// <summary>
    /// Frees all loaded `animation_script`s.
    /// </summary>
    public static void FreeAll()
    {
        SplashKit.FreeAllAnimationScripts();
    }

    /// <summary>
    /// Restarts an `animation`.
    /// </summary>
    public void Restart()
    {
        SplashKit.RestartAnimation(this);
    }

    /// <summary>
    /// Restarts an `animation`. This may play a sound effect if the first frame triggers a sound.
    /// </summary>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    public void Restart(bool withSound)
    {
        SplashKit.RestartAnimation(this, withSound);
    }

    /// <summary>
    /// Updates the animation, updating the time spent and possibly moving to a new frame in the animation. This may play a sound effect if the new frame triggers a sound.
    /// </summary>
    public void Update()
    {
        SplashKit.UpdateAnimation(this);
    }

    /// <summary>
    /// Updates the animation, updating the time spent and possibly moving to a new frame in the animation. This may play a sound effect if the new frame triggers a sound.
    /// </summary>
    /// <param name="pct"> The amount that the frame time will be incremented</param>
    public void Update(float pct)
    {
        SplashKit.UpdateAnimation(this, pct);
    }

    /// <summary>
    /// Gets or sets the CurrentCell property of the Animation.
    /// </summary>
    public int CurrentCell
    {
        get { return SplashKit.AnimationCurrentCell(this); }
    }
    /// <summary>
    /// Gets or sets the CurrentVector property of the Animation.
    /// </summary>
    public Vector2D CurrentVector
    {
        get { return SplashKit.AnimationCurrentVector(this); }
    }
    /// <summary>
    /// Gets or sets the Ended property of the Animation.
    /// </summary>
    public bool Ended
    {
        get { return SplashKit.AnimationEnded(this); }
    }
    /// <summary>
    /// Gets or sets the EnteredFrame property of the Animation.
    /// </summary>
    public bool EnteredFrame
    {
        get { return SplashKit.AnimationEnteredFrame(this); }
    }
    /// <summary>
    /// Gets or sets the FrameTime property of the Animation.
    /// </summary>
    public float FrameTime
    {
        get { return SplashKit.AnimationFrameTime(this); }
    }
    /// <summary>
    /// Gets or sets the Name property of the Animation.
    /// </summary>
    public string Name
    {
        get { return SplashKit.AnimationName(this); }
    }
}
/// <summary>
/// This class represents AnimationScript, which wraps a pointer to SplashKit resources.
/// </summary>
public class AnimationScript : PointerWrapper
{
  private AnimationScript(IntPtr ptr) : base(ptr, true) {}

  internal static AnimationScript FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as AnimationScript;
    #pragma warning restore CS8603
    return new AnimationScript(ptr);
  }

    /// <summary>
    /// Creates a new instance of AnimationScript using the provided parameters.
    /// </summary>
    /// <param name="name"> The name of the `animation_script`.</param>
    /// <param name="filename"> The file to load the `animation_script` from.</param>
    public AnimationScript(string name, string filename) : base ( SplashKit.LoadAnimationScript(name, filename), false )
    { }
    protected internal override void DoFree()
    {
        SplashKit.FreeAnimationScript(this);
    }
    /// <summary>
    /// Searches an `animation_script` for an `animation` and returns its index.
    /// </summary>
    /// <param name="name"> The name of the `animation` to look for.</param>
    /// <returns>Returns the index of the `animation` in the `animation_script`</returns>
    public int AnimationIndex(string name)
    {
        return SplashKit.AnimationIndex(this, name);
    }

    /// <summary>
    /// Creates an animation from an `animation_script`.
    /// </summary>
    /// <param name="name"> The name for the new `animation`</param>
    /// <returns>Returns the newly created `animation`</returns>
    public Animation CreateAnimation(string name)
    {
        return SplashKit.CreateAnimation(this, name);
    }

    /// <summary>
    /// Creates an animation from a `animation_script`. This may play a sound effect if the animation is set to play a sound effect on its first frame.
    /// </summary>
    /// <param name="name"> The name for the new `animation`</param>
    /// <param name="withSound"> Denotes whether the `animation` should play audio.</param>
    /// <returns>Returns the newly created `animation`.</returns>
    public Animation CreateAnimation(string name, bool withSound)
    {
        return SplashKit.CreateAnimation(this, name, withSound);
    }

    /// <summary>
    /// Gets or sets the AnimationCount property of the AnimationScript.
    /// </summary>
    public int AnimationCount
    {
        get { return SplashKit.AnimationCount(this); }
    }
    /// <summary>
    /// Gets or sets the Name property of the AnimationScript.
    /// </summary>
    public string Name
    {
        get { return SplashKit.AnimationScriptName(this); }
    }
}
/// <summary>
/// This class represents Bitmap, which wraps a pointer to SplashKit resources.
/// </summary>
public class Bitmap : PointerWrapper
{
  private Bitmap(IntPtr ptr) : base(ptr, true) {}

  internal static Bitmap FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as Bitmap;
    #pragma warning restore CS8603
    return new Bitmap(ptr);
  }

    /// <summary>
    /// Creates a new instance of Bitmap using the provided parameters.
    /// </summary>
    /// <param name="name"> The name of the bitmap resource to be created. If this already exists SplashKit will alter the name to make it unique.</param>
    /// <param name="width"> The width of the created bitmap</param>
    /// <param name="height"> The height of the created bitmap</param>
    public Bitmap(string name, int width, int height) : base ( SplashKit.CreateBitmap(name, width, height), false )
    { }
    /// <summary>
    /// Creates a new instance of Bitmap using the provided parameters.
    /// </summary>
    /// <param name="name"> The name of the bitmap resource in SplashKit</param>
    /// <param name="filename"> The filename to load</param>
    public Bitmap(string name, string filename) : base ( SplashKit.LoadBitmap(name, filename), false )
    { }
    protected internal override void DoFree()
    {
        SplashKit.FreeBitmap(this);
    }
    /// <summary>
    /// Draw a circle onto the destination bitmap. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    public void DrawCircle(Color clr, double x, double y, double radius)
    {
        SplashKit.DrawCircleOnBitmap(this, clr, x, y, radius);
    }

    /// <summary>
    /// Draw a circle to the bitmap using the supplied drawing options. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public void DrawCircle(Color clr, double x, double y, double radius, DrawingOptions opts)
    {
        SplashKit.DrawCircleOnBitmap(this, clr, x, y, radius, opts);
    }

    /// <summary>
    /// Fill a circle onto the destination bitmap. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    public void FillCircle(Color clr, double x, double y, double radius)
    {
        SplashKit.FillCircleOnBitmap(this, clr, x, y, radius);
    }

    /// <summary>
    /// Fill a circle to the bitmap using the supplied drawing options. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public void FillCircle(Color clr, double x, double y, double radius, DrawingOptions opts)
    {
        SplashKit.FillCircleOnBitmap(this, clr, x, y, radius, opts);
    }

    /// <summary>
    /// Tests if a bitmap drawn at `pt` would intersect with a circle.
    /// </summary>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="circ"> The circle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `circ` when drawn.</returns>
    public bool CircleCollision(Point2D pt, Circle circ)
    {
        return SplashKit.BitmapCircleCollision(this, pt, circ);
    }

    /// <summary>
    /// Tests if a bitmap drawn at `x`, `y` would intersect with a circle.
    /// </summary>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="circ"> The circle to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `circ` when drawn.</returns>
    public bool CircleCollision(double x, double y, Circle circ)
    {
        return SplashKit.BitmapCircleCollision(this, x, y, circ);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn using a passed in translation, will intersect with a circle. You can use this to detect collisions between bitmaps and circles.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="translation"> The matrix used to transfrom the bitmap when drawing</param>
    /// <param name="circ"> The circle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `circ` when drawn.</returns>
    public bool CircleCollision(int cell, Matrix2D translation, Circle circ)
    {
        return SplashKit.BitmapCircleCollision(this, cell, translation, circ);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn at `pt` would intersect with a circle.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="circ"> The circle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `circ` when drawn.</returns>
    public bool CircleCollision(int cell, Point2D pt, Circle circ)
    {
        return SplashKit.BitmapCircleCollision(this, cell, pt, circ);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn at `x`, `y` would intersect with a circle.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="circ"> The circle to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `circ` when drawn.</returns>
    public bool CircleCollision(int cell, double x, double y, Circle circ)
    {
        return SplashKit.BitmapCircleCollision(this, cell, x, y, circ);
    }

    /// <summary>
    /// Check if two bitmaps collide.
    /// </summary>
    /// <param name="x1"> The x location where the first bitmap is drawn</param>
    /// <param name="y1"> The y location where the first bitmap is drawn</param>
    /// <param name="bmp2"> The second bitmap</param>
    /// <param name="x2"> The x location where the second bitmap is drawn</param>
    /// <param name="y2"> The y location where the second bitmap is drawn</param>
    /// <returns>True if pixels in the two bitmaps would collide/overlap</returns>
    public bool BitmapCollision(double x1, double y1, Bitmap bmp2, double x2, double y2)
    {
        return SplashKit.BitmapCollision(this, x1, y1, bmp2, x2, y2);
    }

    /// <summary>
    /// Check if two bitmaps collide.
    /// </summary>
    /// <param name="pt1"> The point where bitmap 1 is drawn</param>
    /// <param name="bmp2"> The second bitmap</param>
    /// <param name="pt2"> The point where bitmap 2 is drawn</param>
    /// <returns>True if pixels in the two bitmaps would collide/overlap</returns>
    public bool BitmapCollision(Point2D pt1, Bitmap bmp2, Point2D pt2)
    {
        return SplashKit.BitmapCollision(this, pt1, bmp2, pt2);
    }

    /// <summary>
    /// Check if two bitmaps collide, based on their cell and transform matricies.
    /// </summary>
    /// <param name="cell1"> The cell of the first bitmap.</param>
    /// <param name="matrix1"> The transformation for the first matrix</param>
    /// <param name="bmp2"> The second bitmap</param>
    /// <param name="cell2"> The cell of the second bitmap.</param>
    /// <param name="matrix2"> The transformation for the second matrix</param>
    /// <returns>True if pixels in the two bitmaps would collide/overlap</returns>
    public bool BitmapCollision(int cell1, Matrix2D matrix1, Bitmap bmp2, int cell2, Matrix2D matrix2)
    {
        return SplashKit.BitmapCollision(this, cell1, matrix1, bmp2, cell2, matrix2);
    }

    /// <summary>
    /// Check if two bitmaps collide.
    /// </summary>
    /// <param name="cell1"> The cell of the first bitmap.</param>
    /// <param name="pt1"> The point where bitmap 1 is drawn</param>
    /// <param name="bmp2"> The second bitmap</param>
    /// <param name="cell2"> The cell of the second bitmap.</param>
    /// <param name="pt2"> The point where bitmap 2 is drawn</param>
    /// <returns>True if pixels in the two bitmaps would collide/overlap</returns>
    public bool BitmapCollision(int cell1, Point2D pt1, Bitmap bmp2, int cell2, Point2D pt2)
    {
        return SplashKit.BitmapCollision(this, cell1, pt1, bmp2, cell2, pt2);
    }

    /// <summary>
    /// Check if two bitmaps collide.
    /// </summary>
    /// <param name="cell1"> The cell of the first bitmap.</param>
    /// <param name="x1"> The x location where the first bitmap is drawn</param>
    /// <param name="y1"> The y location where the first bitmap is drawn</param>
    /// <param name="bmp2"> The second bitmap</param>
    /// <param name="cell2"> The cell of the second bitmap.</param>
    /// <param name="x2"> The x location where the second bitmap is drawn</param>
    /// <param name="y2"> The y location where the second bitmap is drawn</param>
    /// <returns>True if pixels in the two bitmaps would collide/overlap</returns>
    public bool BitmapCollision(int cell1, double x1, double y1, Bitmap bmp2, int cell2, double x2, double y2)
    {
        return SplashKit.BitmapCollision(this, cell1, x1, y1, bmp2, cell2, x2, y2);
    }

    /// <summary>
    /// Tests if a bitmap drawn using the passed in translation matrix would draw a pixel at the passed in point. Use to check collisions between a point and a bitmap.
    /// </summary>
    /// <param name="translation"> The translation matrix that represents the position, scale, and rotation of the bitmap when it is drawn.</param>
    /// <param name="pt"> The point in the resulting drawing that is being tested.</param>
    /// <returns>True if drawing the bitmap, using the passed in translation, will draw a pixel at the indicated point.</returns>
    public bool PointCollision(Matrix2D translation, Point2D pt)
    {
        return SplashKit.BitmapPointCollision(this, translation, pt);
    }

    /// <summary>
    /// Tests if a bitmap drawn at the `bmp_pt` point would draw a pixel at point `pt`. Use to check collisions between a point and a bitmap.
    /// </summary>
    /// <param name="bmpPt"> The point where the bitmap is drawn.</param>
    /// <param name="pt"> The point in the resulting drawing that is being tested.</param>
    /// <returns>True if drawing the bitmap, at `bmp_pt`, will draw a pixel at the indicated point (`pt`).</returns>
    public bool PointCollision(Point2D bmpPt, Point2D pt)
    {
        return SplashKit.BitmapPointCollision(this, bmpPt, pt);
    }

    /// <summary>
    /// Tests if a bitmap drawn at x,y would draw a pixel at the passed in point. Use to check collisions between a point and a bitmap.
    /// </summary>
    /// <param name="bmpX"> The x location where the bitmap is drawn</param>
    /// <param name="bmpY"> The y location where the bitmap is drawn</param>
    /// <param name="x"> The x location of the point to test</param>
    /// <param name="y"> The y location of the point to test</param>
    /// <returns>True if drawing the bitmap, at the indicated location, will draw a pixel at the indicated point.</returns>
    public bool PointCollision(double bmpX, double bmpY, double x, double y)
    {
        return SplashKit.BitmapPointCollision(this, bmpX, bmpY, x, y);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn using the passed in translation matrix would draw a pixel at the passed in point.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check.</param>
    /// <param name="translation"> The translation matrix that represents the position, scale, and rotation of the bitmap when it is drawn.</param>
    /// <param name="pt"> The point in the resulting drawing that is being tested.</param>
    /// <returns>True if drawing the bitmap, using the passed in translation, will draw a pixel at the indicated point.</returns>
    public bool PointCollision(int cell, Matrix2D translation, Point2D pt)
    {
        return SplashKit.BitmapPointCollision(this, cell, translation, pt);
    }

    /// <summary>
    /// Tests if a cell of a bitmap drawn at x,y would draw a pixel at the passed in point. Use to check collisions between a point and a bitmap.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to test</param>
    /// <param name="bmpPt"> The point where the bitmap is drawn.</param>
    /// <param name="pt"> The point in the resulting drawing that is being tested.</param>
    /// <returns>True if drawing the bitmap cell, at the indicated location, will draw a pixel at the indicated point.</returns>
    public bool PointCollision(int cell, Point2D bmpPt, Point2D pt)
    {
        return SplashKit.BitmapPointCollision(this, cell, bmpPt, pt);
    }

    /// <summary>
    /// Tests if a cell of a bitmap drawn at x,y would draw a pixel at the passed in point. Use to check collisions between a point and a bitmap.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to test</param>
    /// <param name="bmpX"> The x location where the bitmap is drawn</param>
    /// <param name="bmpY"> The y location where the bitmap is drawn</param>
    /// <param name="x"> The x location of the point to test</param>
    /// <param name="y"> The y location of the point to test</param>
    /// <returns>True if drawing the bitmap cell, at the indicated location, will draw a pixel at the indicated point.</returns>
    public bool PointCollision(int cell, double bmpX, double bmpY, double x, double y)
    {
        return SplashKit.BitmapPointCollision(this, cell, bmpX, bmpY, x, y);
    }

    /// <summary>
    /// Tests if a bitmap drawn at `pt` would intersect with a quad.
    /// </summary>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="q"> The quad to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `q` when drawn.</returns>
    public bool QuadCollision(Point2D pt, Quad q)
    {
        return SplashKit.BitmapQuadCollision(this, pt, q);
    }

    /// <summary>
    /// Tests if a bitmap drawn at `x`, `y` would intersect with a quad.
    /// </summary>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="q"> The quad to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `q` when drawn.</returns>
    public bool QuadCollision(double x, double y, Quad q)
    {
        return SplashKit.BitmapQuadCollision(this, x, y, q);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn using a passed in translation, will intersect with a quad. You can use this to detect collisions between bitmaps and quads.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="translation"> The matrix used to transfrom the bitmap when drawing</param>
    /// <param name="q"> The quad to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `q` when drawn.</returns>
    public bool QuadCollision(int cell, Matrix2D translation, Quad q)
    {
        return SplashKit.BitmapQuadCollision(this, cell, translation, q);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn at `pt` would intersect with a quad.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="q"> The quad to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `q` when drawn.</returns>
    public bool QuadCollision(int cell, Point2D pt, Quad q)
    {
        return SplashKit.BitmapQuadCollision(this, cell, pt, q);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn at `x`, `y` would intersect with a quad.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="q"> The quad to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `q` when drawn.</returns>
    public bool QuadCollision(int cell, double x, double y, Quad q)
    {
        return SplashKit.BitmapQuadCollision(this, cell, x, y, q);
    }

    /// <summary>
    /// Tests if a bitmap drawn at `pt` would intersect with a ray.
    /// </summary>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="origin"> The origin of the ray</param>
    /// <param name="heading"> The heading of the ray</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with the ray when drawn.</returns>
    public bool RayCollision(Point2D pt, Point2D origin, Vector2D heading)
    {
        return SplashKit.BitmapRayCollision(this, pt, origin, heading);
    }

    /// <summary>
    /// Tests if a bitmap drawn at `x`, `y` would intersect with a ray.
    /// </summary>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="origin"> The origin of the ray</param>
    /// <param name="heading"> The heading of the ray</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with the ray when drawn.</returns>
    public bool RayCollision(double x, double y, Point2D origin, Vector2D heading)
    {
        return SplashKit.BitmapRayCollision(this, x, y, origin, heading);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn using a passed in translation, will intersect with a ray. You can use this to detect collisions between bitmaps and rays.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="translation"> The matrix used to transfrom the bitmap when drawing</param>
    /// <param name="origin"> The origin of the ray</param>
    /// <param name="heading"> The heading of the ray</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with the ray when drawn.</returns>
    public bool RayCollision(int cell, Matrix2D translation, Point2D origin, Vector2D heading)
    {
        return SplashKit.BitmapRayCollision(this, cell, translation, origin, heading);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn at `pt` would intersect with a ray.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="origin"> The origin of the ray</param>
    /// <param name="heading"> The heading of the ray</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with the ray when drawn.</returns>
    public bool RayCollision(int cell, Point2D pt, Point2D origin, Vector2D heading)
    {
        return SplashKit.BitmapRayCollision(this, cell, pt, origin, heading);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn at `x`, `y` would intersect with a ray.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="origin"> The origin of the ray</param>
    /// <param name="heading"> The heading of the ray</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with the ray when drawn.</returns>
    public bool RayCollision(int cell, double x, double y, Point2D origin, Vector2D heading)
    {
        return SplashKit.BitmapRayCollision(this, cell, x, y, origin, heading);
    }

    /// <summary>
    /// Tests if a bitmap drawn at `pt` would intersect with a rectangle.
    /// </summary>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="rect"> The rectangle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `rect` when drawn.</returns>
    public bool RectangleCollision(Point2D pt, Rectangle rect)
    {
        return SplashKit.BitmapRectangleCollision(this, pt, rect);
    }

    /// <summary>
    /// Tests if a bitmap drawn at `x`, `y` would intersect with a rectangle.
    /// </summary>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="rect"> The rectangle to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `rect` when drawn.</returns>
    public bool RectangleCollision(double x, double y, Rectangle rect)
    {
        return SplashKit.BitmapRectangleCollision(this, x, y, rect);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn using a passed in translation, will intersect with a rectangle. You can use this to detect collisions between bitmaps and rectangles.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="translation"> The matrix used to transfrom the bitmap when drawing</param>
    /// <param name="rect"> The rectangle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `rect` when drawn.</returns>
    public bool RectangleCollision(int cell, Matrix2D translation, Rectangle rect)
    {
        return SplashKit.BitmapRectangleCollision(this, cell, translation, rect);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn at `pt` would intersect with a rectangle.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="rect"> The rectangle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `rect` when drawn.</returns>
    public bool RectangleCollision(int cell, Point2D pt, Rectangle rect)
    {
        return SplashKit.BitmapRectangleCollision(this, cell, pt, rect);
    }

    /// <summary>
    /// Tests if a cell of the bitmap drawn at `x`, `y` would intersect with a rectangle.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="rect"> The rectangle to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `rect` when drawn.</returns>
    public bool RectangleCollision(int cell, double x, double y, Rectangle rect)
    {
        return SplashKit.BitmapRectangleCollision(this, cell, x, y, rect);
    }

    /// <summary>
    /// Tests if a bitmap drawn at `pt` would intersect with a triangle.
    /// </summary>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="tri"> The triangle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `tri` when drawn.</returns>
    public bool TriangleCollision(Point2D pt, Triangle tri)
    {
        return SplashKit.BitmapTriangleCollision(this, pt, tri);
    }

    /// <summary>
    /// Tests if a bitmap drawn at `x`, `y` would intersect with a triangle.
    /// </summary>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="tri"> The triangle to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `tri` when drawn.</returns>
    public bool TriangleCollision(double x, double y, Triangle tri)
    {
        return SplashKit.BitmapTriangleCollision(this, x, y, tri);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn using a passed in translation, will intersect with a triangle. You can use this to detect collisions between bitmaps and triangles.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="translation"> The matrix used to transfrom the bitmap when drawing</param>
    /// <param name="tri"> The triangle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `tri` when drawn.</returns>
    public bool TriangleCollision(int cell, Matrix2D translation, Triangle tri)
    {
        return SplashKit.BitmapTriangleCollision(this, cell, translation, tri);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn at `pt` would intersect with a triangle.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="pt"> The location where the bitmap is drawn</param>
    /// <param name="tri"> The triangle to test</param>
    /// <returns>True if a drawn pixel in the cell of the bitmap will intersect with `tri` when drawn.</returns>
    public bool TriangleCollision(int cell, Point2D pt, Triangle tri)
    {
        return SplashKit.BitmapTriangleCollision(this, cell, pt, tri);
    }

    /// <summary>
    /// Tests if a bitmap cell drawn at `x`, `y` would intersect with a triangle.
    /// </summary>
    /// <param name="cell"> The cell of the bitmap to check</param>
    /// <param name="x"> The x location where the bitmap is drawn</param>
    /// <param name="y"> The y location where the bitmap is drawn</param>
    /// <param name="tri"> The triangle to test</param>
    /// <returns>True if a drawn pixel in the bitmap will intersect with `tri` when drawn.</returns>
    public bool TriangleCollision(int cell, double x, double y, Triangle tri)
    {
        return SplashKit.BitmapTriangleCollision(this, cell, x, y, tri);
    }

    /// <summary>
    /// Draws an ellipse on the given bitmap, using the provided location, and size.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    public void DrawEllipse(Color clr, Rectangle rect)
    {
        SplashKit.DrawEllipseOnBitmap(this, clr, rect);
    }

    /// <summary>
    /// Draws an ellipse on the given bitmap, using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawEllipse(Color clr, Rectangle rect, DrawingOptions opts)
    {
        SplashKit.DrawEllipseOnBitmap(this, clr, rect, opts);
    }

    /// <summary>
    /// Draws an ellipse on the given bitmap, using the provided location, and size.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or bitmap to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or bitmap to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    public void DrawEllipse(Color clr, double x, double y, double width, double height)
    {
        SplashKit.DrawEllipseOnBitmap(this, clr, x, y, width, height);
    }

    /// <summary>
    /// Draws an ellipse to the bitmap, using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or bitmap to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or bitmap to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawEllipse(Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
        SplashKit.DrawEllipseOnBitmap(this, clr, x, y, width, height, opts);
    }

    /// <summary>
    /// Fill an ellipse on the given bitmap, using the provided location, and size.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    public void FillEllipse(Color clr, Rectangle rect)
    {
        SplashKit.FillEllipseOnBitmap(this, clr, rect);
    }

    /// <summary>
    /// Fills an ellipse on the given bitmap, using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public void FillEllipse(Color clr, Rectangle rect, DrawingOptions opts)
    {
        SplashKit.FillEllipseOnBitmap(this, clr, rect, opts);
    }

    /// <summary>
    /// Fills an ellipse on the given bitmap, using the provided location, and size.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or bitmap to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or bitmap to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    public void FillEllipse(Color clr, double x, double y, double width, double height)
    {
        SplashKit.FillEllipseOnBitmap(this, clr, x, y, width, height);
    }

    /// <summary>
    /// Fills an ellipse on the given bitmap, using the provided location, size, and drawing options.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or bitmap to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or bitmap to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public void FillEllipse(Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
        SplashKit.FillEllipseOnBitmap(this, clr, x, y, width, height, opts);
    }

    /// <summary>
    /// Returns a circle that will encompass the entire bitamp.
    /// </summary>
    /// <param name="pt"> The point where the bitmap is located.</param>
    /// <returns>A circle that surrounds the bitmap.</returns>
    public Circle BoundingCircle(Point2D pt)
    {
        return SplashKit.BitmapBoundingCircle(this, pt);
    }

    /// <summary>
    /// Returns a rectangle that is the same size as a bitmap (the whole bitmap).
    /// </summary>
    /// <returns>A rectangle with the same size as the bitmap.</returns>
    public Rectangle BoundingRectangle()
    {
        return SplashKit.BitmapBoundingRectangle(this);
    }

    /// <summary>
    /// Returns a rectangle that is the same size as the bitmap and is located at the indicated position.
    /// </summary>
    /// <param name="x"> The x location of the rectangle</param>
    /// <param name="y"> The y location of the rectangle</param>
    /// <returns>A rectangle with the same size as the bitmap, at the indicated location.</returns>
    public Rectangle BoundingRectangle(double x, double y)
    {
        return SplashKit.BitmapBoundingRectangle(this, x, y);
    }

    /// <summary>
    /// Returns a circle that will encompass the bitmap cell if it were drawn at the indicated point.
    /// </summary>
    /// <param name="x"> The the x location of the bitmap.</param>
    /// <param name="y"> The the y location of the bitmap.</param>
    /// <returns>A circle that will encompass the bitmap cell.</returns>
    public Circle CellCircle(double x, double y)
    {
        return SplashKit.BitmapCellCircle(this, x, y);
    }

    /// <summary>
    /// Returns a circle that will encompass the bitmap cell if it were drawn at the indicated point.
    /// </summary>
    /// <param name="pt"> The point indicating the location of the bitmap.</param>
    /// <returns>A circle that will encompass the bitmap cell.</returns>
    public Circle CellCircle(Point2D pt)
    {
        return SplashKit.BitmapCellCircle(this, pt);
    }

    /// <summary>
    /// Returns a circle that will encompass the bitmap cell if it were drawn at the indicated point, with the provided scale.
    /// </summary>
    /// <param name="pt"> The point indicating the location of the bitmap.</param>
    /// <param name="scale"> The scaling factor for the bitmap drawing.</param>
    /// <returns>A circle that will encompass the bitmap cell.</returns>
    public Circle CellCircle(Point2D pt, double scale)
    {
        return SplashKit.BitmapCellCircle(this, pt, scale);
    }

    /// <summary>
    /// Returns a vector that represents the movement needed to get to a given cell within a bitmap.
    /// </summary>
    /// <param name="cell"> The index of the cell</param>
    /// <returns>The offset needed to get to the cell from the top left of the bitmap.</returns>
    public Vector2D CellOffset(int cell)
    {
        return SplashKit.BitmapCellOffset(this, cell);
    }

    /// <summary>
    /// Returns a rectangle that will encompass a cell of the bitmap.
    /// </summary>
    /// <returns>A rectangle with width and height from the bitmap's cell details.</returns>
    public Rectangle CellRectangle()
    {
        return SplashKit.BitmapCellRectangle(this);
    }

    /// <summary>
    /// Returns a rectangle that will encompass the bitmap cell if it were drawn at the indicated point.
    /// </summary>
    /// <param name="pt"> The point details for the rectangle.</param>
    /// <returns>A rectangle at pt, with width and height from the bitmap's cell details.</returns>
    public Rectangle CellRectangle(Point2D pt)
    {
        return SplashKit.BitmapCellRectangle(this, pt);
    }

    /// <summary>
    /// Returns a rectangle that can be used to access the part of a bitmap related to an individual cell.
    /// </summary>
    /// <param name="cell"> The cell</param>
    /// <returns>The area of the cell within the bitmap</returns>
    public Rectangle RectangleOfCell(int cell)
    {
        return SplashKit.BitmapRectangleOfCell(this, cell);
    }

    /// <summary>
    /// Initialise the bitmap cell details. This allows parts of the bitmap to be drawn as individual cells.
    /// </summary>
    /// <param name="width"> The width of each cell</param>
    /// <param name="height"> The height of each cell</param>
    /// <param name="columns"> The number of cell columns within the bitmap</param>
    /// <param name="rows"> The number of cell rows within the bitmap</param>
    /// <param name="count"> The total number of cells, may be fewer than columns * rows</param>
    public void SetCellDetails(int width, int height, int columns, int rows, int count)
    {
        SplashKit.BitmapSetCellDetails(this, width, height, columns, rows, count);
    }

    /// <summary>
    /// Clear the bitmap to the indicated color. This will ensure the entire surface of the bitmap is set to that color.
    /// </summary>
    /// <param name="clr"> The new color for the surface of the bitmap</param>
    public void Clear(Color clr)
    {
        SplashKit.ClearBitmap(this, clr);
    }

    /// <summary>
    /// Draws the bitmap supplied into `bmp` to the current window. at `x` and `y`.
    /// </summary>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    public void Draw(double x, double y)
    {
        SplashKit.DrawBitmap(this, x, y);
    }

    /// <summary>
    /// Draws the bitmap supplied into `bmp` to the current window. with extra drawing options supplied in `opts` at `x` and `y`.
    /// </summary>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    /// <param name="opts"> the `drawing_options` which provide extra information for how to draw the `bitmap`</param>
    public void Draw(double x, double y, DrawingOptions opts)
    {
        SplashKit.DrawBitmap(this, x, y, opts);
    }

    /// <summary>
    /// Draws the bitmap supplied into `bmp` to the given bitmap. at `x` and `y`.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the bitmap to</param>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    public void DrawBitmap(Bitmap destination, double x, double y)
    {
        SplashKit.DrawBitmapOnBitmap(destination, this, x, y);
    }

    /// <summary>
    /// Draws the bitmap supplied into `bmp` to the given bitmap. with extra drawing options supplied in `opts` at `x` and `y`.
    /// </summary>
    /// <param name="destination"> the bitmap to draw the bitmap to</param>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    /// <param name="opts"> the `drawing_options` which provide extra information for how to draw the `bitmap`</param>
    public void DrawBitmap(Bitmap destination, double x, double y, DrawingOptions opts)
    {
        SplashKit.DrawBitmapOnBitmap(destination, this, x, y, opts);
    }

    /// <summary>
    /// Frees the bitmap resource.
    /// </summary>
    public void Free()
    {
        SplashKit.FreeBitmap(this);
    }

    /// <summary>
    /// Check if the bitmap has a pixel drawn at the indicated point.
    /// </summary>
    /// <param name="pt"> The point within the bitmap to check.</param>
    /// <returns>True if the pixel at that point in the bitmap is drawn.</returns>
    public bool PixelDrawnAtPoint(Point2D pt)
    {
        return SplashKit.PixelDrawnAtPoint(this, pt);
    }

    /// <summary>
    /// Check if the bitmap has a pixel drawn at the indicated point.
    /// </summary>
    /// <param name="x"> The x coordinate within the bitmap to check</param>
    /// <param name="y"> The y coordinate within the bitmap to check</param>
    /// <returns>True if the pixel at that point in the bitmap is drawn.</returns>
    public bool PixelDrawnAtPoint(double x, double y)
    {
        return SplashKit.PixelDrawnAtPoint(this, x, y);
    }

    /// <summary>
    /// Check if the bitmap has a pixel drawn at the indicated point in the cell.
    /// </summary>
    /// <param name="cell"> The bitmap cell to check.</param>
    /// <param name="pt"> The point within the bitmap to check.</param>
    /// <returns>True if the pixel at that point in the bitmap's cell is drawn.</returns>
    public bool PixelDrawnAtPointInCell(int cell, Point2D pt)
    {
        return SplashKit.PixelDrawnAtPoint(this, cell, pt);
    }

    /// <summary>
    /// Check if the bitmap has a pixel drawn at the indicated point in the cell.
    /// </summary>
    /// <param name="cell"> The bitmap cell to check.</param>
    /// <param name="x"> The x coordinate within the bitmap to check</param>
    /// <param name="y"> The y coordinate within the bitmap to check</param>
    /// <returns>True if the pixel at that point in the bitmap's cell is drawn.</returns>
    public bool PixelDrawnAtPoint(int cell, double x, double y)
    {
        return SplashKit.PixelDrawnAtPoint(this, cell, x, y);
    }

    /// <summary>
    /// Sets up the collision mask for a bitmap. This enables collision detection between this bitmap and other bitmaps or shapes.  This is automatically called when a bitmap is loaded, and only needs to be  called on bitmaps created using `create_bitmap`, and when a bitmap is changed by drawing onto the bitmap.
    /// </summary>
    public void SetupCollisionMask()
    {
        SplashKit.SetupCollisionMask(this);
    }

    /// <summary>
    /// Draws a line onto the given bitmap.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="l"> The line's details</param>
    public void DrawLine(Color clr, Line l)
    {
        SplashKit.DrawLineOnBitmap(this, clr, l);
    }

    /// <summary>
    /// Draws a line on the given bitmap.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="l"> The line's details</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawLine(Color clr, Line l, DrawingOptions opts)
    {
        SplashKit.DrawLineOnBitmap(this, clr, l, opts);
    }

    /// <summary>
    /// Draw a line from one point to another on the given bitmap.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="fromPt"> The start of the line</param>
    /// <param name="toPt"> The end of the line</param>
    public void DrawLine(Color clr, Point2D fromPt, Point2D toPt)
    {
        SplashKit.DrawLineOnBitmap(this, clr, fromPt, toPt);
    }

    /// <summary>
    /// Draw a line from one point to another on the given bitmap.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="fromPt"> The start of the line</param>
    /// <param name="toPt"> The end of the line</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawLine(Color clr, Point2D fromPt, Point2D toPt, DrawingOptions opts)
    {
        SplashKit.DrawLineOnBitmap(this, clr, fromPt, toPt, opts);
    }

    /// <summary>
    /// Draw a line from one point to another on the given bitmap.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="x1"> The distance from the left of the bitmap/bitmap to the first point</param>
    /// <param name="y1"> The distance from the top of the bitmap/bitmap to the first point</param>
    /// <param name="x2"> The distance from the left of the bitmap/bitmap to the second point</param>
    /// <param name="y2"> The distance from the top of the bitmap/bitmap to the second point</param>
    public void DrawLine(Color clr, double x1, double y1, double x2, double y2)
    {
        SplashKit.DrawLineOnBitmap(this, clr, x1, y1, x2, y2);
    }

    /// <summary>
    /// Draw a line from one point to another
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="x1"> The distance from the left of the bitmap/bitmap to the first point</param>
    /// <param name="y1"> The distance from the top of the bitmap/bitmap to the first point</param>
    /// <param name="x2"> The distance from the left of the bitmap/bitmap to the second point</param>
    /// <param name="y2"> The distance from the top of the bitmap/bitmap to the second point</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawLine(Color clr, double x1, double y1, double x2, double y2, DrawingOptions opts)
    {
        SplashKit.DrawLineOnBitmap(this, clr, x1, y1, x2, y2, opts);
    }

    /// <summary>
    /// Draws an individual pixel to the given bitmap.
    /// </summary>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="pt"> The location of the pixel to draw</param>
    public void DrawPixel(Color clr, Point2D pt)
    {
        SplashKit.DrawPixelOnBitmap(this, clr, pt);
    }

    /// <summary>
    /// Draws an individual pixel to the given bitmap with the given drawing options.
    /// </summary>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="pt"> The location of the pixel to draw</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawPixel(Color clr, Point2D pt, DrawingOptions opts)
    {
        SplashKit.DrawPixelOnBitmap(this, clr, pt, opts);
    }

    /// <summary>
    /// Draws an individual pixel to the given bitmap.
    /// </summary>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="x"> The distance from the left edge of the bitmap to the pixel</param>
    /// <param name="y"> The distance from the top edge of the bitmap to the pixel</param>
    public void DrawPixel(Color clr, double x, double y)
    {
        SplashKit.DrawPixelOnBitmap(this, clr, x, y);
    }

    /// <summary>
    /// Draws an individual pixel to the given bitmap with the given drawing options.
    /// </summary>
    /// <param name="clr"> The color of the pixel</param>
    /// <param name="x"> The distance from the left edge of the bitmap to the pixel</param>
    /// <param name="y"> The distance from the top edge of the bitmap to the pixel</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawPixel(Color clr, double x, double y, DrawingOptions opts)
    {
        SplashKit.DrawPixelOnBitmap(this, clr, x, y, opts);
    }

    /// <summary>
    /// Draw a quad on the supplied bitmap to the current bitmap.
    /// </summary>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    public void DrawQuad(Color clr, Quad q)
    {
        SplashKit.DrawQuadOnBitmap(this, clr, q);
    }

    /// <summary>
    /// Draw a quad on the supplied bitmap using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawQuad(Color clr, Quad q, DrawingOptions opts)
    {
        SplashKit.DrawQuadOnBitmap(this, clr, q, opts);
    }

    /// <summary>
    /// Draw a rectangle to the bitmap using the supplied rect. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> the rectangle to be drawn to the bitmap</param>
    public void DrawRectangle(Color clr, Rectangle rect)
    {
        SplashKit.DrawRectangleOnBitmap(this, clr, rect);
    }

    /// <summary>
    /// Draw a rectangle to the bitmap using the supplied rect and drawing options. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> the rectangle to be drawn to the bitmap</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public void DrawRectangle(Color clr, Rectangle rect, DrawingOptions opts)
    {
        SplashKit.DrawRectangleOnBitmap(this, clr, rect, opts);
    }

    /// <summary>
    /// Draw a rectangle to the bitmap using. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The x location of the rectangle</param>
    /// <param name="y"> The y location of the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    public void DrawRectangle(Color clr, double x, double y, double width, double height)
    {
        SplashKit.DrawRectangleOnBitmap(this, clr, x, y, width, height);
    }

    /// <summary>
    /// Draw a rectangle to the bitmap using the supplied drawing options. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The x location of the rectangle</param>
    /// <param name="y"> The y location of the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public void DrawRectangle(Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
        SplashKit.DrawRectangleOnBitmap(this, clr, x, y, width, height, opts);
    }

    /// <summary>
    /// Fill a quad on the supplied bitmap on the current bitmap.
    /// </summary>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    public void FillQuad(Color clr, Quad q)
    {
        SplashKit.FillQuadOnBitmap(this, clr, q);
    }

    /// <summary>
    /// Fill a quad on the supplied bitmap using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    /// <param name="opts"> The drawing options</param>
    public void FillQuad(Color clr, Quad q, DrawingOptions opts)
    {
        SplashKit.FillQuadOnBitmap(this, clr, q, opts);
    }

    /// <summary>
    /// Fill a rectangle on the supplied bitmap onto the current bitmap.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> The rectangle to draw</param>
    public void FillRectangle(Color clr, Rectangle rect)
    {
        SplashKit.FillRectangleOnBitmap(this, clr, rect);
    }

    /// <summary>
    /// Fills a rectangle on the supplied bitmap using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> The rectangle to draw</param>
    /// <param name="opts"> The drawing options</param>
    public void FillRectangle(Color clr, Rectangle rect, DrawingOptions opts)
    {
        SplashKit.FillRectangleOnBitmap(this, clr, rect, opts);
    }

    /// <summary>
    /// Fills a rectangle on the supplied bitmap to the current bitmap.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The distance from the left of the bitmap/bitmap to the rectangle</param>
    /// <param name="y"> The distance from the top of the bitmap/bitmap to the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    public void FillRectangle(Color clr, double x, double y, double width, double height)
    {
        SplashKit.FillRectangleOnBitmap(this, clr, x, y, width, height);
    }

    /// <summary>
    /// Fills a rectangle on the supplied bitmap, using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The distance from the left of the bitmap/bitmap to the rectangle</param>
    /// <param name="y"> The distance from the top of the bitmap/bitmap to the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    /// <param name="opts"> The drawing options</param>
    public void FillRectangle(Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
        SplashKit.FillRectangleOnBitmap(this, clr, x, y, width, height, opts);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the bitmap.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The name of the `font` which will be used to draw the text</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public void DrawText(string text, Color clr, string fnt, int fontSize, double x, double y)
    {
        SplashKit.DrawTextOnBitmap(this, text, clr, fnt, fontSize, x, y);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the bitmap.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The name of the `font` which will be used to draw the text</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public void DrawText(string text, Color clr, string fnt, int fontSize, double x, double y, DrawingOptions opts)
    {
        SplashKit.DrawTextOnBitmap(this, text, clr, fnt, fontSize, x, y, opts);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the bitmap.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public void DrawText(string text, Color clr, double x, double y)
    {
        SplashKit.DrawTextOnBitmap(this, text, clr, x, y);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the bitmap.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public void DrawText(string text, Color clr, double x, double y, DrawingOptions opts)
    {
        SplashKit.DrawTextOnBitmap(this, text, clr, x, y, opts);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the bitmap.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The `font` to be used to draw the text.</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public void DrawText(string text, Color clr, Font fnt, int fontSize, double x, double y)
    {
        SplashKit.DrawTextOnBitmap(this, text, clr, fnt, fontSize, x, y);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the bitmap.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The `font` to be used to draw the text.</param>
    /// <param name="fontSize"> The desired size of the font.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public void DrawText(string text, Color clr, Font fnt, int fontSize, double x, double y, DrawingOptions opts)
    {
        SplashKit.DrawTextOnBitmap(this, text, clr, fnt, fontSize, x, y, opts);
    }

    /// <summary>
    /// Draw a triangle on a given bitmap, using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    public void DrawTriangle(Color clr, Triangle tri)
    {
        SplashKit.DrawTriangleOnBitmap(this, clr, tri);
    }

    /// <summary>
    /// Draw a triangle on a given bitmap, using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawTriangle(Color clr, Triangle tri, DrawingOptions opts)
    {
        SplashKit.DrawTriangleOnBitmap(this, clr, tri, opts);
    }

    /// <summary>
    /// Draw a triangle to the given bitmap.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap to the third point of the triangle</param>
    public void DrawTriangle(Color clr, double x1, double y1, double x2, double y2, double x3, double y3)
    {
        SplashKit.DrawTriangleOnBitmap(this, clr, x1, y1, x2, y2, x3, y3);
    }

    /// <summary>
    /// Draw a triangle to the given bitmap, using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap/bitmap to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap/bitmap to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap/bitmap to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap/bitmap to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap/bitmap to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap/bitmap to the third point of the triangle</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawTriangle(Color clr, double x1, double y1, double x2, double y2, double x3, double y3, DrawingOptions opts)
    {
        SplashKit.DrawTriangleOnBitmap(this, clr, x1, y1, x2, y2, x3, y3, opts);
    }

    /// <summary>
    /// Fill a triangle on a given bitmap
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    public void FillTriangle(Color clr, Triangle tri)
    {
        SplashKit.FillTriangleOnBitmap(this, clr, tri);
    }

    /// <summary>
    /// Fill a triangle on a given bitmap, using given drawing options
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    /// <param name="opts"> The drawing options</param>
    public void FillTriangle(Color clr, Triangle tri, DrawingOptions opts)
    {
        SplashKit.FillTriangleOnBitmap(this, clr, tri, opts);
    }

    /// <summary>
    /// Fill a triangle on a given bitmap
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap to the third point of the triangle</param>
    public void FillTriangle(Color clr, double x1, double y1, double x2, double y2, double x3, double y3)
    {
        SplashKit.FillTriangleOnBitmap(this, clr, x1, y1, x2, y2, x3, y3);
    }

    /// <summary>
    /// Fill a triangle on a given bitmap, using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap/bitmap to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap/bitmap to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap/bitmap to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap/bitmap to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap/bitmap to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap/bitmap to the third point of the triangle</param>
    /// <param name="opts"> The drawing options</param>
    public void FillTriangle(Color clr, double x1, double y1, double x2, double y2, double x3, double y3, DrawingOptions opts)
    {
        SplashKit.FillTriangleOnBitmap(this, clr, x1, y1, x2, y2, x3, y3, opts);
    }

    /// <summary>
    /// Gets or sets the CellCenter property of the Bitmap.
    /// </summary>
    public Point2D CellCenter
    {
        get { return SplashKit.BitmapCellCenter(this); }
    }
    /// <summary>
    /// Gets or sets the CellColumns property of the Bitmap.
    /// </summary>
    public int CellColumns
    {
        get { return SplashKit.BitmapCellColumns(this); }
    }
    /// <summary>
    /// Gets or sets the CellCount property of the Bitmap.
    /// </summary>
    public int CellCount
    {
        get { return SplashKit.BitmapCellCount(this); }
    }
    /// <summary>
    /// Gets or sets the CellHeight property of the Bitmap.
    /// </summary>
    public int CellHeight
    {
        get { return SplashKit.BitmapCellHeight(this); }
    }
    /// <summary>
    /// Gets or sets the CellRows property of the Bitmap.
    /// </summary>
    public int CellRows
    {
        get { return SplashKit.BitmapCellRows(this); }
    }
    /// <summary>
    /// Gets or sets the CellWidth property of the Bitmap.
    /// </summary>
    public int CellWidth
    {
        get { return SplashKit.BitmapCellWidth(this); }
    }
    /// <summary>
    /// Gets or sets the Center property of the Bitmap.
    /// </summary>
    public Point2D Center
    {
        get { return SplashKit.BitmapCenter(this); }
    }
    /// <summary>
    /// Gets or sets the Filename property of the Bitmap.
    /// </summary>
    public string Filename
    {
        get { return SplashKit.BitmapFilename(this); }
    }
    /// <summary>
    /// Gets or sets the Height property of the Bitmap.
    /// </summary>
    public int Height
    {
        get { return SplashKit.BitmapHeight(this); }
    }
    /// <summary>
    /// Gets or sets the Name property of the Bitmap.
    /// </summary>
    public string Name
    {
        get { return SplashKit.BitmapName(this); }
    }
    /// <summary>
    /// Gets or sets the Width property of the Bitmap.
    /// </summary>
    public int Width
    {
        get { return SplashKit.BitmapWidth(this); }
    }
}
/// <summary>
/// This class represents Display, which wraps a pointer to SplashKit resources.
/// </summary>
public class Display : PointerWrapper
{
  private Display(IntPtr ptr) : base(ptr, true) {}

  internal static Display FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as Display;
    #pragma warning restore CS8603
    return new Display(ptr);
  }

    protected internal override void DoFree()
    {}
    /// <summary>
    /// Gets or sets the Height property of the Display.
    /// </summary>
    public int Height
    {
        get { return SplashKit.DisplayHeight(this); }
    }
    /// <summary>
    /// Gets or sets the Name property of the Display.
    /// </summary>
    public string Name
    {
        get { return SplashKit.DisplayName(this); }
    }
    /// <summary>
    /// Gets or sets the Width property of the Display.
    /// </summary>
    public int Width
    {
        get { return SplashKit.DisplayWidth(this); }
    }
    /// <summary>
    /// Gets or sets the X property of the Display.
    /// </summary>
    public int X
    {
        get { return SplashKit.DisplayX(this); }
    }
    /// <summary>
    /// Gets or sets the Y property of the Display.
    /// </summary>
    public int Y
    {
        get { return SplashKit.DisplayY(this); }
    }
}
/// <summary>
/// This class represents Font, which wraps a pointer to SplashKit resources.
/// </summary>
public class Font : PointerWrapper
{
  private Font(IntPtr ptr) : base(ptr, true) {}

  internal static Font FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as Font;
    #pragma warning restore CS8603
    return new Font(ptr);
  }

    /// <summary>
    /// Creates a new instance of Font using the provided parameters.
    /// </summary>
    /// <param name="name"> The name of the `font` to be loaded from file.</param>
    /// <param name="filename"> The name of the file to load the `font` from.</param>
    public Font(string name, string filename) : base ( SplashKit.LoadFont(name, filename), false )
    { }
    protected internal override void DoFree()
    {
        SplashKit.FreeFont(this);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="fontSize"> The size to check.</param>
    /// <returns>Returns true if the supplied `font` has the supplied size.</returns>
    public bool HasSize(int fontSize)
    {
        return SplashKit.FontHasSize(this, fontSize);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="fontSize"> The desired size of the `font`.</param>
    public void LoadSize(int fontSize)
    {
        SplashKit.FontLoadSize(this, fontSize);
    }

    /// <summary>
    /// 
    /// </summary>
    public void Free()
    {
        SplashKit.FreeFont(this);
    }

    /// <summary>
    /// Gets or sets the Style property of the Font.
    /// </summary>
    public FontStyle Style
    {
        get { return SplashKit.GetFontStyle(this); }
        set { SplashKit.SetFontStyle(this, value); }
    }
}
/// <summary>
/// This class represents HttpResponse, which wraps a pointer to SplashKit resources.
/// </summary>
public class HttpResponse : PointerWrapper
{
  private HttpResponse(IntPtr ptr) : base(ptr, true) {}

  internal static HttpResponse FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as HttpResponse;
    #pragma warning restore CS8603
    return new HttpResponse(ptr);
  }

    protected internal override void DoFree()
    {
        SplashKit.FreeResponse(this);
    }
    /// <summary>
    /// Free the response resource.
    /// </summary>
    public void Free()
    {
        SplashKit.FreeResponse(this);
    }

}
/// <summary>
/// This class represents HttpRequest, which wraps a pointer to SplashKit resources.
/// </summary>
public class HttpRequest : PointerWrapper
{
  private HttpRequest(IntPtr ptr) : base(ptr, true) {}

  internal static HttpRequest FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as HttpRequest;
    #pragma warning restore CS8603
    return new HttpRequest(ptr);
  }

    protected internal override void DoFree()
    {}
    /// <summary>
    /// Checks if a request wants to delete a given resource.
    /// </summary>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is a HTTP DELETE request for `path`</returns>
    public bool IsDeleteRequestFor(string path)
    {
        return SplashKit.IsDeleteRequestFor(this, path);
    }

    /// <summary>
    /// Checks if a request wants to get a given resource.
    /// </summary>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is a HTTP GET request for `path`</returns>
    public bool IsGetRequestFor(string path)
    {
        return SplashKit.IsGetRequestFor(this, path);
    }

    /// <summary>
    /// Checks if a request wants to check options for given resource.
    /// </summary>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is a HTTP OPTIONS request for `path`</returns>
    public bool IsOptionsRequestFor(string path)
    {
        return SplashKit.IsOptionsRequestFor(this, path);
    }

    /// <summary>
    /// Checks if a request wants to create (post) a given resource.
    /// </summary>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is a HTTP POST request for `path`</returns>
    public bool IsPostRequestFor(string path)
    {
        return SplashKit.IsPostRequestFor(this, path);
    }

    /// <summary>
    /// Checks if a request wants to update (put) a given resource.
    /// </summary>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is a HTTP PUT request for `path`</returns>
    public bool IsPutRequestFor(string path)
    {
        return SplashKit.IsPutRequestFor(this, path);
    }

    /// <summary>
    /// Checks if a request is after a given resource.
    /// </summary>
    /// <param name="method"> The kind of request</param>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is for the indicated method and path</returns>
    public bool IsRequestFor(HttpMethod method, string path)
    {
        return SplashKit.IsRequestFor(this, method, path);
    }

    /// <summary>
    /// Checks if a request wants to trace a given resource.
    /// </summary>
    /// <param name="path"> The resource/route path</param>
    /// <returns>True if the request is a HTTP TRACE request for `path`</returns>
    public bool IsTraceRequestFor(string path)
    {
        return SplashKit.IsTraceRequestFor(this, path);
    }

    /// <summary>
    /// Returns true if the parameter exists in the query string.
    /// </summary>
    /// <param name="name"> The name of the parameter to check</param>
    /// <returns>True if the parameter exists in the user's request.</returns>
    public bool HasQueryParameter(string name)
    {
        return SplashKit.RequestHasQueryParameter(this, name);
    }

    /// <summary>
    /// Returns the value of a parameter from within the query string, or the supplied default if no matching parameter is found.
    /// </summary>
    /// <param name="name"> The name of the parameter to fetch</param>
    /// <param name="defaultValue"> The value to return if the named parameter is not in the query string.</param>
    /// <returns>Returns value of the parameter from the query string, or the default value if the parameter is not found.</returns>
    public string QueryParameter(string name, string defaultValue)
    {
        return SplashKit.RequestQueryParameter(this, name, defaultValue);
    }

    /// <summary>
    /// Serves a css file to the given `http_request`.
    /// </summary>
    /// <param name="filename"> The name of the file in Resources/server</param>
    public void SendCSSFileResponse(string filename)
    {
        SplashKit.SendCSSFileResponse(this, filename);
    }

    /// <summary>
    /// Serves a file to the given `http_request`.
    /// </summary>
    /// <param name="filename"> The name of the file in Resources/server</param>
    /// <param name="contentType"> The type of content being send:</param>
    public void SendFileResponse(string filename, string contentType)
    {
        SplashKit.SendFileResponse(this, filename, contentType);
    }

    /// <summary>
    /// Serves a HTML file to the given `http_request`.
    /// </summary>
    /// <param name="filename"> The name of the file in Resources/server</param>
    public void SendHtmlFileResponse(string filename)
    {
        SplashKit.SendHtmlFileResponse(this, filename);
    }

    /// <summary>
    /// Serves a javascript file to the given `http_request`.
    /// </summary>
    /// <param name="filename"> The name of the file in Resources/server</param>
    public void SendJavascriptFileResponse(string filename)
    {
        SplashKit.SendJavascriptFileResponse(this, filename);
    }

    /// <summary>
    /// Sends a response with no content to a `http_request`.
    /// </summary>
    public void SendResponse()
    {
        SplashKit.SendResponse(this);
    }

    /// <summary>
    /// Sends a message to a given `http_request`.
    /// </summary>
    /// <param name="message"> The message to be sent</param>
    public void SendResponse(string message)
    {
        SplashKit.SendResponse(this, message);
    }

    /// <summary>
    /// Sends a response code to a given `http_request`.
    /// </summary>
    /// <param name="code"> The [HTTP status code](See https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) to be sent.</param>
    public void SendResponse(HttpStatusCode code)
    {
        SplashKit.SendResponse(this, code);
    }

    /// <summary>
    /// Sends a message to a given `http_request` with the specified content type.
    /// </summary>
    /// <param name="code"> The [HTTP status code](See https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) to be sent.</param>
    /// <param name="message"> The messsage, in the form of a `http_response`, to be sent.</param>
    public void SendResponse(HttpStatusCode code, string message)
    {
        SplashKit.SendResponse(this, code, message);
    }

    /// <summary>
    /// Sends a message to a given `http_request` with the specified content type.
    /// </summary>
    /// <param name="code"> The [HTTP status code](See https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) to be sent.</param>
    /// <param name="message"> The messsage, in the form of a `http_response`, to be sent.</param>
    /// <param name="contentType"> The content type of the response.</param>
    public void SendResponse(HttpStatusCode code, string message, string contentType)
    {
        SplashKit.SendResponse(this, code, message, contentType);
    }

    /// <summary>
    /// Sends a message to a given `http_request` with the specified content type.
    /// </summary>
    /// <param name="code"> The [HTTP status code](See https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) to be sent.</param>
    /// <param name="message"> The messsage, in the form of a `http_response`, to be sent.</param>
    /// <param name="contentType"> The content type of the response.</param>
    /// <param name="headers"> The response headers</param>
    public void SendResponse(HttpStatusCode code, string message, string contentType, List<string> headers)
    {
        SplashKit.SendResponse(this, code, message, contentType, headers);
    }

    /// <summary>
    /// Send a JSON response to a given `http_request`
    /// </summary>
    /// <param name="j"> The json to be sent.</param>
    public void SendResponse(Json j)
    {
        SplashKit.SendResponse(this, j);
    }

    /// <summary>
    /// Gets or sets the Body property of the HttpRequest.
    /// </summary>
    public string Body
    {
        get { return SplashKit.RequestBody(this); }
    }
    /// <summary>
    /// Gets or sets the Headers property of the HttpRequest.
    /// </summary>
    public List<string> Headers
    {
        get { return SplashKit.RequestHeaders(this); }
    }
    /// <summary>
    /// Gets or sets the Method property of the HttpRequest.
    /// </summary>
    public HttpMethod Method
    {
        get { return SplashKit.RequestMethod(this); }
    }
    /// <summary>
    /// Gets or sets the QueryString property of the HttpRequest.
    /// </summary>
    public string QueryString
    {
        get { return SplashKit.RequestQueryString(this); }
    }
    /// <summary>
    /// Gets or sets the URI property of the HttpRequest.
    /// </summary>
    public string URI
    {
        get { return SplashKit.RequestURI(this); }
    }
    /// <summary>
    /// Gets or sets the URIStubs property of the HttpRequest.
    /// </summary>
    public List<string> URIStubs
    {
        get { return SplashKit.RequestURIStubs(this); }
    }
}
/// <summary>
/// This class represents WebServer, which wraps a pointer to SplashKit resources.
/// </summary>
public class WebServer : PointerWrapper
{
  private WebServer(IntPtr ptr) : base(ptr, true) {}

  internal static WebServer FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as WebServer;
    #pragma warning restore CS8603
    return new WebServer(ptr);
  }

    /// <summary>
    /// Creates a new instance of WebServer using the provided parameters.
    /// </summary>
    public WebServer() : base ( SplashKit.StartWebServer(), false )
    { }
    /// <summary>
    /// Creates a new instance of WebServer using the provided parameters.
    /// </summary>
    /// <param name="port"> The port number to connect through.</param>
    public WebServer(ushort port) : base ( SplashKit.StartWebServer(port), false )
    { }
    protected internal override void DoFree()
    {
        SplashKit.StopWebServer(this);
    }
    /// <summary>
    /// Stops a given `web_server` instance.
    /// </summary>
    public void Stop()
    {
        SplashKit.StopWebServer(this);
    }

    /// <summary>
    /// Gets or sets the HasIncomingRequests property of the WebServer.
    /// </summary>
    public bool HasIncomingRequests
    {
        get { return SplashKit.HasIncomingRequests(this); }
    }
    /// <summary>
    /// Gets or sets the NextWebRequest property of the WebServer.
    /// </summary>
    public HttpRequest NextWebRequest
    {
        get { return SplashKit.NextWebRequest(this); }
    }
}
/// <summary>
/// This class represents Window, which wraps a pointer to SplashKit resources.
/// </summary>
public class Window : PointerWrapper
{
  private Window(IntPtr ptr) : base(ptr, true) {}

  internal static Window FetchOrCreate(IntPtr ptr)
  {
    #pragma warning disable CS8603
    if (ptr == IntPtr.Zero) return null;

    if (_ptrRegister.ContainsKey(ptr)) return _ptrRegister[ptr] as Window;
    #pragma warning restore CS8603
    return new Window(ptr);
  }

    /// <summary>
    /// Creates a new instance of Window using the provided parameters.
    /// </summary>
    /// <param name="caption"> The title of the window. If a window with this caption already exists, SplashKit will alter the caption to ensure that it is unique.</param>
    /// <param name="width"> The width of the window</param>
    /// <param name="height"> The height of the window</param>
    public Window(string caption, int width, int height) : base ( SplashKit.OpenWindow(caption, width, height), false )
    { }
    protected internal override void DoFree()
    {
        SplashKit.CloseWindow(this);
    }
    /// <summary>
    /// Draw a circle onto the destination window. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    public void DrawCircle(Color clr, double x, double y, double radius)
    {
        SplashKit.DrawCircleOnWindow(this, clr, x, y, radius);
    }

    /// <summary>
    /// Draw a circle to the window using the supplied drawing options. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public void DrawCircle(Color clr, double x, double y, double radius, DrawingOptions opts)
    {
        SplashKit.DrawCircleOnWindow(this, clr, x, y, radius, opts);
    }

    /// <summary>
    /// Fill a circle onto the destination window. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    public void FillCircle(Color clr, double x, double y, double radius)
    {
        SplashKit.FillCircleOnWindow(this, clr, x, y, radius);
    }

    /// <summary>
    /// Fill a circle to the window using the supplied drawing options. The circle is centred on its x, y coordinates, and has the provided radius.
    /// </summary>
    /// <param name="clr"> The color of the circle</param>
    /// <param name="x"> The x location of the circle</param>
    /// <param name="y"> The y location of the circle</param>
    /// <param name="radius"> The radius of the circle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public void FillCircle(Color clr, double x, double y, double radius, DrawingOptions opts)
    {
        SplashKit.FillCircleOnWindow(this, clr, x, y, radius, opts);
    }

    /// <summary>
    /// Draws an ellipse on the given window, using the provided location, and size.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    public void DrawEllipse(Color clr, Rectangle rect)
    {
        SplashKit.DrawEllipseOnWindow(this, clr, rect);
    }

    /// <summary>
    /// Draws an ellipse on the given window, using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawEllipse(Color clr, Rectangle rect, DrawingOptions opts)
    {
        SplashKit.DrawEllipseOnWindow(this, clr, rect, opts);
    }

    /// <summary>
    /// Draws an ellipse on the given window, using the provided location, and size.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or window to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or window to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    public void DrawEllipse(Color clr, double x, double y, double width, double height)
    {
        SplashKit.DrawEllipseOnWindow(this, clr, x, y, width, height);
    }

    /// <summary>
    /// Draws an ellipse to the window, using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or window to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or window to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawEllipse(Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
        SplashKit.DrawEllipseOnWindow(this, clr, x, y, width, height, opts);
    }

    /// <summary>
    /// Fill an ellipse on the given window, using the provided location, and size.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    public void FillEllipse(Color clr, Rectangle rect)
    {
        SplashKit.FillEllipseOnWindow(this, clr, rect);
    }

    /// <summary>
    /// Fills an ellipse on the given window, using the provided location, size, and drawing options.  At this stage ellipse drawing is not affected by line width from the drawing options.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="rect"> Indicates the location and size of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public void FillEllipse(Color clr, Rectangle rect, DrawingOptions opts)
    {
        SplashKit.FillEllipseOnWindow(this, clr, rect, opts);
    }

    /// <summary>
    /// Fills an ellipse on the given window, using the provided location, and size.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or window to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or window to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    public void FillEllipse(Color clr, double x, double y, double width, double height)
    {
        SplashKit.FillEllipseOnWindow(this, clr, x, y, width, height);
    }

    /// <summary>
    /// Fills an ellipse on the given window, using the provided location, size, and drawing options.
    /// </summary>
    /// <param name="clr"> The color of the ellipse</param>
    /// <param name="x"> The distance from the left of the bitmap or window to the left edge of the ellipse</param>
    /// <param name="y"> The distance from the top of the bitmap or window to the top edge of the ellipse</param>
    /// <param name="width"> The width of the ellipse</param>
    /// <param name="height"> The height of the ellipse</param>
    /// <param name="opts"> The drawing options</param>
    public void FillEllipse(Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
        SplashKit.FillEllipseOnWindow(this, clr, x, y, width, height, opts);
    }

    /// <summary>
    /// Draws the bitmap supplied into `bmp` to the given window. at `x` and `y`.
    /// </summary>
    /// <param name="bmp"> the bitmap which will be drawn to the screen</param>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    public void DrawBitmap(Bitmap bmp, double x, double y)
    {
        SplashKit.DrawBitmapOnWindow(this, bmp, x, y);
    }

    /// <summary>
    /// Draws the bitmap supplied into `bmp` to the given window. with extra drawing options supplied in `opts` at `x` and `y`.
    /// </summary>
    /// <param name="bmp"> the bitmap which will be drawn to the screen</param>
    /// <param name="x"> the x location which represents where the bitmap will be drawn</param>
    /// <param name="y"> the y location which represents where the bitmap will be drawn</param>
    /// <param name="opts"> the `drawing_options` which provide extra information for how to draw the `bitmap`</param>
    public void DrawBitmap(Bitmap bmp, double x, double y, DrawingOptions opts)
    {
        SplashKit.DrawBitmapOnWindow(this, bmp, x, y, opts);
    }

    /// <summary>
    /// Draws a line onto the given window.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="l"> The line's details</param>
    public void DrawLine(Color clr, Line l)
    {
        SplashKit.DrawLineOnWindow(this, clr, l);
    }

    /// <summary>
    /// Draws a line on the given window.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="l"> The line's details</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawLine(Color clr, Line l, DrawingOptions opts)
    {
        SplashKit.DrawLineOnWindow(this, clr, l, opts);
    }

    /// <summary>
    /// Draw a line from one point to another on the given window.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="fromPt"> The start of the line</param>
    /// <param name="toPt"> The end of the line</param>
    public void DrawLine(Color clr, Point2D fromPt, Point2D toPt)
    {
        SplashKit.DrawLineOnWindow(this, clr, fromPt, toPt);
    }

    /// <summary>
    /// Draw a line from one point to another on the given window.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="fromPt"> The start of the line</param>
    /// <param name="toPt"> The end of the line</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawLine(Color clr, Point2D fromPt, Point2D toPt, DrawingOptions opts)
    {
        SplashKit.DrawLineOnWindow(this, clr, fromPt, toPt, opts);
    }

    /// <summary>
    /// Draw a line from one point to another on the given window.
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="x1"> The distance from the left of the window/bitmap to the first point</param>
    /// <param name="y1"> The distance from the top of the window/bitmap to the first point</param>
    /// <param name="x2"> The distance from the left of the window/bitmap to the second point</param>
    /// <param name="y2"> The distance from the top of the window/bitmap to the second point</param>
    public void DrawLine(Color clr, double x1, double y1, double x2, double y2)
    {
        SplashKit.DrawLineOnWindow(this, clr, x1, y1, x2, y2);
    }

    /// <summary>
    /// Draw a line from one point to another
    /// </summary>
    /// <param name="clr"> The color of the line</param>
    /// <param name="x1"> The distance from the left of the window/bitmap to the first point</param>
    /// <param name="y1"> The distance from the top of the window/bitmap to the first point</param>
    /// <param name="x2"> The distance from the left of the window/bitmap to the second point</param>
    /// <param name="y2"> The distance from the top of the window/bitmap to the second point</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawLine(Color clr, double x1, double y1, double x2, double y2, DrawingOptions opts)
    {
        SplashKit.DrawLineOnWindow(this, clr, x1, y1, x2, y2, opts);
    }

    /// <summary>
    /// Draw a quad on the supplied window to the current window.
    /// </summary>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    public void DrawQuad(Color clr, Quad q)
    {
        SplashKit.DrawQuadOnWindow(this, clr, q);
    }

    /// <summary>
    /// Draw a quad on the supplied window using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawQuad(Color clr, Quad q, DrawingOptions opts)
    {
        SplashKit.DrawQuadOnWindow(this, clr, q, opts);
    }

    /// <summary>
    /// Draw a rectangle to the window using the supplied rect. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> the rectangle to be drawn to the window</param>
    public void DrawRectangle(Color clr, Rectangle rect)
    {
        SplashKit.DrawRectangleOnWindow(this, clr, rect);
    }

    /// <summary>
    /// Draw a rectangle to the window using the supplied rect and drawing options. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> the rectangle to be drawn to the window</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public void DrawRectangle(Color clr, Rectangle rect, DrawingOptions opts)
    {
        SplashKit.DrawRectangleOnWindow(this, clr, rect, opts);
    }

    /// <summary>
    /// Draw a rectangle to the window using. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The x location of the rectangle</param>
    /// <param name="y"> The y location of the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    public void DrawRectangle(Color clr, double x, double y, double width, double height)
    {
        SplashKit.DrawRectangleOnWindow(this, clr, x, y, width, height);
    }

    /// <summary>
    /// Draw a rectangle to the window using the supplied drawing options. The rectangle is centred on its x, y coordinates, and has the provided width and height.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The x location of the rectangle</param>
    /// <param name="y"> The y location of the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    /// <param name="opts"> Drawing options to configure the drawing operation</param>
    public void DrawRectangle(Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
        SplashKit.DrawRectangleOnWindow(this, clr, x, y, width, height, opts);
    }

    /// <summary>
    /// Fill a quad on the supplied window on the current window.
    /// </summary>
    /// <param name="clr"> The color for the quad</param>
    /// <param name="q"> The details of the quad</param>
    public void FillQuad(Color clr, Quad q)
    {
        SplashKit.FillQuadOnWindow(this, clr, q);
    }

    /// <summary>
    /// Fill a rectangle on the supplied window onto the current window.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> The rectangle to draw</param>
    public void FillRectangle(Color clr, Rectangle rect)
    {
        SplashKit.FillRectangleOnWindow(this, clr, rect);
    }

    /// <summary>
    /// Fills a rectangle on the supplied window using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="rect"> The rectangle to draw</param>
    /// <param name="opts"> The drawing options</param>
    public void FillRectangle(Color clr, Rectangle rect, DrawingOptions opts)
    {
        SplashKit.FillRectangleOnWindow(this, clr, rect, opts);
    }

    /// <summary>
    /// Fills a rectangle on the supplied window to the current window.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The distance from the left of the window/bitmap to the rectangle</param>
    /// <param name="y"> The distance from the top of the window/bitmap to the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    public void FillRectangle(Color clr, double x, double y, double width, double height)
    {
        SplashKit.FillRectangleOnWindow(this, clr, x, y, width, height);
    }

    /// <summary>
    /// Fills a rectangle on the supplied window, using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color of the rectangle</param>
    /// <param name="x"> The distance from the left of the window/bitmap to the rectangle</param>
    /// <param name="y"> The distance from the top of the window/bitmap to the rectangle</param>
    /// <param name="width"> The width of the rectangle</param>
    /// <param name="height"> The height of the rectangle</param>
    /// <param name="opts"> The drawing options</param>
    public void FillRectangle(Color clr, double x, double y, double width, double height, DrawingOptions opts)
    {
        SplashKit.FillRectangleOnWindow(this, clr, x, y, width, height, opts);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The name of the `font` which will be used to draw the text</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public void DrawText(string text, Color clr, string fnt, int fontSize, double x, double y)
    {
        SplashKit.DrawTextOnWindow(this, text, clr, fnt, fontSize, x, y);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The name of the `font` which will be used to draw the text</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public void DrawText(string text, Color clr, string fnt, int fontSize, double x, double y, DrawingOptions opts)
    {
        SplashKit.DrawTextOnWindow(this, text, clr, fnt, fontSize, x, y, opts);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public void DrawText(string text, Color clr, double x, double y)
    {
        SplashKit.DrawTextOnWindow(this, text, clr, x, y);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public void DrawText(string text, Color clr, double x, double y, DrawingOptions opts)
    {
        SplashKit.DrawTextOnWindow(this, text, clr, x, y, opts);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The `font` to be used to draw the text.</param>
    /// <param name="fontSize"> The size of the font which will be drawn.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    public void DrawText(string text, Color clr, Font fnt, int fontSize, double x, double y)
    {
        SplashKit.DrawTextOnWindow(this, text, clr, fnt, fontSize, x, y);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to be written to the window.</param>
    /// <param name="clr"> The desired `color` of the text to be written.</param>
    /// <param name="fnt"> The `font` to be used to draw the text.</param>
    /// <param name="fontSize"> The desired size of the font.</param>
    /// <param name="x"> The x location to draw the text.</param>
    /// <param name="y"> The y location to draw the text.</param>
    /// <param name="opts"> The `drawing_options` which provide extra information for how to draw the text.</param>
    public void DrawText(string text, Color clr, Font fnt, int fontSize, double x, double y, DrawingOptions opts)
    {
        SplashKit.DrawTextOnWindow(this, text, clr, fnt, fontSize, x, y, opts);
    }

    /// <summary>
    /// Draw a triangle on a given window, using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    public void DrawTriangle(Color clr, Triangle tri)
    {
        SplashKit.DrawTriangleOnWindow(this, clr, tri);
    }

    /// <summary>
    /// Draw a triangle on a given window, using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawTriangle(Color clr, Triangle tri, DrawingOptions opts)
    {
        SplashKit.DrawTriangleOnWindow(this, clr, tri, opts);
    }

    /// <summary>
    /// Draw a triangle to the given window.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the window to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the window to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the window to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the window to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the window to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the window to the third point of the triangle</param>
    public void DrawTriangle(Color clr, double x1, double y1, double x2, double y2, double x3, double y3)
    {
        SplashKit.DrawTriangleOnWindow(this, clr, x1, y1, x2, y2, x3, y3);
    }

    /// <summary>
    /// Draw a triangle to the given window, using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap/window to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap/window to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap/window to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap/window to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap/window to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap/window to the third point of the triangle</param>
    /// <param name="opts"> The drawing options</param>
    public void DrawTriangle(Color clr, double x1, double y1, double x2, double y2, double x3, double y3, DrawingOptions opts)
    {
        SplashKit.DrawTriangleOnWindow(this, clr, x1, y1, x2, y2, x3, y3, opts);
    }

    /// <summary>
    /// Fill a triangle on a given window
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    public void FillTriangle(Color clr, Triangle tri)
    {
        SplashKit.FillTriangleOnWindow(this, clr, tri);
    }

    /// <summary>
    /// Fill a triangle on a given window, using given drawing options
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="tri"> The triangles details</param>
    /// <param name="opts"> The drawing options</param>
    public void FillTriangle(Color clr, Triangle tri, DrawingOptions opts)
    {
        SplashKit.FillTriangleOnWindow(this, clr, tri, opts);
    }

    /// <summary>
    /// Fill a triangle on a given window
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the window to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the window to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the window to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the window to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the window to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the window to the third point of the triangle</param>
    public void FillTriangle(Color clr, double x1, double y1, double x2, double y2, double x3, double y3)
    {
        SplashKit.FillTriangleOnWindow(this, clr, x1, y1, x2, y2, x3, y3);
    }

    /// <summary>
    /// Fill a triangle on a given window, using the supplied drawing options.
    /// </summary>
    /// <param name="clr"> The color for the triangle</param>
    /// <param name="x1"> The distance from the left side of the bitmap/window to the first point of the triangle</param>
    /// <param name="y1"> The distance from the top of the bitmap/window to the first point of the triangle</param>
    /// <param name="x2"> The distance from the left side of the bitmap/window to the second point of the triangle</param>
    /// <param name="y2"> The distance from the top of the bitmap/window to the second point of the triangle</param>
    /// <param name="x3"> The distance from the left side of the bitmap/window to the third point of the triangle</param>
    /// <param name="y3"> The distance from the top of the bitmap/window to the third point of the triangle</param>
    /// <param name="opts"> The drawing options</param>
    public void FillTriangle(Color clr, double x1, double y1, double x2, double y2, double x3, double y3, DrawingOptions opts)
    {
        SplashKit.FillTriangleOnWindow(this, clr, x1, y1, x2, y2, x3, y3, opts);
    }

    /// <summary>
    /// clears a window to the specified color given in `clr`
    /// </summary>
    /// <param name="clr"> the `color` to clear the window to.</param>
    public void Clear(Color clr)
    {
        SplashKit.ClearWindow(this, clr);
    }

    /// <summary>
    /// Closes and frees the graphics window supplied in `wind`.
    /// </summary>
    public void Close()
    {
        SplashKit.CloseWindow(this);
    }

    /// <summary>
    /// Move the window to the new location on the displays.
    /// </summary>
    /// <param name="x"> The new x location</param>
    /// <param name="y"> The new y location</param>
    public void MoveTo(int x, int y)
    {
        SplashKit.MoveWindowTo(this, x, y);
    }

    /// <summary>
    /// Refreshes the window `wind`.
    /// </summary>
    public void Refresh()
    {
        SplashKit.RefreshWindow(this);
    }

    /// <summary>
    /// Refreshes the window `wind`.
    /// </summary>
    /// <param name="targetFps"> the desired framerate</param>
    public void Refresh(uint targetFps)
    {
        SplashKit.RefreshWindow(this, targetFps);
    }

    /// <summary>
    /// Change the size of the window.
    /// </summary>
    /// <param name="width"> Its new width</param>
    /// <param name="height"> Its new height</param>
    public void Resize(int width, int height)
    {
        SplashKit.ResizeWindow(this, width, height);
    }

    /// <summary>
    /// Change the current window. Use this so that you can draw to different windows by default.
    /// </summary>
    public void MakeCurrent()
    {
        SplashKit.SetCurrentWindow(this);
    }

    /// <summary>
    /// Toggle the window border.
    /// </summary>
    public void ToggleBorder()
    {
        SplashKit.WindowToggleBorder(this);
    }

    /// <summary>
    /// Toggle the fullscreen property of the window
    /// </summary>
    public void ToggleFullscreen()
    {
        SplashKit.WindowToggleFullscreen(this);
    }

    /// <summary>
    /// Gets or sets the Area property of the Window.
    /// </summary>
    public Rectangle Area
    {
        get { return SplashKit.WindowArea(this); }
    }
    /// <summary>
    /// Gets or sets the IsCurrentWindow property of the Window.
    /// </summary>
    public bool IsCurrentWindow
    {
        get { return SplashKit.IsCurrentWindow(this); }
    }
    /// <summary>
    /// Gets or sets the Caption property of the Window.
    /// </summary>
    public string Caption
    {
        get { return SplashKit.WindowCaption(this); }
    }
    /// <summary>
    /// Gets or sets the CloseRequested property of the Window.
    /// </summary>
    public bool CloseRequested
    {
        get { return SplashKit.WindowCloseRequested(this); }
    }
    /// <summary>
    /// Gets or sets the HasBorder property of the Window.
    /// </summary>
    public bool HasBorder
    {
        get { return SplashKit.WindowHasBorder(this); }
    }
    /// <summary>
    /// Gets or sets the HasFocus property of the Window.
    /// </summary>
    public bool HasFocus
    {
        get { return SplashKit.WindowHasFocus(this); }
    }
    /// <summary>
    /// Gets or sets the Height property of the Window.
    /// </summary>
    public int Height
    {
        get { return SplashKit.WindowHeight(this); }
    }
    /// <summary>
    /// Gets or sets the IsFullscreen property of the Window.
    /// </summary>
    public bool IsFullscreen
    {
        get { return SplashKit.WindowIsFullscreen(this); }
    }
    /// <summary>
    /// Gets or sets the Position property of the Window.
    /// </summary>
    public Point2D Position
    {
        get { return SplashKit.WindowPosition(this); }
    }
    /// <summary>
    /// Gets or sets the Icon property of the Window.
    /// </summary>
    public Bitmap Icon
    {
        set { SplashKit.WindowSetIcon(this, value); }
    }
    /// <summary>
    /// Gets or sets the Width property of the Window.
    /// </summary>
    public int Width
    {
        get { return SplashKit.WindowWidth(this); }
    }
    /// <summary>
    /// Gets or sets the X property of the Window.
    /// </summary>
    public int X
    {
        get { return SplashKit.WindowX(this); }
    }
    /// <summary>
    /// Gets or sets the Y property of the Window.
    /// </summary>
    public int Y
    {
        get { return SplashKit.WindowY(this); }
    }
}
/// <summary>
/// Static methods for working with Audio in the SplashKit framework.
/// </summary>
public static class Audio{
    /// <summary>
    /// Fades music outover a specified number of milliseconds
    /// </summary>
    /// <param name="ms"> How many milliseconds it takes to fade the `music` out</param>
    public static void FadeOut(int ms)
    {
        SplashKit.FadeMusicOut(ms);
    }

    /// <summary>
    /// Releases all of the music files that have been loaded.
    /// </summary>
    public static void FreeAllMusic()
    {
        SplashKit.FreeAllMusic();
    }

    /// <summary>
    /// Pauses currently playing music - see resume_music to continue playing.
    /// </summary>
    public static void Pause()
    {
        SplashKit.PauseMusic();
    }

    /// <summary>
    /// Resumes currently paused music - see pause_music to pause playing music.
    /// </summary>
    public static void Resume()
    {
        SplashKit.ResumeMusic();
    }

    /// <summary>
    /// Stops currently playing music.
    /// </summary>
    public static void Stop()
    {
        SplashKit.StopMusic();
    }

    /// <summary>
    /// Gets or sets the IsReady property of the Audio.
    /// </summary>
    public static bool IsReady
    {
        get { return SplashKit.AudioReady(); }
    }
    /// <summary>
    /// Gets or sets the Playing property of the Audio.
    /// </summary>
    public static bool Playing
    {
        get { return SplashKit.MusicPlaying(); }
    }
    /// <summary>
    /// Gets or sets the Volume property of the Audio.
    /// </summary>
    public static double Volume
    {
        get { return SplashKit.MusicVolume(); }
        set { SplashKit.SetMusicVolume(value); }
    }
}
/// <summary>
/// Static methods for working with Camera in the SplashKit framework.
/// </summary>
public static class Camera{
    /// <summary>
    /// Set the camera view to be centered over the specific sprite. The offset vector allows you to move the sprite from the direct center of the screen.
    /// </summary>
    /// <param name="s"> The sprite to track.</param>
    /// <param name="offset"> The amount to offset the camera, allowing you to position the sprite away from the center of the screen.</param>
    public static void CenterOn(Sprite s, Vector2D offset)
    {
        SplashKit.CenterCameraOn(s, offset);
    }

    /// <summary>
    /// Set the camera view to be centered over the specific sprite. The offset vector allows you to move the sprite from the direct center of the screen.
    /// </summary>
    /// <param name="s"> The sprite to track.</param>
    /// <param name="offsetX"> An additional offset added to the camera, allowing you to position the sprite offset from the center of the screen.</param>
    /// <param name="offsetY"> An additional offset added to the camera, allowing you to position the sprite offset from the center of the screen.</param>
    public static void CenterOn(Sprite s, double offsetX, double offsetY)
    {
        SplashKit.CenterCameraOn(s, offsetX, offsetY);
    }

    /// <summary>
    /// Move the camera (offset its world x and y values) using the specified vector. For example, if you move the camera by the same speed vector of a sprite the camera will "track" (be locked on to) the sprite as it moves.
    /// </summary>
    /// <param name="offset"> The amount to move the camera.</param>
    public static void MoveBy(Vector2D offset)
    {
        SplashKit.MoveCameraBy(offset);
    }

    /// <summary>
    /// Move the camera (offset its world x and y values) using the specified dx (change in x) and dy (change in x) values.
    /// </summary>
    /// <param name="dx"> The amount to move the camera along the x axis.</param>
    /// <param name="dy"> The amount to move the camera along the y axis.</param>
    public static void MoveBy(double dx, double dy)
    {
        SplashKit.MoveCameraBy(dx, dy);
    }

    /// <summary>
    /// Move the camera view (screen top left) to a specified point in the world. This will be the new top left corner of the screen.
    /// </summary>
    /// <param name="pt"> The new camera location</param>
    public static void MoveTo(Point2D pt)
    {
        SplashKit.MoveCameraTo(pt);
    }

    /// <summary>
    /// Move the camera view to a world location specified by the x and y values. This will be the new top left corner of the screen.
    /// </summary>
    /// <param name="x"> The new camera x location</param>
    /// <param name="y"> The new camera y location</param>
    public static void MoveTo(double x, double y)
    {
        SplashKit.MoveCameraTo(x, y);
    }

    /// <summary>
    /// Tests if the point is in the window.
    /// </summary>
    /// <param name="wind"> The window to check</param>
    /// <param name="pt"> The point to check.</param>
    /// <returns>True if the point is on the screen.</returns>
    public static bool PointInWindow(Window wind, Point2D pt)
    {
        return SplashKit.PointInWindow(wind, pt);
    }

    /// <summary>
    /// Tests if the point is on the screen.
    /// </summary>
    /// <param name="pt"> The point to check.</param>
    /// <returns>True if the point is on the screen.</returns>
    public static bool PointOnScreen(Point2D pt)
    {
        return SplashKit.PointOnScreen(pt);
    }

    /// <summary>
    /// Tests if the rectangle is within the bounds of the window.
    /// </summary>
    /// <param name="wind"> The window to check</param>
    /// <param name="rect"> The rectangle to check.</param>
    /// <returns>True if any part of the rectangle is in the window.</returns>
    public static bool RectInWindow(Window wind, Rectangle rect)
    {
        return SplashKit.RectInWindow(wind, rect);
    }

    /// <summary>
    /// Tests if the rectangle is on the screen.
    /// </summary>
    /// <param name="rect"> The rectangle to check.</param>
    /// <returns>True if any part of the rectangle is on the screen.</returns>
    public static bool RectOnScreen(Rectangle rect)
    {
        return SplashKit.RectOnScreen(rect);
    }

    /// <summary>
    /// Convert the passed in world coordinates to screen coordinates.
    /// </summary>
    /// <param name="pt"> The point to convert - this should be in world coordinates.</param>
    /// <returns>A point that represents pt in screen coordinates.</returns>
    public static Point2D ToScreen(Point2D pt)
    {
        return SplashKit.ToScreen(pt);
    }

    /// <summary>
    /// Convert the rectangle in world coordinates to screen coordinates.
    /// </summary>
    /// <param name="rect"> The rectangle to convert - this should be in world coordinates.</param>
    /// <returns>A rectangle that represents rect in screen coordinates.</returns>
    public static Rectangle ToScreen(Rectangle rect)
    {
        return SplashKit.ToScreen(rect);
    }

    /// <summary>
    /// Translate a world x value to the current screen x value which is based on the camera position.
    /// </summary>
    /// <param name="worldX"> The value of the x coordinate to translate to screen.</param>
    /// <returns>The x location of the world coordinate on the screen.</returns>
    public static double ToScreenX(double worldX)
    {
        return SplashKit.ToScreenX(worldX);
    }

    /// <summary>
    /// Translate a world y value to the current screen y value set by the camera.
    /// </summary>
    /// <param name="worldY"> The value of the y coordinate to translate to screen.</param>
    /// <returns>The y location of the world coordinate on the screen.</returns>
    public static double ToScreenY(double worldY)
    {
        return SplashKit.ToScreenY(worldY);
    }

    /// <summary>
    /// Converts the passed in point from screen coordinates to world coordinates.
    /// </summary>
    /// <param name="pt"> The point in screen coordinates.</param>
    /// <returns>The same point in world coordinates.</returns>
    public static Point2D ToWorld(Point2D pt)
    {
        return SplashKit.ToWorld(pt);
    }

    /// <summary>
    /// Translate a screen x value (based on the camera) to a world x value
    /// </summary>
    /// <param name="screenX"> The value of the x coordinate on screen to translate to the world.</param>
    /// <returns>The x location of the screen coordinate in the world.</returns>
    public static double ToWorldX(double screenX)
    {
        return SplashKit.ToWorldX(screenX);
    }

    /// <summary>
    /// Translate a screen y value (based on the camera) to a world y value
    /// </summary>
    /// <param name="screenY"> The value of the y coordinate on screen to translate to the world.</param>
    /// <returns>The y location of the screen coordinate in the world.</returns>
    public static double ToWorldY(double screenY)
    {
        return SplashKit.ToWorldY(screenY);
    }

    /// <summary>
    /// Gets or sets the Position property of the Camera.
    /// </summary>
    public static Point2D Position
    {
        get { return SplashKit.CameraPosition(); }
        set { SplashKit.SetCameraPosition(value); }
    }
    /// <summary>
    /// Gets or sets the X property of the Camera.
    /// </summary>
    public static double X
    {
        get { return SplashKit.CameraX(); }
        set { SplashKit.SetCameraX(value); }
    }
    /// <summary>
    /// Gets or sets the Y property of the Camera.
    /// </summary>
    public static double Y
    {
        get { return SplashKit.CameraY(); }
        set { SplashKit.SetCameraY(value); }
    }
    /// <summary>
    /// Gets or sets the ScreenCenter property of the Camera.
    /// </summary>
    public static Point2D ScreenCenter
    {
        get { return SplashKit.ScreenCenter(); }
    }
    /// <summary>
    /// Gets or sets the ScreenRectangle property of the Camera.
    /// </summary>
    public static Rectangle ScreenRectangle
    {
        get { return SplashKit.ScreenRectangle(); }
    }
    /// <summary>
    /// Gets or sets the VectorWorldToScreen property of the Camera.
    /// </summary>
    public static Vector2D VectorWorldToScreen
    {
        get { return SplashKit.VectorWorldToScreen(); }
    }
}
/// <summary>
/// Static methods for working with Networking in the SplashKit framework.
/// </summary>
public static class Networking{
    /// <summary>
    /// Gets or sets the HasMessages property of the Networking.
    /// </summary>
    public static bool HasMessages
    {
        get { return SplashKit.HasMessages(); }
    }
    /// <summary>
    /// Gets or sets the UDPPacketSize property of the Networking.
    /// </summary>
    public static uint UDPPacketSize
    {
        get { return SplashKit.UDPPacketSize(); }
        set { SplashKit.SetUDPPacketSize(value); }
    }
}
/// <summary>
/// Static methods for working with Text in the SplashKit framework.
/// </summary>
public static class Text{
    /// <summary>
    /// 
    /// </summary>
    public static void FreeAll()
    {
        SplashKit.FreeAllFonts();
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to check the length of.</param>
    /// <param name="fnt"> The font used for the text.</param>
    /// <param name="fontSize"> The size of the font used for the text.</param>
    /// <returns>Returns the height of the text as an integer.</returns>
    public static int Height(string text, string fnt, int fontSize)
    {
        return SplashKit.TextHeight(text, fnt, fontSize);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to check the length of.</param>
    /// <param name="fnt"> The font used for the text.</param>
    /// <param name="fontSize"> The size of the font used for the text.</param>
    /// <returns>Returns the height of the text as an integer.</returns>
    public static int Height(string text, Font fnt, int fontSize)
    {
        return SplashKit.TextHeight(text, fnt, fontSize);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to check the length of.</param>
    /// <param name="fnt"> The font used for the text.</param>
    /// <param name="fontSize"> The size of the font used for the text.</param>
    /// <returns>Returns the width of the text as an integer.</returns>
    public static int Width(string text, string fnt, int fontSize)
    {
        return SplashKit.TextWidth(text, fnt, fontSize);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="text"> The text string to check the length of.</param>
    /// <param name="fnt"> The font used for the text.</param>
    /// <param name="fontSize"> The size of the font used for the text.</param>
    /// <returns>Returns the width of the text as an integer.</returns>
    public static int Width(string text, Font fnt, int fontSize)
    {
        return SplashKit.TextWidth(text, fnt, fontSize);
    }

}
}
